---
title: "ADHDCYCLE Individual GAM Reports"
author: "Tory Eisenlohr-Moul, PhD"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: html_document
---

> **Script Purpose:** This script conducts a comprehensive, automated analysis of symptom cyclicity. The workflow is divided into three main parts:
> 1.  **Setup & Preparation:** Loads packages and data, and defines key parameters.
> 2.  **Automated Reporting:** For each participant, this section runs all necessary models and generates a complete PDF report on-the-fly.
> 3.  **Publication Figure Generation:** Creates a specific figure for publication.

---

### 1. Setup & Configuration

This section prepares everything needed for the analysis.

#### 1.1: Load Libraries
```{r setup}

#install.packages(c("dplyr", "ggplot2", "mgcv", "marginaleffects", "patchwork", "gridExtra", "grid", "tibble", "tidyr"))

# load all packages
library(dplyr)
library(ggplot2)
library(mgcv)
library(marginaleffects)
library(patchwork)
library(gridExtra)
library(grid)
library(tibble)
library(tidyr)
library(knitr)
library(readr)

options(scipen = 999) # turn off scientific notation
set.seed(12345) # for reproducibility

```

#### 1.2: User-Configurable Parameters ⚙️
```{r user-config}
# --- Path to the main output directory ---
gam_output_base <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Study_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/6_GAMs/"

# --- Define all Time Variables to iterate over ---
time_vars_to_run <- c("cyclic_time", "cyclic_time_ov", "cyclic_time_impute", "cyclic_time_imp_ov")

# --- Table Formatting ---
table_cols_per_page <- 6

# --- Plot Layout ---
plots_per_col <- 3
plots_per_row <- 3 
```

#### 1.3: Automatic Setup & Data Load
```{r auto-setup-load}

# --- Create output folder with current date ---
current_date <- format(Sys.Date(), "%Y%m%d")
output_folder <- file.path(gam_output_base, paste0("GAM_Reports_", current_date))
dir.create(output_folder, showWarnings = FALSE, recursive = TRUE)

# --- Load Scaled Dataset ---

cycle_df_scaled <- get(load("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/1_interim_datasets/adhd_daily_df_scaled_20250922.RData"))

names(cycle_df_scaled)

# --- Robustness Check: Verify time variables exist ---
time_vars <- intersect(time_vars_to_run, names(cycle_df_scaled))
if (length(time_vars) < length(time_vars_to_run)) {
  missing_vars <- setdiff(time_vars_to_run, time_vars)
  warning("The following time_vars were not found and will be skipped: ", paste(missing_vars, collapse = ", "))
}
```

```{r}
# ---- Speed helpers: reuse grids and axis meta per time variable ----
pred_grid_list <- setNames(lapply(time_vars, function(tv) {
  df <- data.frame(seq(-1, 1, by = 0.05))
  names(df) <- tv
  df
}), time_vars)

axis_meta <- lapply(time_vars, function(tv) {
  if (grepl("ov", tv, ignore.case = TRUE)) {
    list(labels = c("Menses", "50%F", "Ovulation", "50%L", "Menses"),
         menses = c(-1, 1), ov = 0)
  } else {
    list(labels = c("Ovulation", "50%L", "Menses", "50%F", "Ovulation"),
         menses = 0, ov = c(-1, 1))
  }
})
names(axis_meta) <- time_vars

# ---- Model + predict one outcome for one time variable ----
fit_outcome <- function(dat, outcome_var, tv, outcomes_map, k_max = 10L) {
  log_out <- paste0(outcome_var, "_Log")
  keep <- c(log_out, tv)
  if (!all(keep %in% names(dat))) return(NULL)
  dat <- dat[complete.cases(dat[, keep]), keep, drop = FALSE]
  if (nrow(dat) < 10 || var(dat[[log_out]], na.rm = TRUE) < 1e-6) return(NULL)

  k <- min(k_max, nrow(dat) - 1L)
  if (k < 3L) return(NULL)

  fml <- as.formula(paste0(log_out, " ~ s(", tv, ", bs = 'cc', k = ", k, ")"))
  knots <- setNames(list(c(-1, 1)), tv)

  mf <- try(mgcv::bam(fml, data = dat, knots = knots, method = "fREML",
                      discrete = TRUE, select = TRUE),
            silent = TRUE)
  if (inherits(mf, "try-error")) return(NULL)

  s  <- summary(mf)
  p  <- as.numeric(s$s.pv[1])
  st <- s$s.table
  edf <- suppressWarnings(as.numeric(st[1, "edf"]))
  Fval <- suppressWarnings(as.numeric(st[1, "F"]))

  pg <- pred_grid_list[[tv]]
  pr <- predict(mf, newdata = pg, se.fit = TRUE, type = "link")  # link == identity on log(y+1)
  est <- exp(pr$fit) - 1
  conf.low  <- exp(pr$fit - 1.96 * pr$se.fit) - 1
  conf.high <- exp(pr$fit + 1.96 * pr$se.fit) - 1

  pred <- cbind(pg, estimate = est, conf.low = conf.low, conf.high = conf.high)
  pred$outcome_label <- outcomes_map[[outcome_var]]
  pred$p.value <- p
  pred$raw_range <- diff(range(est, na.rm = TRUE))

  list(
    pred = pred,
    sig  = tibble::tibble(
      variable = outcome_var,
      outcome_label = outcomes_map[[outcome_var]],
      time_var = tv,
      p.value = p,
      edf = edf,
      F = Fval,
      n = nrow(dat),
      range = diff(range(est, na.rm = TRUE))
    )
  )
}

# ---- Plot helper (unchanged aesthetics; just parameterized) ----
create_annotated_plot <- function(plot_df, tv, axis_meta_list) {
  if (is.null(plot_df) || nrow(plot_df) == 0) return(NULL)
  max_pt <- dplyr::slice_max(plot_df, order_by = estimate, n = 1, with_ties = FALSE)
  min_pt <- dplyr::slice_min(plot_df, order_by = estimate, n = 1, with_ties = FALSE)
  rng   <- dplyr::first(plot_df$raw_range)
  p_val <- dplyr::first(plot_df$p.value)
  stars <- dplyr::case_when(p_val < 0.001 ~ "***", p_val < 0.01 ~ "**", p_val < 0.05 ~ "*", TRUE ~ "")
  ann   <- sprintf("%s Range = %.2f", stars, rng)
  meta  <- axis_meta_list[[tv]]

  ggplot2::ggplot(plot_df, ggplot2::aes(x = .data[[tv]], y = estimate)) +
    ggplot2::geom_vline(xintercept = meta$menses, color = "red") +
    ggplot2::geom_vline(xintercept = meta$ov,     color = "forestgreen") +
    ggplot2::geom_line(linewidth = 1, color = "#0072B2") +
    ggplot2::geom_ribbon(ggplot2::aes(ymin = conf.low, ymax = conf.high),
                         alpha = 0.2, fill = "#0072B2") +
    ggplot2::geom_point(data = max_pt, size = 2.5) +
    ggplot2::geom_point(data = min_pt, size = 2.5) +
    ggplot2::annotate("text", x = -1, y = Inf, label = ann,
                      hjust = -0.1, vjust = 1.5, size = 3, fontface = "bold") +
    ggplot2::labs(title = dplyr::first(plot_df$outcome_label), x = "Cycle Phase", y = NULL) +
    ggplot2::scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.5),
                                labels = meta$labels) +
    ggplot2::theme_minimal() +
    ggplot2::theme(plot.title = ggplot2::element_text(size = 10, face = "bold", hjust = 0.5))
}

```

#### 1.4: Define Outcomes, Categories, and Custom Page Layouts
```{r outcomes-and-layouts}
# --- Define Outcomes to Model ---
outcomes <- c(
    "CSS_Inatt_Count" = "CSS Inattention Sx Count", "CSS_Hyp_Count" = "CSS Hyperactivity Sx Count",
    "CSS_Imp_Count" = "CSS Impulsivity Sx Count", "CSS_Inatt" = "CSS Inattention Sx Severity",
    "CSS_HypImp" = "CSS Hyperactivity/Impulsivity Sx Severity", "score_pinball" = "Working Memory Score (Pinball)",
    "score_robot" = "Response Inhibition (Robot Factory)", "BDEFS_WM_avg" = "Working Memory Sx (BDEFS)",
    "BDEFS_RI_avg" = "Response Inhibition Sx (BDEFS)", "DRSP_1" = "Depressed Mood", "DRSP_2" = "Hopelessness",
    "DRSP_3" = "Worthlessness/Guilt", "DRSP_4" = "Anxiety", "DRSP_5" = "Mood Swings",
    "DRSP_6" = "Rejection Sensitivity", "DRSP_7" = "Irritability", "DRSP_8" = "Interpersonal Conflicts",
    "DRSP_9" = "Less Interest in Activities", "DRSP_10" = "Difficulty Concentrating", "DRSP_11" = "Lethargy/Fatigue",
    "DRSP_12" = "Increased Appetite/Overate", "DRSP_13" = "Food Cravings", "DRSP_14" = "Hypersomnia",
    "DRSP_15" = "Insomnia", "DRSP_16" = "Overwhelmed/Couldn't Cope", "DRSP_17" = "Felt Out of Control",
    "DRSP_18" = "Breast Tenderness", "DRSP_19" = "Swelling/Bloating", "DRSP_20" = "Headache",
    "DRSP_21" = "Joint/Muscle Pain", "DRSP_22" = "Work Impairment", "DRSP_23" = "Relationship Impairment",
    "E2" = "Estradiol", "P4" = "Progesterone", "LH" = "Luteinizing Hormone"
)

# --- Define Categories for organization ---
outcome_categories <- tribble(
  ~category, ~variable,
  "ADHD Symptoms (CSS)", "CSS_Inatt_Count", "ADHD Symptoms (CSS)", "CSS_Hyp_Count",
  "ADHD Symptoms (CSS)", "CSS_Imp_Count", "ADHD Symptoms (CSS)", "CSS_Inatt", "ADHD Symptoms (CSS)", "CSS_HypImp",
  "Cognitive Score", "score_pinball", "Cognitive Score", "score_robot",
  "Executive Function (BDEFS)", "BDEFS_WM_avg", "Executive Function (BDEFS)", "BDEFS_RI_avg",
  "Hormone", "E2", "Hormone", "P4", "Hormone", "LH",
  "Mood & Physical (DRSP)", "DRSP_1", "Mood & Physical (DRSP)", "DRSP_2", "Mood & Physical (DRSP)", "DRSP_3",
  "Mood & Physical (DRSP)", "DRSP_4", "Mood & Physical (DRSP)", "DRSP_5", "Mood & Physical (DRSP)", "DRSP_6",
  "Mood & Physical (DRSP)", "DRSP_7", "Mood & Physical (DRSP)", "DRSP_8", "Mood & Physical (DRSP)", "DRSP_9",
  "Mood & Physical (DRSP)", "DRSP_10", "Mood & Physical (DRSP)", "DRSP_11", "Mood & Physical (DRSP)", "DRSP_12",
  "Mood & Physical (DRSP)", "DRSP_13", "Mood & Physical (DRSP)", "DRSP_14", "Mood & Physical (DRSP)", "DRSP_15",
  "Mood & Physical (DRSP)", "DRSP_16", "Mood & Physical (DRSP)", "DRSP_17", "Mood & Physical (DRSP)", "DRSP_18",
  "Mood & Physical (DRSP)", "DRSP_19", "Mood & Physical (DRSP)", "DRSP_20", "Mood & Physical (DRSP)", "DRSP_21",
  "Impairment (DRSP)", "DRSP_22", "Impairment (DRSP)", "DRSP_23"
) %>% right_join(enframe(outcomes, name = "variable", value = "outcome_label"), by = "variable")

# --- Define custom page layouts ---
page_definitions <- c(
  list(
    CSS_Page = outcome_categories %>% filter(category == "ADHD Symptoms (CSS)") %>% pull(outcome_label),
    Hormone_Page = outcome_categories %>% filter(category == "Hormone") %>% pull(outcome_label),
    Cog_EF_Page = c("Response Inhibition (Robot Factory)", "Response Inhibition Sx (BDEFS)", "Working Memory Score (Pinball)", "Working Memory Sx (BDEFS)")
  ),
  split(
    outcome_categories %>% filter(grepl("DRSP", category)) %>% pull(outcome_label),
    ceiling(seq_along(outcome_categories %>% filter(grepl("DRSP", category)) %>% pull(outcome_label)) / 9)
  )
)
names(page_definitions)[4:length(page_definitions)] <- paste0("DRSP_Page_", 1:(length(page_definitions)-3))


# --- Pre-calculate log-transformations ---
for (var in names(outcomes)) {
  if (var %in% names(cycle_df_scaled)) {
    log_var_name <- paste0(var, "_Log")
    cycle_df_scaled[[log_var_name]] <- log(cycle_df_scaled[[var]] + 1)
  }
}
```

---

### 2. Automated Reporting: Generate Comprehensive PDF for Each Participant

This section iterates through every participant, creating a PDF report with a styled summary table and plots of a consistent, fixed size.

```{r automated-reporting}
# === 2. Automated Reporting (Optimized): One PDF per participant + CSV audit ===

report_folder <- file.path(output_folder, "Participant_Reports_PDF_byID")
dir.create(report_folder, showWarnings = FALSE, recursive = TRUE)

ids_to_run   <- unique(cycle_df_scaled$id)  # set to a subset if you want to test, e.g., c("ID001","ID007")
skip_existing <- TRUE                       # set FALSE to overwrite

# collector for a single CSV at the end
all_ids_signif <- list()

# fixed layout controls
max_plots_per_page <- plots_per_col * plots_per_row
table_theme <- gridExtra::ttheme_default(
  base_size = 9,
  core   = list(fg_params = list(hjust = 0, x = 0.05)),
  colhead = list(fg_params = list(hjust = 0, x = 0.05))
)

for (current_id in ids_to_run) {
  message(sprintf("--- Processing ID: %s ---", current_id))
  datSX_id <- subset(cycle_df_scaled, id == current_id)

  # Pass 1: fit everything (fast) and hold predictions/significance in memory
  preds_by_tv <- list()
  sig_by_tv   <- list()

  for (tv in time_vars) {
    message(sprintf("  ... time variable: %s", tv))
    all_preds <- list()
    sig_list  <- list()

    for (outcome_var in names(outcomes)) {
      res <- fit_outcome(datSX_id, outcome_var, tv, outcomes)
      if (is.null(res)) next
      all_preds[[length(all_preds) + 1]] <- res$pred
      sig_list[[length(sig_list) + 1]]  <- res$sig
    }

    if (length(all_preds) > 0) {
      preds_by_tv[[tv]] <- dplyr::bind_rows(all_preds)
      sig_by_tv[[tv]]   <- dplyr::bind_rows(sig_list)
    }
  }

  # Nothing modeled for this ID?
  if (!length(preds_by_tv)) {
    message("    -> No successful models for this ID; skipping.")
    next
  }

  # Build the participant-level significance object and stash for CSV output
  sig_all <- dplyr::bind_rows(sig_by_tv)
  sig_all$id <- current_id
  all_ids_signif[[as.character(current_id)]] <- sig_all

  # Cover page: wide 'stars' table across time variables
  star_tab <- sig_all %>%
    dplyr::mutate(stars = dplyr::case_when(p.value < 0.001 ~ "***",
                                           p.value < 0.01  ~ "**",
                                           p.value < 0.05  ~ "*", TRUE ~ "")) %>%
dplyr::left_join(dplyr::select(outcome_categories, variable, category), by = "variable") %>%
    dplyr::select(Category = category, Outcome = outcome_label, time_var, stars) %>%
    tidyr::pivot_wider(names_from = time_var, values_from = stars, values_fill = "") %>%
    dplyr::arrange(Category, Outcome)

  # Open a single PDF per participant
  pdf_filename <- file.path(report_folder, sprintf("Report_ID_%s.pdf", current_id))
  if (isTRUE(skip_existing) && file.exists(pdf_filename)) {
    message("    -> File exists; skipping. Set skip_existing=FALSE to overwrite.")
    next
  }
  grDevices::pdf(pdf_filename, width = 8.5, height = 11)

  # COVER PAGE
  title_grob    <- grid::textGrob(paste("Cycle Effects Summary (Stars) — ID:", current_id),
                                  gp = grid::gpar(fontsize = 16, fontface = "bold"))
  table_grob    <- gridExtra::tableGrob(star_tab, rows = NULL, theme = table_theme)
  footnote_grob <- grid::textGrob("* p < .05, ** p < .01, *** p < .001",
                                  gp = grid::gpar(fontsize = 9, fontface = "italic"), hjust = 1)
  gridExtra::grid.arrange(title_grob, table_grob, footnote_grob, ncol = 1,
                          heights = grid::unit(c(0.06, 0.89, 0.05), "npc"))

  # PER–TIME VARIABLE sections
  for (tv in names(preds_by_tv)) {

    # Significance table for this tv
    summary_df <- sig_by_tv[[tv]] %>%
dplyr::left_join(dplyr::select(outcome_categories, variable, category), by = "variable") %>%
      dplyr::mutate(stars = dplyr::case_when(p.value < 0.001 ~ "***",
                                             p.value < 0.01  ~ "**",
                                             p.value < 0.05  ~ "*", TRUE ~ "")) %>%
      dplyr::select(Category = category, Outcome = outcome_label,
                    N = n, EDF = edf, F = F, Range = range, Sig = stars) %>%
      dplyr::arrange(Category, Outcome)

    tv_title <- grid::textGrob(paste("Significance — ID:", current_id, "| Time Variable:", tv),
                               gp = grid::gpar(fontsize = 14, fontface = "bold"))
    tv_table <- gridExtra::tableGrob(summary_df, rows = NULL, theme = table_theme)
    gridExtra::grid.arrange(tv_title, tv_table, ncol = 1,
                            heights = grid::unit(c(0.08, 0.92), "npc"))

    # Plots by your predefined pages
    combined_plot_data <- preds_by_tv[[tv]]
    for (page_name in names(page_definitions)) {
      page_outcomes <- page_definitions[[page_name]]
      page_data <- dplyr::filter(combined_plot_data, outcome_label %in% page_outcomes)
      if (nrow(page_data) == 0) next

      plot_list <- lapply(page_outcomes, function(lab) {
        plot_df <- dplyr::filter(page_data, outcome_label == lab)
        create_annotated_plot(plot_df, tv, axis_meta)
      })
      plot_list <- Filter(Negate(is.null), plot_list)

      if (length(plot_list) > 0) {
        # pad to a full grid
        if (length(plot_list) < max_plots_per_page) {
          plot_list <- c(plot_list,
                         rep(list(patchwork::plot_spacer()), max_plots_per_page - length(plot_list)))
        }
        page_title <- paste("Symptom & Hormone Trajectories — ID:", current_id, "| Time Variable:", tv)
        final_page <- patchwork::wrap_plots(plotlist = plot_list, ncol = plots_per_col) +
          patchwork::plot_annotation(
            title = page_title,
            theme = ggplot2::theme(plot.title = ggplot2::element_text(size = 14, face = "bold"))
          )
        print(final_page)
      }
    }
  }

  grDevices::dev.off()
  message(sprintf("    --- ✅ Saved Report: %s ---", pdf_filename))
}

# Write a single long CSV so you can evaluate by participant outside the PDFs
if (length(all_ids_signif)) {
  eval_csv <- file.path(output_folder, paste0("participant_significance_summary_", current_date, ".csv"))
  write.csv(dplyr::bind_rows(all_ids_signif), eval_csv, row.names = FALSE)
  message(sprintf("Wrote summary CSV: %s", eval_csv))
}

```
