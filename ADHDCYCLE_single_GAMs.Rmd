---
title: "ADHDCYCLE_single_GAMs"
author: "Tory Eisenlohr-Moul, PhD"
date: "`r Sys.Date()`"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen = 999) # Turn off scientific notation
options(digits = 3) # Set number of digits to display
```

# Load libraries
```{r}
library(dplyr)
library(tidyr)
library(tidyverse)
library(janitor)
library(readr)
library(haven)
library(zoo)
library(lubridate)
library(conflicted)
library(menstrualcycleR)

conflicts_prefer(dplyr::filter)
```

# Create/Load scaled dataset using the ENT_data_prep_menstrualcycleR Rmd in the working directory

```{r}

View(cycle_df_scaled)
names(cycle_df_scaled)
str(cycle_df_scaled)
```


# Loop Over and Save all GAMMs and Model-Implied Plots - Cyclic Time (No Imputation) and Log Transformation of all Outcomes

```{r}
# --- 1. Setup ---
# Assumes 'cycle_df_scaled' is your pre-existing dataframe

# Define your output folder and current date
gam_output <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/6_GAMs/"

current_date <- format(Sys.Date(), "%Y%m%d")

output_folder <- paste0(gam_output, "GAM_outputs_", current_date, "/")



```

# --- Define Outcomes and Labels ---
```{r}

# This creates a 'named vector' called 'outcomes'.
# A named vector is a perfect tool for mapping the raw column names from your
# dataset to the clean, readable labels you want to display in plots or tables.

# Structure: "Column_Name" = "Plot Label"
# - The 'name' (left side) MUST EXACTLY match the column name in your data frame.
# - The 'value' (right side) is the user-friendly label that will be used.

outcomes <- c(
    #CSS (Conners' Scale) ADHD Symptoms
    "CSS_Inatt_Count" = "CSS Inattention Sx Count",
    "CSS_Hyp_Count" = "CSS Hyperactivity Sx Count",
    "CSS_Imp_Count" = "CSS Impulsivity Sx Count",
    "CSS_Inatt" = "CSS Inattention Sx Severity",
    "CSS_HypImp" = "CSS Hyperactivity/Impulsivity Sx Severity",

    # Cognitive Task Scores
    "score_pinball" = "Working Memory Score (Pinball)",
    "score_robot" = "Reponse Inhibition (Robot Factory)",

    # BDEFS (Barkley Deficits in Executive Functioning Scale) Symptoms
    "BDEFS_WM_avg" = "Working Memory Sx (BDEFS)",
    "BDEFS_RI_avg" = "Response Inhibition Sx (BDEFS)",

    # DRSP (Daily Record of Severity of Problems) Items
    "DRSP_1" = "Depressed Mood",
    "DRSP_2" = "Hopelessness",
    "DRSP_3" = "Worthlessness/Guilt",
    "DRSP_4" = "Anxiety",
    "DRSP_5" = "Mood Swings",
    "DRSP_6" = "Rejection Sensitivity",
    "DRSP_7" = "Irritability",
    "DRSP_8" = "Interpersonal Conflicts",
    "DRSP_9" = "Less Interest in Activities",
    "DRSP_10" = "Difficulty Concentrating",
    "DRSP_11" = "Lethargy/Fatigue",
    "DRSP_12" = "Increased Appetite/Overate",
    "DRSP_13" = "Food Cravings",
    "DRSP_14" = "Hypersomnia",
    "DRSP_15" = "Insomnia",
    "DRSP_16" = "Overwhelmed/Couldn't Cope",
    "DRSP_17" = "Felt Out of Control",
    "DRSP_18" = "Breast Tenderness",
    "DRSP_19" = "Swelling/Bloating",
    "DRSP_20" = "Headache",
    "DRSP_21" = "Joint/Muscle Pain",

    # Impairment Scores
    "DRSP_22" = "Work Impairment",
    "DRSP_23" = "Relationship Impairment",

    # Hormones
    "E2" = "Estradiol",
    "P4" = "Progesterone",
    "LH" = "Luteinizing Hormone"
)

```

# Default settings below - menses-centered
```{r}
# You can easily switch this back to "cyclic_time" if needed
time_var <- "cyclic_time_impute"


# Get the actual column names from the dataframe
actual_colnames <- names(cycle_df_scaled)

# Loop through your defined outcomes and check if they exist
for (outcome_to_check in names(outcomes)) {
  if (outcome_to_check %in% actual_colnames) {
    message(paste("✅ Found:", outcome_to_check))
  } else {
    message(paste("❌ NOT FOUND:", outcome_to_check))
  }
}

```



#Run loop!

```{r}

# --- 3. Loop Through Each Outcome ---
for (outcome_var in names(outcomes)) {

  outcome_label <- outcomes[outcome_var]
  log_outcome_var <- paste0(outcome_var, "_Log")

  message(paste("Processing outcome:", outcome_label, "with time variable:", time_var))

  # Log-transform the current outcome variable
  cycle_df_scaled[[log_outcome_var]] <- log(cycle_df_scaled[[outcome_var]] + 1)

  # Prepare data for the model using the specified time_var
  selected_vars <- c(time_var, log_outcome_var, "id")
  datSX <- cycle_df_scaled[complete.cases(cycle_df_scaled[selected_vars]), ]
  datSX$id <- as.factor(datSX$id)

  # Dynamically create the formula for the GAM model using time_var
  gamm_formula <- as.formula(paste(
    log_outcome_var,
    "~ s(", time_var, ", bs = 'cc') + s(id, bs = 're') + s(id,", time_var, ", bs = c('re','cc'))"
  ))
  
  # Create the knots list dynamically
  knots_list <- list(c(-1, 1))
  names(knots_list) <- time_var

  # Run the GAMM model
  gamm <- mgcv::gam(
    formula = gamm_formula,
    data = datSX,
    knots = knots_list,
    method = 'REML'
  )

  # Save the model summary to a dynamically named .txt file
  summary_filename <- paste0(output_folder, "gamm_", log_outcome_var, "_", time_var, "_summary_", current_date, ".txt")
  sink(summary_filename)
  print(summary(gamm))
  sink()

  # --- Plotting ---
  
  # Create a named list for expand.grid using the time_var string
  grid_list <- list(seq(-1, 1, by = 0.05), id = 0)
  names(grid_list)[1] <- time_var
  plotdat <- do.call(expand.grid, grid_list)

  # Get predictions and back-transform them
  pred <- marginaleffects::predictions(
    gamm,
    newdata = plotdat,
    type = "response",
    transform = function(x) exp(x) - 1
  )

  plotdat$estimate <- pred$estimate
  plotdat$conf.low <- pred$conf.low
  plotdat$conf.high <- pred$conf.high

  # Generate the plot with the dynamic y-axis label
  gamplot <- ggplot(plotdat, aes(x = .data[[time_var]], y = estimate)) +
    scale_x_continuous(
      limits = c(-1, 1),
      breaks = seq(-1, 1, by = 0.50),
      # IMPORTANT: You may need to change these labels to match the meaning of cyclic_time_ov
      labels = c("Menses", "50%F", "Ovulation", "50%L", "Menses")
    ) +
    labs(x = "", y = outcome_label) +
    geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf, fill = "grey70", alpha = 0.2, color = "white") +
    geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf, fill = "grey87", alpha = 0.2, color = "white") +
    geom_line(linewidth = 1) +
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightgrey", alpha = 0.3) +
    theme_minimal()

  print(gamplot)

  # Save the plot to a dynamically named .png file
  plot_filename <- paste0(output_folder, "gamplot_", log_outcome_var, "_", time_var, "_", current_date, ".png")
  ggsave(plot_filename, gamplot, width = 8, height = 6, dpi = 300)

}

#No such file or directoryError in file(file, if (append) "a" else "w") : cannot open the connection

  
```

# Description of this chunk: 
# --- 4. Loop Through Each Outcome for Each Person (with Improvements) ---
# This loop iterates through each outcome and then through each unique participant ID. The goal is to fit a GAM model for each outcome within each participant and save the results. It saves to individual folders for each participant within the main output folder. Other key features include data checks, error handling, and adaptive model complexity.
```{r}
# Load the necessary library for tryCatch if you plan to do more complex error handling
# library(base) # It's a base package, so no need to load

for (outcome_var in names(outcomes)) {

  outcome_label <- outcomes[outcome_var]
  log_outcome_var <- paste0(outcome_var, "_Log")

  message(paste("Processing outcome:", outcome_label, "with time variable:", time_var))
  cycle_df_scaled[[log_outcome_var]] <- log(cycle_df_scaled[[outcome_var]] + 1)

  selected_vars <- c(time_var, log_outcome_var, "id")
  datSX <- cycle_df_scaled[complete.cases(cycle_df_scaled[selected_vars]), ]
  datSX$id <- as.factor(datSX$id)

  unique_ids <- unique(datSX$id)

  for (current_id in unique_ids) {
    datSX_id <- subset(datSX, id == current_id)

    # --- IMPROVEMENT 1: STRONGER DATA CHECKS ---
    # Check for sufficient data points AND variance in the outcome
    if (nrow(datSX_id) < 10 || var(datSX_id[[log_outcome_var]]) < 1e-6) {
      message(paste("Skipping ID:", current_id, "for outcome:", outcome_label, "due to insufficient data or zero variance."))
      next
    }

    # --- IMPROVEMENT 2: USE tryCatch TO PREVENT CRASHES ---
    tryCatch({
      
      # --- IMPROVEMENT 3: MAKE 'k' ADAPTIVE ---
      # Set k to be less than the number of unique data points to avoid errors
      # This makes the model complexity dependent on the available data
      adaptive_k <- min(10, nrow(datSX_id) - 1)
      
      gamm_formula <- as.formula(paste(
        log_outcome_var,
        "~ s(", time_var, ", bs = 'cc', k = ", adaptive_k, ")"
      ))

      knots_list <- list(c(-1, 1))
      names(knots_list) <- time_var

      # The GAM call is now inside the tryCatch block
      gamm_id <- mgcv::gam(
        formula = gamm_formula,
        data = datSX_id,
        knots = knots_list,
        method = 'REML'
      )

      # --- All the saving and plotting code is also inside the tryCatch block ---
      id_output_folder <- file.path(output_folder, paste0("ID_", current_id))
      dir.create(id_output_folder, showWarnings = FALSE, recursive = TRUE)

      summary_filename <- file.path(id_output_folder, paste0("summary_", log_outcome_var, "_", time_var, "_", current_date, ".txt"))
      sink(summary_filename)
      print(summary(gamm_id))
      sink()

      grid_list <- list(seq(-1, 1, by = 0.05))
      names(grid_list)[1] <- time_var
      plotdat <- do.call(expand.grid, grid_list)

      pred <- marginaleffects::predictions(
        gamm_id,
        newdata = plotdat,
        type = "response",
        transform = function(x) exp(x) - 1
      )

      plotdat$estimate <- pred$estimate
      plotdat$conf.low <- pred$conf.low
      plotdat$conf.high <- pred$conf.high

      gamplot <- ggplot(plotdat, aes(x = .data[[time_var]], y = estimate)) +
        scale_x_continuous(
          limits = c(-1, 1),
          breaks = seq(-1, 1, by = 0.50),
          labels = c("Menses", "50%F", "Ovulation", "50%L", "Menses")
        ) +
        labs(x = "", y = outcome_label, title = paste("ID:", current_id)) +
        geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf, fill = "grey70", alpha = 0.2, color = "white") +
        geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf, fill = "grey87", alpha = 0.2, color = "white") +
        geom_line(linewidth = 1) +
        geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightgrey", alpha = 0.3) +
        theme_minimal()
      
      print(gamplot)
      
      plot_filename <- file.path(id_output_folder, paste0("plot_", log_outcome_var, "_", time_var, "_", current_date, ".png"))
      ggsave(plot_filename, gamplot, width = 8, height = 6, dpi = 300)

    }, error = function(e) {
      # This part runs ONLY if an error occurs in the code above
      message(paste("!!! FAILED to fit model for ID:", current_id, "and outcome:", outcome_label, "!!!"))
      message("Error message:", e$message)
    }) # End of tryCatch block
    
  } # End of id loop
} # End of outcome loop
```

Factor Interpretations:
1. Acute Sinus Reaction: High loadings on facial pain/pressure and sneezing, indicating acute inflammatory responses.
2. Mucosal Dryness: High loadings on nasal dryness and diminished smell, reflecting mucosal irritation and sensory changes.
3. Congestion & Drainage: High loadings on congestion and nasal drainage, representing obstructive and secretory symptoms.
Itch did not load strongly on any factor and is treated as a standalone symptom.

```{r}
# --- SETUP (should be at the top of your script) ---
# Ensure these objects are defined before running the loop
current_date <- format(Sys.Date(), "%Y%m%d")
# The 'outcomes', 'time_var', and 'cycle_df_scaled' objects should also be defined

# --- START OF REVISED LOOP ---
unique_ids <- unique(cycle_df_scaled$id)

# 1. OUTER LOOP: Iterate through each person
for (current_id in unique_ids) {
  
  message(paste("--- Processing all outcomes for ID:", current_id, "---"))
  
  # 2. Create an empty list to store all prediction dataframes for this person
  all_predictions_for_id <- list()
  
  # Get all data for the current person once
  datSX_id <- subset(cycle_df_scaled, id == current_id)
  
  # 3. INNER LOOP: Iterate through each outcome for the current person
  for (outcome_var in names(outcomes)) {
    outcome_label <- outcomes[outcome_var]
    log_outcome_var <- paste0(outcome_var, "_Log")
    
    # Log-transform and select complete cases for this specific outcome
    datSX_id[[log_outcome_var]] <- log(datSX_id[[outcome_var]] + 1)
    
    # Check for sufficient data
    if (nrow(datSX_id) < 10 || var(datSX_id[[log_outcome_var]], na.rm = TRUE) < 1e-6) {
      next # Skip to the next outcome if data is insufficient
    }
    
    tryCatch({
      # --- Model fitting (this part is the same as before) ---
      adaptive_k <- min(10, nrow(datSX_id) - 1)
      gamm_formula <- as.formula(paste(log_outcome_var, "~ s(", time_var, ", bs = 'cc', k = ", adaptive_k, ")"))
      knots_list <- list(c(-1, 1)); names(knots_list) <- time_var
      
      gamm_id <- mgcv::gam(
        formula = gamm_formula,
        data = datSX_id,
        knots = knots_list,
        method = 'REML'
      )
      
      # --- Prediction (this part is also the same) ---
      plotdat <- expand.grid(time_points = seq(-1, 1, by = 0.05))
      names(plotdat)[1] <- time_var
      
      pred <- marginaleffects::predictions(
        gamm_id,
        newdata = plotdat,
        type = "response",
        transform = function(x) exp(x) - 1
      )
      
      # 4. Add a column to the prediction data to identify the outcome
      # This is ESSENTIAL for faceting
      pred$outcome_label <- outcome_label
      
      # 5. Store the prediction dataframe in our list
      all_predictions_for_id[[outcome_var]] <- pred
      
    }, error = function(e) {
      message(paste("!!! FAILED model for ID:", current_id, "and outcome:", outcome_label, "!!!"))
    })
  } # End of inner loop (outcomes)
  
  # 6. After modeling all outcomes, combine the prediction data and create the faceted plot
  if (length(all_predictions_for_id) > 0) {
    
    # Combine the list of dataframes into a single, long dataframe
    combined_plot_data <- dplyr::bind_rows(all_predictions_for_id)
    
  # Create the final plot using facet_wrap
faceted_plot <- ggplot(combined_plot_data, aes(x = .data[[time_var]], y = estimate)) +
  geom_line(linewidth = 1, color = "#0072B2") +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#0072B2", alpha = 0.2) +
  
  # --- ADD THESE TWO LINES ---
  # Add a red vertical line at x = -1 for Menses ("M")
  geom_vline(xintercept = -1.0, linetype = "dashed", color = "red", linewidth = 1) +
  # Add a green vertical line at x = 0 for Ovulation ("Ov")
  geom_vline(xintercept = 0.0, linetype = "dashed", color = "green", linewidth = 1) +
  
  # This is the key function to create the grid of plots
  facet_wrap(~ outcome_label, scales = "free_y") + 
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.50),
    labels = c("M", "50F", "Ov", "50L", "M")
  ) +
  labs(
    x = "Cycle Phase", 
    y = "Symptom Score", 
    title = paste("Symptom Trajectories for ID:", current_id)
  ) +
  theme_minimal() +
  theme(strip.text = element_text(face = "bold")) # Make panel titles bold

# Print the plot to the screen
print(faceted_plot)
    
    # Save the combined, faceted plot as a single PNG file
    id_output_folder <- file.path(output_folder, "Faceted_Plots_by_ID")
    dir.create(id_output_folder, showWarnings = FALSE, recursive = TRUE)
    plot_filename <- file.path(id_output_folder, paste0("plot_all_symptoms_ID_", current_id, "_", current_date, ".png"))
    ggsave(plot_filename, faceted_plot, width = 12, height = 8, dpi = 300)
    
  } # End of if-statement for plotting
  
} # End of outer loop (IDs)
```


```{r}
# --- SETUP ---
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(mgcv)
library(marginaleffects)

# Load the final, scaled dataset with subscales
cycle_df_scaled <- read_csv("lee_daily_scaled_with_subscales.csv")

# Define the list of outcomes you want to plot for each person
# This can be all symptoms or just a subset
outcomes_to_plot <- c(
  sxprob = "Symptom Probability",
  congestion = "Congestion",
  drainage = "Nasal Drainage",
  dryness = "Nasal Dryness",
  sneeze = "Sneezing",
  acute_reaction = "Subscale: Acute Sinus Reaction",
  mucosal_dryness = "Subscale: Mucosal Dryness",
  congestion_drainage = "Subscale: Congestion & Drainage",
  itch = "Nasal Itchiness"
)

# Define your time variable and output folder
time_var <- "cyclic_time_imp_ov" 
!
dir.create(output_folder, showWarnings = FALSE)

# --- Select the Most Representative Participants ---
target_ids <- c(
  "103", # Example of a Clear Cyclical Phenotype
  "209", # Example of a Symptom-Specific Phenotype
  "104"  # Example of a Non-Cyclical Phenotype
)

# --- LOOP TO GENERATE AND SAVE KEY FIGURES ---
for (current_id in target_ids) {
  
  message(paste("--- Generating figure for representative ID:", current_id, "---"))
  
  all_predictions_for_id <- list()
  datSX_id <- subset(cycle_df_scaled, id == current_id)
  
  for (outcome_var in names(outcomes_to_plot)) {
    if (!outcome_var %in% names(datSX_id)) next # Skip if outcome column doesn't exist
    
    log_outcome_var <- paste0(outcome_var, "_Log")
    datSX_id[[log_outcome_var]] <- log(datSX_id[[outcome_var]] + 1)
    
    if (nrow(datSX_id) < 10 || var(datSX_id[[log_outcome_var]], na.rm = TRUE) < 1e-6) next
    
    tryCatch({
      adaptive_k <- min(10, nrow(datSX_id) - 1)
      gamm_formula <- as.formula(paste(log_outcome_var, "~ s(", time_var, ", bs = 'cc', k = ", adaptive_k, ")"))
      knots_list <- list(c(-1, 1)); names(knots_list) <- time_var
      
      gamm_id <- mgcv::gam(formula = gamm_formula, data = datSX_id, knots = knots_list, method = 'REML')
      
      plotdat <- expand.grid(time_points = seq(-1, 1, by = 0.05)); names(plotdat)[1] <- time_var
      
      pred <- marginaleffects::predictions(gamm_id, newdata = plotdat, type = "response", transform = function(x) exp(x) - 1)
      pred$outcome_label <- outcomes_to_plot[outcome_var]
      all_predictions_for_id[[outcome_var]] <- pred
      
    }, error = function(e) { message(paste("Model failed for", outcome_var)) })
  }
  
  if (length(all_predictions_for_id) > 0) {
    combined_plot_data <- dplyr::bind_rows(all_predictions_for_id)
    
    phenotype_label <- case_when(
      current_id == "103" ~ "Clear_Cyclical",
      current_id == "209" ~ "Symptom_Specific",
      current_id == "104" ~ "Non_Cyclical",
      TRUE ~ "Other"
    )
    
    faceted_plot <- ggplot(combined_plot_data, aes(x = .data[[time_var]], y = estimate)) +
      geom_line(linewidth = 1, color = "#0072B2") +
      geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#0072B2", alpha = 0.2) +
      geom_vline(xintercept = -1.0, linetype = "dashed", color = "red", linewidth = 1) +
      geom_vline(xintercept = 0.0, linetype = "dashed", color = "green", linewidth = 1) +
      facet_wrap(~ outcome_label, scales = "free_y") + 
      scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("M", "50F", "Ov", "50L", "M")) +
      labs(x = "Cycle Phase", y = "Symptom Score", title = paste("Symptom Trajectories for ID:", current_id, "(", phenotype_label, "Phenotype)")) +
      theme_minimal() +
      theme(strip.text = element_text(face = "bold"))

    print(faceted_plot)
    
    plot_filename <- file.path(output_folder, paste0("Figure_ID_", current_id, "_", phenotype_label, "_Example.png"))
    ggsave(plot_filename, faceted_plot, width = 12, height = 8, dpi = 300)
    message("Saved figure: ", plot_filename)
  }
}
```




```{r}
# --- 1. SETUP ---
# Load all necessary libraries
library(dplyr)
library(ggplot2)
library(mgcv)
library(marginaleffects)
library(patchwork) 

# Load the final, scaled dataset with subscales
cycle_df_scaled <- read_csv("lee_daily_scaled_with_subscales.csv")

# --- DEFINE A FOCUSED LIST OF OUTCOMES ---
# By reducing the number of variables here, the final figure will be much cleaner.
outcomes_to_plot <- c(
  sxprob = "Overall Symptom Probability",
  acute_reaction = "Subscale: Acute Sinus Reaction",
  mucosal_dryness = "Subscale: Mucosal Dryness",
  congestion_drainage = "Subscale: Congestion & Drainage",
  itch = "Standalone: Nasal Itchiness"
)

# Define your time variable and output folder
time_var <- "cyclic_time_imp_ov" 
dir.create(output_folder, showWarnings = FALSE)

# --- 2. GENERATE PLOT FOR EACH REPRESENTATIVE PARTICIPANT ---
plot_list <- list()

# Define the specific participants for Figure 1 (A, B, C)
target_ids <- c("103", "209", "104")

for (current_id in target_ids) {
  
  message(paste("--- Generating figure for representative ID:", current_id, "---"))
  
  all_predictions_for_id <- list()
  datSX_id <- subset(cycle_df_scaled, id == current_id)
  
  for (outcome_var in names(outcomes_to_plot)) {
    if (!outcome_var %in% names(datSX_id)) next
    
    log_outcome_var <- paste0(outcome_var, "_Log")
    datSX_id[[log_outcome_var]] <- log(datSX_id[[outcome_var]] + 1)
    
    if (nrow(datSX_id) < 10 || var(datSX_id[[log_outcome_var]], na.rm = TRUE) < 1e-6) next
    
    tryCatch({
      adaptive_k <- min(10, nrow(datSX_id) - 1)
      gamm_formula <- as.formula(paste(log_outcome_var, "~ s(", time_var, ", bs = 'cc', k = ", adaptive_k, ")"))
      knots_list <- list(c(-1, 1)); names(knots_list) <- time_var
      
      gamm_id <- mgcv::gam(formula = gamm_formula, data = datSX_id, knots = knots_list, method = 'REML')
      
      plotdat <- expand.grid(time_points = seq(-1, 1, by = 0.05)); names(plotdat)[1] <- time_var
      
      pred <- marginaleffects::predictions(gamm_id, newdata = plotdat, type = "response", transform = function(x) exp(x) - 1)
      pred$outcome_label <- outcomes_to_plot[outcome_var]
      all_predictions_for_id[[outcome_var]] <- pred
      
    }, error = function(e) {})
  }
  
  if (length(all_predictions_for_id) > 0) {
    combined_plot_data <- dplyr::bind_rows(all_predictions_for_id)
    
    phenotype_label <- case_when(
      current_id == "103" ~ "Clear Cyclical",
      current_id == "209" ~ "Symptom-Specific",
      current_id == "104" ~ "Non-Cyclical",
      TRUE ~ "Other"
    )
    
    p <- ggplot(combined_plot_data, aes(x = .data[[time_var]], y = estimate)) +
      geom_line(linewidth = 1, color = "#0072B2") +
      geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#0072B2", alpha = 0.2) +
      geom_vline(xintercept = -1.0, linetype = "dashed", color = "red") +
      geom_vline(xintercept = 0.0, linetype = "dashed", color = "green") +
      facet_wrap(~ outcome_label, scales = "free_y", ncol = 3) + # You can adjust ncol
      scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("M", "50F", "Ov", "50L", "M")) +
      labs(x = "Cycle Phase", y = "Symptom Score", title = paste("Participant", current_id, paste0("(", phenotype_label, " Phenotype)"))) +
      theme_minimal() +
      theme(strip.text = element_text(face = "bold"), plot.title = element_text(face = "bold"))
      
    plot_list[[current_id]] <- p
  }
}

# --- 3. COMBINE PLOTS INTO A SINGLE FIGURE WITH PATCHWORK ---
if (length(plot_list) == 3) {
  final_figure <- plot_list[["103"]] / plot_list[["209"]] / plot_list[["104"]]
  
  final_figure_with_labels <- final_figure + 
    plot_annotation(
      title = 'Figure 1. Representative Examples of Sino-Nasal Symptom Cyclicity Phenotypes',
      tag_levels = 'A'
    ) & 
    theme(plot.tag = element_text(size = 18, face = "bold"))

  print(final_figure_with_labels)
  
  ggsave(
    file.path(output_folder, "Figure_1_Combined_Phenotypes_Focused.png"),
    final_figure_with_labels,
    width = 10, 
    height = 12, 
    dpi = 300
  )
  message("Saved focused final figure to: ", output_folder)
}
```

```{r}
# --- 1. SETUP ---
# Load all necessary libraries
library(dplyr)
library(ggplot2)
library(mgcv)
library(marginaleffects)
library(patchwork) 

# Load the final, scaled dataset with subscales
cycle_df_scaled <- read_csv("lee_daily_scaled_with_subscales.csv")

# Define your time variable and output folder
time_var <- "cyclic_time_imp_ov" 
dir.create(output_folder, showWarnings = FALSE)

# --- 2. GENERATE EACH PLOT INDIVIDUALLY ---

# --- Plot A: Participant 106 (Clear Cyclical) ---
message("Generating Plot A: Participant 106")
dat_106 <- subset(cycle_df_scaled, id == "106")
dat_106$sxprob_Log <- log(dat_106$sxprob + 1)
model_106 <- mgcv::gam(sxprob_Log ~ s(cyclic_time_imp_ov, bs = 'cc'), data = dat_106, knots = list(cyclic_time_imp_ov = c(-1, 1)))
pred_106 <- marginaleffects::predictions(model_106, type = "response", transform = function(x) exp(x) - 1)
plot_A <- ggplot(pred_106, aes(x = cyclic_time_imp_ov, y = estimate)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#0072B2", alpha = 0.2) +
  geom_line(linewidth = 1.2, color = "#0072B2") +
  labs(title = "Overall Symptom Probability", y = "Symptom Score")

# --- Plot B: Participant 209 (Symptom-Specific) ---
message("Generating Plot B: Participant 209")
dat_209 <- subset(cycle_df_scaled, id == "209")
# Use the correct binomial model for the binary 'itch' outcome
model_209 <- mgcv::gam(itch ~ s(cyclic_time_imp_ov, bs = 'cc'), data = dat_209, family = "binomial", knots = list(cyclic_time_imp_ov = c(-1, 1)))
pred_209 <- marginaleffects::predictions(model_209, type = "response")
plot_B <- ggplot(pred_209, aes(x = cyclic_time_imp_ov, y = estimate)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#0072B2", alpha = 0.2) +
  geom_line(linewidth = 1.2, color = "#0072B2") +
  scale_y_continuous(labels = scales::percent_format(accuracy=1)) + # Format y-axis as probability
  labs(title = "Standalone: Nasal Itchiness", y = "Probability of Itch")

# --- Plot C: Participant 104 (Non-Cyclical) ---
message("Generating Plot C: Participant 104")
dat_104 <- subset(cycle_df_scaled, id == "104")
dat_104$sxprob_Log <- log(dat_104$sxprob + 1)
model_104 <- mgcv::gam(sxprob_Log ~ s(cyclic_time_imp_ov, bs = 'cc'), data = dat_104, knots = list(cyclic_time_imp_ov = c(-1, 1)))
pred_104 <- marginaleffects::predictions(model_104, type = "response", transform = function(x) exp(x) - 1)
plot_C <- ggplot(pred_104, aes(x = cyclic_time_imp_ov, y = estimate)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#0072B2", alpha = 0.2) +
  geom_line(linewidth = 1.2, color = "#0072B2") +
  labs(title = "Overall Symptom Probability", y = "Symptom Score")

# --- 3. COMBINE THE THREE PLOTS INTO A SINGLE FIGURE ---
final_figure <- (plot_A | plot_B | plot_C) # Arrange plots side-by-side

final_figure_with_labels <- final_figure + 
  plot_annotation(
    title = 'Figure 1. Representative Examples of Sino-Nasal Symptom Cyclicity Phenotypes',
    tag_levels = 'A'
  ) & 
  # Apply theme elements to all plots at once
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.tag = element_text(size = 20, face = "bold"),
    axis.title.x = element_text(size=12, face="bold", margin=margin(t=10)),
    axis.title.y = element_text(size=12, face="bold", margin=margin(r=10))
  ) &
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("M", "50F", "Ov", "50L", "M"), name="Cycle Phase") &
  geom_vline(xintercept = -1.0, linetype = "dashed", color = "red") &
  geom_vline(xintercept = 0.0, linetype = "dashed", color = "green")

print(final_figure_with_labels)

ggsave(
  file.path(output_folder, "Figure_1_Final_Phenotypes_Corrected.png"),
  final_figure_with_labels,
  width = 15, height = 5, dpi = 300
)
message("Saved final, corrected figure to: ", output_folder)
```


#run a factored smooth version of the gamm and plot them all on one plot for each symptom

```{r}
for (outcome_var in names(outcomes_subscales)) {

  outcome_label <- outcomes[outcome_var]
  log_outcome_var <- paste0(outcome_var, "_Log")

  message(paste("Processing outcome:", outcome_label, "with time variable:", time_var))
  cycle_df_scaled[[log_outcome_var]] <- log(cycle_df_scaled[[outcome_var]] + 1)

  selected_vars <- c(time_var, log_outcome_var, "id")
  datSX <- cycle_df_scaled[complete.cases(cycle_df_scaled[selected_vars]), ]
  datSX$id <- as.factor(datSX$id)

  unique_ids <- unique(datSX$id)

    # --- IMPROVEMENT 1: STRONGER DATA CHECKS ---
    # Check for sufficient data points AND variance in the outcome
    if (nrow(datSX) < 10 || var(datSX[[log_outcome_var]]) < 1e-6) {
      message(paste("Skipping outcome:", outcome_label, "due to insufficient data or zero variance."))
      next
    }

    # --- IMPROVEMENT 2: USE tryCatch TO PREVENT CRASHES ---
    tryCatch({
      
      # --- IMPROVEMENT 3: MAKE 'k' ADAPTIVE ---
      # Set k to be less than the number of unique data points to avoid errors
      # This makes the model complexity dependent on the available data
      adaptive_k <- min(10, nrow(datSX) - 1)
      
      gamm_formula <- as.formula(paste(
        log_outcome_var,
        "~ s(", time_var, ", by = id, bs = 'cc', k = ", adaptive_k, ") + s(id, bs = 're')"
      ))

      knots_list <- list(c(-1, 1))
      names(knots_list) <- time_var

      # The GAM call is now inside the tryCatch block
      gamm_id <- mgcv::gam(
        formula = gamm_formula,
        data = datSX,
        knots = knots_list,
        method = 'REML'
      )

      # --- All the saving and plotting code is also inside the tryCatch block ---
      id_output_folder <- file.path(gam_output_folder, paste0("All_IDs"))
      dir.create(id_output_folder, showWarnings = FALSE, recursive = TRUE)

      summary_filename <- file.path(id_output_folder, paste0("summary
_", log_outcome_var, "_", time_var, "_", current_date, ".txt"))
      sink(summary_filename)
      print(summary(gamm_id))
      sink()

      grid_list <- list(seq(-1, 1, by = 0.05))
      names(grid_list)[1] <- time_var
      plotdat <- do.call(expand.grid, grid_list)

      pred <- marginaleffects::predictions(
        gamm_id,
        newdata = plotdat,
        type = "response",
        transform = function(x) exp(x) - 1
      )

      plotdat$estimate <- pred$estimate
      plotdat$conf.low <- pred$conf.low
      plotdat$conf.high <- pred$conf.high

      gamplot <- ggplot(plotdat, aes(x = .data[[time_var]], y = estimate, group = id, color = id)) +
        scale_x_continuous(
          limits = c(-1, 1),
          breaks = seq(-1, 1, by = 0.50),
          labels = c("Ovulation", "50%L", "Menses Onset", "50%F", "Ovulation")
        ) +
        labs(x = "", y = outcome_label, title = paste("All IDs:", outcome_label)) +
        geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf, fill = "grey70", alpha = 0.2, color = "white") +
        geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf, fill = "grey87", alpha = 0.2, color = "white") +
        geom_line(linewidth = 1) +
        theme_minimal() +
        theme(legend.position = "none") # Hide legend for clarity
      
      print(gamplot)
      
      plot_filename <- file.path(id_output_folder, paste0("plot_", log_outcome_var, "_", time_var, "_", current_date, ".png"))
      ggsave(plot_filename, gamplot, width = 8, height = 6, dpi = 300)

    }, error = function(e) {
      # This part runs ONLY if an error occurs in the code above
      message(paste("!!! FAILED to fit model for outcome:", outcome_label, "!!!"))
      message("Error message:", e$message)
    }) # End of tryCatch block
    
} # End of outcome loop

```

