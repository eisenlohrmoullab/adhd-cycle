---
title: "ADHDCYCLE_daily"
output: 
  html_document: 
    toc: true
    fig_caption: true
    number_sections: true
    df_print: default
date: "Last compiled on `r format(Sys.time(), '%B %d, %Y')`"
---

# ---------------------------------------------------------------------------------- CACHED CHUNKS

# ---- Store Functions ----
Instructions: Please keep these chunks minimized when not in use. 

## standardize_index_names(): Function to standardize index variable names
- Inputs: Dataframe with misformatted "ID" or "date_rated" variables
- Outputs: @id and @daterated
#TODO: add hormones and other variables here, need to make it more flexible to pick up on other options
```{r standardize_index_names, cache=TRUE}
standardize_index_names <- function(df) {
    df %>%
        rename_with(~ gsub("([Dd]ate.?rated|daterated)", "daterated", .), # Standardize daterated column names
                    matches("date|daterated")) %>% # Match date or daterated in the column name
        rename_with(~ gsub("([Ii][Dd])", "id", .), matches("ID|id")) # Standardize id column names
}

```

## count_rows_ids Function to count rows and unique ids
- Inputs: Any Dataframe with @id variable
- Outputs: Number of rows in the dataset, number of unique id values, and a list of unique id values
```{r count_rows_ids, cache=TRUE}

count_rows_ids <- function(df) {
  cat("Number of rows: ", nrow(df), "\n")
  cat("Number of unique ids: ", n_distinct(df$id), "\n")
  
  # Get a list of unique IDs in the dataset
  id_list <- unique(df$id)

  # Print the number of unique IDs and the list of unique IDs in a sentence
  cat("The id values are:", "\n", "\n", paste(id_list, collapse = ", "), "\n", "\n")
}

```

## print.variable.names() Function to print variable names
- Inputs: Any Dataframe
- Outputs: Names of all variables in the dataset
```{r print.variable.names, cache=TRUE}
print.variable.names <- function(df) {
  variable_names <- names(df)
  formatted_list <- paste(variable_names, collapse = ", ")
cat("-------- Names of variables in the raw dataset --------   ", formatted_list)
}

```

## create.person.metrics() Function to calculate person-level metrics for a given variable
- Inputs: @df dataset, @alldailyvars list, @id id variable
- Outputs: Dataframe with person-level metrics for the specified variable including: 
-     .d, .zd, .3roll, .5roll, .d.3roll, .d.5roll, .zd.3roll, and .zd.5roll
```{r create.person.metrics, cache=TRUE}

# Create a function to calculate person-level metrics for a given variable
create.person.metrics <- function(df, var, id) {
  # Capture the variable name
  var <- enquo(var)

  # Create person means for the specified variable, grouped by the id
  df <- df %>%
    group_by({{ id }}) %>%
    mutate(!!paste0(quo_name(var), ".m") := mean(!!var, na.rm = TRUE)) %>%
    ungroup()

  # Create person standard deviations for the specified variable, grouped by the id
  df <- df %>%
    group_by({{ id }}) %>%
    mutate(!!paste0(quo_name(var), ".sd") := sd(!!var, na.rm = TRUE)) %>%
    ungroup()

  # Create person deviations from the mean for the specified variable
  df <- df %>%
    mutate(!!paste0(quo_name(var), ".d") := (!!var) - .data[[paste0(quo_name(var), ".m")]])

  # Create person standardized values (z-scores) for the specified variable
  df <- df %>%
    mutate(!!paste0(quo_name(var), ".zd") := (.data[[quo_name(var)]] - .data[[paste0(quo_name(var), ".m")]]) / .data[[paste0(quo_name(var), ".sd")]])

  # Return the modified dataframe with the new metrics
  return(df)
}

```

## create.rolling.avgs(): Function to create 3- and 5-day rolling averages on raw, .d, and .zd variables in alldailyvars list
- Inputs: @df dataset, @alldailyvars list
- Outputs: Dataframe with 3- and 5-day rolling averages for the specified variable
```{r}
create.rolling.avgs <- function(df, var) {
  df %>%
    group_by(id) %>%
    mutate("{{var}}.3roll" := rollapply({{var}}, 3, function(x) mean(x, na.rm = TRUE), align="center", fill=NA, partial=TRUE), 
           "{{var}}.5roll" := rollapply({{var}}, 5, function(x) mean(x, na.rm = TRUE), align="center", fill=NA, partial=TRUE))
}
```


# ---- Store Global Lists of final variable names and labels ----
- Create Lists of Variables for Analysis
-   @dv_list: List of dependent variables for analysis
-   @hormlist: List of hormone variables for analysis
-   @alldailyvars: dv_list and hormlist combined

```{r make lists, cache=TRUE}

dv_list <- c(
  "CSS_Inatt",
  "CSS_HypImp",
  "score_pinball",
  "score_robot",
  "BDEFS_Total",
  "BDEFS_WM_avg",
  "BDEFS_RI_avg",
  "UPPS_NU_avg",
  "UPPS_PU_avg",
  "UPPS_Premed_avg",
  "UPPS_Persev_avg",
  "UPPS_Sens_avg",
  "DEBQ_Total",
  "CSS_Inatt_Count",
  "CSS_Hyp_Count",
  "CSS_Imp_Count",
  "CSS_HypImp_Count",
  "DRSP_1",
  "DRSP_2",
  "DRSP_3",
  "DRSP_4",
  "DRSP_5",
  "DRSP_6",
  "DRSP_7",
  "DRSP_8",
  "DRSP_9",
  "DRSP_10",
  "DRSP_11",
  "DRSP_12",
  "DRSP_13",
  "DRSP_14",
  "DRSP_15",
  "DRSP_16",
  "DRSP_17",
  "DRSP_18",
  "DRSP_19",
  "DRSP_20",
  "DRSP_21",
  "DRSP_22",
  "DRSP_23"
) %>% noquote()


# Rename the variables based on DRSP items
# This creates a named vector to assign meaningful labels to each variable for better interpretation in the plots
names(dv_list) <- c(
  "Inattention Sx", 
  "Hyperactivity/Imp Sx", 
  "Pinball Score",
  "Robot Score",
  "BDEFS Total",
  "BDEFS Working Memory",
  "BDEFS Resp Inhibition",
  "Negative Urgency",
  "Positive Urgency",
  "Lack of Premeditation",
  "Lack of Perseverance",
  "Sensation Seeking",
  "DEBQ Total",
  "Inattention Sx Count",
  "Hyperactivity Sx Count",
  "Impulsivity Sx Count",
  "Hyp/Imp Sx Count",
  "Depressed Mood", # DRSP_1
  "Hopelessness", # DRSP_2
  "Worthlessness/Guilt", # DRSP_3
  "Anxiety/Tension", # DRSP_4
  "Mood Swings", # DRSP_5
  "Rejection Sensitivity", # DRSP_6
  "Anger/Irritability", # DRSP_7
  "Interpersonal Conflict", # DRSP_8
  "Less Interest", # DRSP_9
  "Difficulty Concentrating", # DRSP_10
  "Lethargy/Fatigue", # DRSP_11
  "Incr Appetite/Overate", # DRSP_12
  "Food Cravings", # DRSP_13
  "Hypersomnia", # DRSP_14
  "Insomnia", # DRSP_15
  "Overwhelm/Can't Cope", # DRSP_16
  "Out of Control", # DRSP_17
  "Breast Tenderness", # DRSP_18
  "Swelling/Bloat/Wt Gain", # DRSP_19
  "Joint/Muscle Pain", # DRSP_20
  "Headache", # DRSP_21
  "Work/School Imp", 
  "Relational Imp"
)

# Rename the variables based on DRSP items
names(dv_list) <- c(
  "Depressed Mood", # DRSP_1
  "hopelessness", # DRSP_2
  "Worthlessness/Guilt", # DRSP_3
  "Anxiety/Tension", # DRSP_4
  "Mood Swings", # DRSP_5
  "Rejection Sensitivity", # DRSP_6
  "Anger/Irritability", # DRSP_7
  "Interpersonal Conflict", # DRSP_8
  "Less Interest", # DRSP_9
  "Difficulty Concentrating", # DRSP_10
  "Lethargy/Fatigue", # DRSP_11
  "Increased Appetite/Overate", # DRSP_12
  "Food Cravings", # DRSP_13
  "Hypersomnia", # DRSP_14
  "Insomnia", # DRSP_15
  "Overwhelm/Can't Cope", # DRSP_16
  "Out of Control", # DRSP_17
  "Breast Tenderness", # DRSP_18
  "Swelling/Bloating/Weight Gain", # DRSP_19
  "Joint/Muscle Pain", # DRSP_20
  "Headache", # DRSP_21
  "Work/School Impairment", 
  "Relational Impairment",
  "Inattention Symptoms", 
  "Hyperactivity/Impulsivity Symptoms", 
  "Pinball Score",
  "Robot Score",
  "BDEFS Total",
  "BDEFS Working Memory",
  "BDEFS Response Inhibition",
  "Negative Urgency",
  "Positive Urgency",
  "Lack of Premeditation",
  "Lack of Perseverance",
  "Sensation Seeking",
  "DEBQ Total",
  "Inattention Sx Count",
  "Hyperactivity Sx Count",
  "Impulsivity Sx Count",
  "Hyperactivity/Impulsivity Sx Count"
)

hormlist <- c(
  "E2",
  "P4",
  "LH"
) %>% noquote()

#Create another list that combines both dv_list and hormlist above
alldailyvars <- c(dv_list, hormlist) %>% noquote()
```


# ---------------------------------------------------------------------------------- SETUP

# ---- Load Packages (no cache) ----
```{r packages, warning=FALSE}

# ---- Global Chunk Options and Settings ----

# Setting options for knitr to display R code in output
knitr::opts_chunk$set(echo = TRUE)

# Prevent scientific notation in outputs
options(scipen = 999)

# ---- Data Manipulation and Cleaning ----

# Core tidyverse libraries for data manipulation and visualization
library(dplyr)       # Data manipulation (part of tidyverse)
library(tidyr)       # Data tidying (part of tidyverse)
library(tidyverse)   # Meta-package, includes dplyr, tidyr, ggplot2, and others
library(janitor)     # For cleaning data, e.g., renaming columns, removing empty rows
library(skimr)       # Summarize and inspect data quickly


# ---- Reading and Working with Files ----

# Libraries for reading various file formats
library(haven)       # For reading SPSS, Stata, and SAS files
library(readxl)      # For reading Excel files
library(readr)       # For reading CSV and other text files


# ---- Plotting and Visualization ----

# Core and extended libraries for data visualization
library(ggplot2)     # Core plotting library
library(ggdist)      # Visualizing distributions and uncertainty
library(ggforce)     # Extending ggplot2 functionality with advanced features
library(ggrepel)     # For adding non-overlapping text labels to ggplot2
library(visdat)      # Visualizing missing data and data structure
library(sjPlot)      # Plotting for statistical models (e.g., mixed models)
library(corrplot)    # For creating correlation matrix visualizations
library(grid)        # Base R graphics system for visual layout
library(gridExtra)   # Arranging multiple plots in a grid
library(see)         # Visualizing model checks and diagnostics
library(DescTools)  # Descriptive statistics and plotting tools

# ---- Time Series and Rolling Averages ----

# Libraries for time series data and handling dates
library(zoo)         # Working with rolling means/averages and time series
library(lubridate)   # Date and time manipulation


# ---- Mixed-Effects Models and Analysis ----

# Libraries for mixed-effects models and related analysis
library(lme4)        # Fitting mixed-effects models (linear and generalized)
library(lmerTest)    # Adds p-values for lme4 models
library(nlme)        # Linear and nonlinear mixed-effects models
library(emmeans)     # Compute estimated marginal means (EMMs) for model outputs
library(broom.mixed) # Tidying mixed model results into tidy data frames
library(performance) # Model performance metrics (e.g., R-squared for mixed models)
library(pbkrtest)    # Parametric bootstrap and Kenward-Roger methods for mixed models

# Generalized additive models and marginal effects
library(mgcv)        # Fitting generalized additive models (GAMs)
library(marginaleffects) # Tools for calculating marginal effects from regression models


# ---- Statistical Tools ----

# Libraries for specific statistical methods
#library(psych)       # Descriptive statistics and psychometrics
#library(GPArotation) # Factor analysis rotations (e.g., Varimax)
library(rmcorr)      # Repeated measures correlations
#library(MASS)        # Functions for statistical methods, e.g., Mahalanobis distance
library(careless)    # Detecting careless responses in surveys
library(responsePatterns) # Analyzing response patterns in data


# ---- GitHub, Project Management, and Reproducibility ----

# Libraries for project and version control management
library(usethis)     # Simplifies setting up GitHub repositories and managing projects
library(gitcreds)    # Managing Git credentials for GitHub interactions
#library(renv)        # Manages dependencies for reproducible environments
#library(targets)     # Workflow management for reproducible research pipelines
```

# ---- Check for Package Conflicts and Declare Preferences (no cache) ----
```{r package conflicts, warning=FALSE}
library(conflicted) # Managing conflicts between package namespaces

conflict_scout() # Check for conflicts between package namespaces

conflicts_prefer(dplyr::filter)
conflicts_prefer(tidyr::complete)
conflicts_prefer(dplyr::lag)
```

# ---- Setup ----
- Turns of Scientific Notation
- Saves 'current_date' as a string in YYYYMMDD format
- Sets the number of digits (3) to display in output
- Sets the 'output_folder' as path to the output folder for saving files
```{r setup}

knitr::opts_chunk$set(echo = TRUE) # Setting options for knitr to display R code in output
options(scipen = 999) # Turn off scientific notation
options(digits = 3) # Set number of digits to display
current_date <- format(Sys.Date(), "%Y%m%d")  # Produces date as YYYYMMDD
output_folder <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/"

```


# ---------------------------------------------------------------------------------- DATA PREPARATION AND CLEANING

# ---- Load Raw Data (save it as both rawdf and df) ----
```{r load data, message=FALSE, warning=FALSE}

# Load your CSV file (adjust the path to your actual file location)

rawdf <- read_csv("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/02_datasets/CYCADHD_DAILY/01_raw_data/2024.04.24. Daily Master.csv") # Change the path to your file

df<-rawdf
```

# ---- Standardize Variable Names ----
- This includes standardizing the names of the index variables (id and daterated)
- Also includes renaming to E2, P4, CSS_Inatt_Count, CSS_Hyp_Count, and CSS_Imp_Count
```{r renaming variables}
standardize_index_names(df)
df <- df %>%
  rename(
    E2 = Estradiol,
    P4 = Progesterone, 
    CSS_Inatt_Count = IA_Count, 
    CSS_Hyp_Count = Hyp_Count, 
    CSS_Imp_Count = Imp_Count)
```

# ---- Sort df by id and daterated ----
```{r sort df}
df <- df %>%
  arrange(id, daterated)
```

# ---- Add Placeholder for Missing Dates ----

```{r add-placeholder-days}

# Display the number of rows BEFORE adding placeholders
cat("Before adding placeholder dates, this is the number of rows: ", nrow(df), "\n")

df <- df %>%
  group_by(id) %>%
  complete(daterated = seq.Date(min(daterated), max(daterated), by = "day")) %>%
  ungroup()

# Display the number of rows after adding placeholders
cat("Placeholder dates added (i.e., added blank lines for days when there were no surveys but the participant was in the study). AFTER adding placeholder dates, this is the number of rows: ", nrow(df), "\n")
```

# ---- Removing rows with NA for all, for id, or for daterated  ----
```{r removing NAs}
# Remove rows where all values are NA
df <- df[rowSums(is.na(df)) != ncol(df), ]

# Remove rows with NA in key columns (e.g., id, daterated)
df <- df %>%
  filter(!is.na(id), !is.na(daterated))
```

# ---- Setting Variable Formats  ----
- Convert daterated to Date format using lubridate if necessary (ensure date format matches)
```{r updating formats, include=TRUE}

# Convert daterated to Date format using lubridate if necessary (ensure date format matches)
df <- df %>%
  mutate(daterated = as.Date(mdy(daterated)))  # If in mm/dd/yyyy format
```

# ---- Hard-Coded Fixes ----
```{r hard-coded-changes}
# Hard-coding changes based on manual review

df$StartPeriod[df$id == 208 & df$TubeNumber == 27] <- 1
# Fix date issues for participant 210
df$daterated[df$id == 210 & df$daterated == as.Date("2021-11-20")] <- as.Date("2020-11-20")
df$daterated[df$id == 210 & df$daterated == as.Date("2021-11-21")] <- as.Date("2020-11-21")



# Add in missing menses onset dates from Urveesha
# <!-- Calculated menses onset (although almost all of these are recorded in the tracking sheet? Not sure why missing): -->
# <!-- 206 - 4/25/21 -->
# <!-- 208 - 2/27/21 -->
# <!-- 209 - 2/15/21 -->
# <!-- 255- 7/2/22 -->
# <!-- 258 - 7/11/22 -->
# <!-- 270 - 9/4/22 -->
# <!-- 279 - 10/27/22 -->
# <!-- 290 - 2/21/23 -->
# <!-- 291 - 2/10/23 -->
# <!-- 293 - 2/3/23 -->
# <!-- 312 - 7/4/23 -->
# <!-- 331 - 1/3/24 -->
# <!-- 332 - 1/21/24     -->

# Convert the dates to Date format
df[["daterated"]] <- as.Date(df[["daterated"]], format = "%m/%d/%y")

# Define a vector of IDs and their corresponding menses onset dates
menses_onset_data <- data.frame(
  id = c(206, 208, 209, 255, 258, 270, 279, 290, 291, 293, 312, 331, 332),
  onset_date = as.Date(c("2021-04-25", "2021-02-27", "2021-02-15", "2022-07-02", "2022-07-11", 
                         "2022-09-04", "2022-10-27", "2023-02-21", "2023-02-10", "2023-02-03", 
                         "2023-07-04", "2024-01-03", "2024-01-21"))
)

# Update StartPeriod in df for these ID and date combinations
for (i in 1:nrow(menses_onset_data)) {
  df[["StartPeriod"]][df[["id"]] == menses_onset_data$id[i] & df[["daterated"]] == menses_onset_data$onset_date[i]] <- 1
}
```

# ---- Set E2, P4, LH to NA for patients with unusable hormone data (based on Tory and Ashley Eng inspection of salivary E2 and P4) ----
- Note that their raw data can still be accessed in @rawdf
- The variable @removed_from_horm_analysis is created and set to 1 for all observations from these IDs
```{r}
# List of IDs whose hormone data should be flagged for missingness due to poor quality

badhorm_ids <- c(221, 235, 243, 267, 272, 273, 278, 283, 305, 307, 312, 317)

# Add a new binary column `remove_from_horm_analysis` to flag the IDs

df <- df %>%
  mutate(removed_from_horm_analysis = ifelse(id %in% badhorm_ids, 1, 0))

# For these ids, set variables E2 and P4 to missing
df <- df %>%
  mutate(E2 = ifelse(id %in% badhorm_ids, NA, E2),
         P4 = ifelse(id %in% badhorm_ids, NA, P4),
         LH = ifelse(id %in% badhorm_ids, NA, LH))

```

# ---- Calculate ADHD, UPPS, BDEFS, and DEBQ Scores ----
- reverse code pinball and robot
- Score ADHD, UPPS, and BDEFS Scales
#TODO add UPPS subscales here
```{r score-rename-scales}

df <- df %>%
  group_by(id) %>%
  mutate(
    # Convert columns to numeric to ensure proper summation
    CSS_Inatt = rowMeans(across(
      c(
        CSS_B_1,
        CSS_B_3,
        CSS_B_5,
        CSS_B_7,
        CSS_B_9,
        CSS_B_11,
        CSS_B_13,
        CSS_B_15,
        CSS_B_17
      ),
      ~ as.numeric(.)
    ), na.rm = TRUE),
    # Convert each column to numeric, handle missing values with na.rm = TRUE
    
    CSS_HypImp = rowMeans(across(
      c(
        CSS_B_2,
        CSS_B_4,
        CSS_B_6,
        CSS_B_8,
        CSS_B_10,
        CSS_B_12,
        CSS_B_14,
        CSS_B_16,
        CSS_B_18
      ),
      ~ as.numeric(.)
    ), na.rm = TRUE),
    # Same process for CSS_HypImp scores
    
    # Adding the counts without needing row-wise summation
    CSS_HypImp_Count = CSS_Imp_Count + CSS_Hyp_Count,
    
    # Direct summation of these variables, assuming they are already numeric
    
    # Functional Total Score: Summing specific function-related columns
    CSS_Fx_Total = rowMeans(across(
      c(
        CSS_Function_1,
        CSS_Function_2,
        CSS_Function_3,
        CSS_Function_4,
        CSS_Function_5,
        CSS_Function_6,
        CSS_Function_7,
        CSS_Function_8,
        CSS_Function_9,
        CSS_Function_10
      ),
      ~ as.numeric(.)
    ), na.rm = TRUE),
    
    # DEBQ Total Score summing all DEBQ columns
    DEBQ_Total = rowMeans(across(
      c(
        DEBQ_1,
        DEBQ_2,
        DEBQ_3,
        DEBQ_4,
        DEBQ_5,
        DEBQ_6,
        DEBQ_7,
        DEBQ_8,
        DEBQ_9,
        DEBQ_10,
        DEBQ_11,
        DEBQ_12,
        DEBQ_13
      ),
      ~ as.numeric(.)
    ), na.rm = TRUE),
    
    # BDEFS Total Score summing all BDEFS columns
    BDEFS_Total = rowMeans(across(
      c(BDEFS_1, BDEFS_2, BDEFS_3, BDEFS_4, BDEFS_5, BDEFS_6),
      ~ as.numeric(.)
    ), na.rm = TRUE)
  ) %>%
  ungroup()

# Reverse code pinball and robot

# Step 1: Find the maximum values for both variables
max_robot <- max(df$score_robot, na.rm = TRUE)
max_pinball <- max(df$score_pinball, na.rm = TRUE)

# Step 2: Reverse code the variables WITH SAME NAME
df$score_robot <- max_robot - df$score_robot
df$score_pinball <- max_pinball - df$score_pinball


# Check Histograms - they are all zero inflated

#hist(df$CSS_Inatt, breaks = 10, main = "Histogram of CSS_Inatt", xlab = "CSS_Inatt", col = "lightblue")
#hist(df$CSS_HypImp, breaks = 10, main = "Histogram of CSS_HypImp", xlab = "CSS_HypImp", col = "lightblue")
#hist(df$BDEFS_Total, breaks = 10, main = "Histogram of BDEFS_Total", xlab = "BDEFS_Total", col = "lightblue")
#hist(df$BDEFS_WM_avg, breaks = 10, main = "Histogram of BDEFS_WM_avg", xlab = "BDEFS_WM_avg", col = "lightblue")
#hist(df$BDEFS_RI_avg)

#hist(df$DEBQ_Total, breaks = 10, main = "Histogram of DEBQ_Total", xlab = "DEBQ_Total", col = "lightblue")

# Checking direction - They are all positively correlated

#cor(df$IA_Count, df$DEBQ_Total, use="pairwise.complete.obs")
#cor(df$BDEFS_Total, df$BDEFS_WM_avg, use="pairwise.complete.obs")
#cor(df$BDEFS_WM_avg, df$score_pinball, use="pairwise.complete.obs")
#cor(df$BDEFS_RI_avg, df$score_robot, use="pairwise.complete.obs")
```

# ---- Calculate Person Metrics .d, .zd, .m, and .sd for all daily variables ----
```{r run person metrics}

# Loop through each variable in alldailyvars list and create person-level metrics

for (var in alldailyvars) {
  df <- create.person.metrics(df=df, var = !!sym(var), id = id)
}

```

# ---- Calculate 3- and 5-day Rolling averages on raw, .d, .zd for all daily variables ----

```{r run rolling avgs}

# Loop through each variable and create 3- and 5-day rolling averages for each RAW variable in alldailyvars

for (var in alldailyvars) {
  df <- create.rolling.avgs(df, var = !!sym(var))
}

# Loop through each variable and create 3- and 5-day rolling averages for each .d variable in alldailyvars
for (var in alldailyvars) {
  # Create the .d version of the variable name
  var.d <- paste0(quo_name(var), ".d")
  
  # Pass the .d version as a symbol to the function
  df <- create.rolling.avgs(df, var = !!sym(var.d))
}

# Loop through each variable and create 3- and 5-day rolling averages for each .zd variable in alldailyvars
for (var in alldailyvars) {
  # Create the .zd version of the variable name
  var.zd <- paste0(quo_name(var), ".zd")
  
  # Pass the .d version as a symbol to the function
  df <- create.rolling.avgs(df, var = !!sym(var.zd))
}

# Confirm the calculation of new metrics .d.3roll, .d.5roll, .zd.3roll, and .zd.5roll

#DONE df %>% dplyr::select(id, daterated, DRSP_1, DRSP_1.d.3roll, DRSP_1.zd.3roll) %>% View()

```

# ---------------------------------------------------------------------------------- PRINT DATA INFO

# ---- Count Rows and Unique IDs ----
```{r count rows and ids}
count_rows_ids(df)
```

# ---- Evaluate N's and Missing Data ----        
```{r eval-Ns-horm-surv}

# Count the total number of "Days in Study" (total observations per ID)
df_count <- df %>%
  group_by(id) %>%
  summarize(days_in_study = n())

# Count the number of non-missing observations per ID for the variable DRSP_1
df_nonmissing_count <- df %>%
  group_by(id) %>%
  summarize(number_of_observations = sum(!is.na(DRSP_1)))

# Count the number of non-missing observations for the variable E2
df_e2_nonmissing_count <- df %>%
  group_by(id) %>%
  summarize(e2_nonmissing = sum(!is.na(E2)))

#### Handle Outliers ONLY for "Days in Study" ####

# Outlier removal for "Days in Study"
Q1 <- quantile(df_count$days_in_study, 0.25)
Q3 <- quantile(df_count$days_in_study, 0.75)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
df_no_outliers <- df_count %>%
  filter(days_in_study >= lower_bound & days_in_study <= upper_bound)

#### Determine Y-Axis Limits ####
y_min <- min(df_no_outliers$days_in_study, df_nonmissing_count$number_of_observations, df_e2_nonmissing_count$e2_nonmissing, na.rm = TRUE)
y_max <- max(df_no_outliers$days_in_study, df_nonmissing_count$number_of_observations, df_e2_nonmissing_count$e2_nonmissing, na.rm = TRUE)

#### Plots ####

# Plot "Days in Study" per ID (with outliers removed)
plot1_no_outliers <- ggplot(df_no_outliers, aes(x = factor(1), y = days_in_study, label = id)) +
  geom_violin(fill = "lightblue", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "blue", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Days in Study", title = "Days in Study per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Plot "Number of Observations" for DRSP_1 (without removing outliers)
plot2_no_outliers <- ggplot(df_nonmissing_count, aes(x = factor(1), y = number_of_observations, label = id)) +
  geom_violin(fill = "lightgreen", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "darkgreen", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Number of Observations (Non-missing DRSP_1)", title = "Surveys per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Plot "Number of non-missing E2 observations" (without removing outliers)
plot3_no_outliers <- ggplot(df_e2_nonmissing_count, aes(x = factor(1), y = e2_nonmissing, label = id)) +
  geom_violin(fill = "lightcoral", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "red", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Number of Observations (Non-missing E2)", title = "Hormone Days per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Combine the three plots on one page using grid.arrange from gridExtra
observations_plot <- grid.arrange(plot1_no_outliers, plot2_no_outliers, plot3_no_outliers, ncol = 3)

# Save the combined plot to a file with the current date
ggsave(filename = paste0(output_folder, "N_observations_plot_", current_date, ".png"), 
       plot = observations_plot, 
       width = 8, 
       height = 6)


```

# ---- Specific Ns for Days in Study, Survey Data, and Hormone Data ----        
```{r data N details}

# Filter the data for non-missing E2 values and count unique ids
non_missing_E2 <- df %>%
  filter(!is.na(E2))

non_missing_E2_count <- n_distinct(non_missing_E2$id)
non_missing_E2_ids <- unique(non_missing_E2$id)

# Get IDs with missing E2 values
missing_E2_ids <- setdiff(unique(df$id), non_missing_E2_ids)

# Print the result for non-missing E2 values
cat("Number of people WITH any hormones (E2):", non_missing_E2_count, "\n")
cat("The id values are:", "\n", paste(non_missing_E2_ids, collapse = ", "), "\n", "\n")

# Print the result for missing E2 values
cat("Number of people WITHOUT hormone data:", length(missing_E2_ids), "\n")
cat("Their id values are:", "\n", paste(missing_E2_ids, collapse = ", "), "\n", "\n")
cat("Of those, these ids were removed due to non-cyclic/insufficient hormone data as reviewed by Tory Eisenlohr-Moul and Ashley Eng:", "\n", paste(badhorm_ids, collapse = ", "), "\n", "\n")

# Filter the data for non-missing survey values and count unique ids
non_missing_survey <- df %>%
  filter(!is.na(DRSP_1))

non_missing_survey_count <- n_distinct(non_missing_survey$id)
non_missing_survey_ids <- unique(non_missing_survey$id)

# Get IDs with missing survey values
missing_survey_ids <- setdiff(unique(df$id), non_missing_survey_ids)

# Print the result for non-missing survey values
cat("Number of people WITH any surveys:", non_missing_survey_count, "\n")
cat("Their id values are:", "\n", paste(non_missing_survey_ids, collapse = ", "), "\n", "\n")

# Print the result for missing survey values
cat("Number of people WITHOUT any surveys:", length(missing_survey_ids), "\n")
cat("Their id values are:", "\n", paste(missing_survey_ids, collapse = ", "), "\n", "\n")

# Find the intersection of available hormone data and available survey data
intersection_ids <- intersect(non_missing_E2_ids, non_missing_survey_ids)
intersection_count <- length(intersection_ids)

# Print the result for the intersection of hormone and survey data
cat("Number of people WITH both usable hormone and any survey data:", intersection_count, "\n")
cat("Their id values are:", "\n", paste(intersection_ids, collapse = ", "), "\n", "\n")

# Count the non-missing observations of DRSP_1 and E2 for people with both hormone and survey data
non_missing_intersection <- df %>%
  filter(id %in% intersection_ids, !is.na(DRSP_1), !is.na(E2))

non_missing_intersection_count <- nrow(non_missing_intersection)

# Print the result for non-missing observations of DRSP_1 and E2
# NOTE THAT THERE WILL BE MORE PEOPLE WITH SCALED CYCLEDAY DATA
cat("Number of non-missing observations of DRSP_1 and E2 for people with both hormone and survey data:", non_missing_intersection_count, "\n")

# Create a list of IDs with the number of days with both E2 and DRSP
usable_days_list <- non_missing_intersection %>%
  group_by(id) %>%
  summarise(usable_days = n()) %>%
  arrange(usable_days)

# Print the list of IDs with the number of days in words
cat("List of IDs with the number of days having both E2 and DRSP (sorted by number of observations ascending):", "\n")
for (i in 1:nrow(usable_days_list)) {
  cat("id", usable_days_list$id[i], "has", usable_days_list$usable_days[i], "hormone-survey pairs.", "\n")
}

```

# ---- Plot Overlap of Available Data  ----        
# Plot days in study, nonmissing survey observations, and E2 observations per id 
#TODO I want to add a venn diagram here. 
```{r N details plot, message=FALSE, warning=FALSE}

# Count the total number of "Days in Study" (total observations per ID)
df_count <- df %>%
  group_by(id) %>%
  summarize(days_in_study = n())

# Count the number of non-missing observations per ID for the variable DRSP_1
df_nonmissing_count <- df %>%
  group_by(id) %>%
  summarize(number_of_observations = sum(!is.na(DRSP_1)))

# Count the number of non-missing observations for the variable E2
df_e2_nonmissing_count <- df %>%
  group_by(id) %>%
  summarize(e2_nonmissing = sum(!is.na(E2)))

#### Handle Outliers ONLY for "Days in Study" ####

# Outlier removal for "Days in Study"
Q1 <- quantile(df_count$days_in_study, 0.25)
Q3 <- quantile(df_count$days_in_study, 0.75)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
df_no_outliers <- df_count %>%
  filter(days_in_study >= lower_bound & days_in_study <= upper_bound)

#### Determine Y-Axis Limits ####
y_min <- min(df_no_outliers$days_in_study, df_nonmissing_count$number_of_observations, df_e2_nonmissing_count$e2_nonmissing, na.rm = TRUE)
y_max <- max(df_no_outliers$days_in_study, df_nonmissing_count$number_of_observations, df_e2_nonmissing_count$e2_nonmissing, na.rm = TRUE)

#### Plots ####

# Plot "Days in Study" per ID (with outliers removed)
plot1_no_outliers <- ggplot(df_no_outliers, aes(x = factor(1), y = days_in_study, label = id)) +
  geom_violin(fill = "lightblue", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "blue", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Days in Study", title = "Days in Study per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Plot "Number of Observations" for DRSP_1 (without removing outliers)
plot2_no_outliers <- ggplot(df_nonmissing_count, aes(x = factor(1), y = number_of_observations, label = id)) +
  geom_violin(fill = "lightgreen", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "darkgreen", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Number of Observations (Non-missing DRSP_1)", title = "Surveys per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Plot "Number of non-missing E2 observations" (without removing outliers)
plot3_no_outliers <- ggplot(df_e2_nonmissing_count, aes(x = factor(1), y = e2_nonmissing, label = id)) +
  geom_violin(fill = "lightcoral", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "red", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Number of Observations (Non-missing E2)", title = "Hormone Days per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Combine the three plots on one page using grid.arrange from gridExtra
observations_plot <- grid.arrange(plot1_no_outliers, plot2_no_outliers, plot3_no_outliers, ncol = 3)

# Save the combined plot to a file with the current date
ggsave(filename = paste0(output_folder, "N_observations_plot_", current_date, ".png"), 
       plot = observations_plot, 
       width = 8, 
       height = 6)


# Loop through each variable and create person-level metrics for each variable in alldailyvars

for (var in alldailyvars) {
  df <- create.person.metrics(df, var = !!sym(var), id = id)
}

#Confirm the presence of new person-level metrics .m, .sd, .d, and .zd

df %>% dplyr::select(id, daterated, ends_with(".m"), ends_with(".sd"), ends_with(".d"), ends_with(".zd")) %>% View()
```

# ---- Print Variable Names ----
```{r print variable names}
print.variable.names(df)
```

# ---------------------------------------------------------------------------------- CYCLE PREP SECTION

# Create dichotomous mensdayone/mensdayonefirst to indicate first day of period
```{r create-mensdayonefirst}

# Check the structure of the data
#str(df$id) #check id format
#str(df$daterated) #check daterated format

df <- df %>%
  filter(!is.na(id))

df <- df %>%
  arrange(id, daterated)


df$StartPeriod <- as.numeric(df$StartPeriod)

df <- df %>%
  mutate(mensdayone = case_when(
    is.na(StartPeriod) ~ NA_real_,
    StartPeriod == 1 ~ 1,
    TRUE ~ 0
  ))


# Eliminate all but the first menses onset day in a new variable called "mensdayonefirst"

# Process the data
df <- df %>%
  arrange(id, daterated) %>%  # Arrange the data by id and daterated
  group_by(id) %>%  # Group the data by id
  mutate(
    mensdayonefirst = case_when(
      is.na(mensdayone) ~ NA,
      mensdayone == 1 & (lag(mensdayone, order_by = daterated) != 1 | is.na(lag(mensdayone, order_by = daterated))) ~ 1,
      row_number() == 1 & mensdayone == 1 ~ 1,
      TRUE ~ 0
    )
  ) %>% 
  ungroup() # Remove the grouping

#Check

#df %>% dplyr::select(id, daterated, mensdayone, mensdayonefirst, PosLHTest) %>% View()


```

# Create "LHposday" (0/1/NA) that represents the positive LH day.
```{r create LHposday}


###View(df)
  
  df$PosLHTest <- as.numeric(df$PosLHTest)

df <- df %>%
  mutate(LHposday = case_when(
    is.na(PosLHTest) ~ NA_real_,
    PosLHTest == 1 ~ 1,
    TRUE ~ 0
  ))

###View(df)

# Eliminate all but the first pos Ov day in a new variable called "LHposdayfirst"
df <- df %>%
  arrange(id, daterated) %>%  # Arrange the data by id and daterated
  group_by(id) %>%  # Group the data by id
  mutate(
    LHposdayfirst = case_when(
      is.na(LHposday) ~ NA_real_,
      LHposday == 1 & lag(LHposday, order_by = daterated) != 1 ~ 1,
      TRUE ~ 0
    )
  ) %>% 
  ungroup()  # Remove the grouping

#Check vars
#DONE df %>% dplyr::select(id, daterated, mensdayonefirst, LHposdayfirst) %>% View()

```

# TURNED OFF - Remove people who never had a positive LH test
# This needs to be ON if we are going to use 5-phase cycle variable
```{r remove-no-pos-LH}
# 
# # Create a person-level variable
# idlhpos <- df %>%
#   group_by(id) %>% 
#   summarise(LHeverpos = ifelse(sum(LHposdayfirst, na.rm = TRUE) > 0, 1, 0)) %>% 
#   ungroup()
# 
# # Merge it back into df
# df <- df %>%
#   left_join(idlhpos, by = "id")
# 
# 
# # Display number of rows before removing those with no pos LH
# cat("Number of rows before removing those who never had a positive LH test: ", nrow(df), "\n")
# 
# # Filter out people with LHids = 0
# df <- df %>%
#   filter(LHeverpos == 1)
# 
# #Check vars -
# #df %>% dplyr::select(id, LHeverpos, daterated, mensdayonefirst, LHposdayfirst) %>% head()

```

# Code Cycle Day Forward + Backward count from menses onset
```{r menses-count-vars}

#make A as a variable copy of mensdayonefirst
df$A <- df$mensdayonefirst

cycleCount <- function(x) {
  #Get the index of 1
  inds <- which(x == 1)
  if(!length(inds)) return(0) 
  #Create a sequence with that index as 0
  num <- lapply(inds, function(i) {
    num <- seq_along(x) - i
    #Add 1 to values greater than equal to 0
    num[num >= 0] <- num[num >= 0] + 1
    num[num < -15 | num > 11] <- NA 
    num
  })
  #Select the first non-NA values from the sequence
  do.call(coalesce, num)
}

df <- df %>% group_by(id) %>% 
  mutate(cycleday = cycleCount(A))

#df <- df %>% dplyr::select(!A)

###View(df)

#Check vars
#df %>% dplyr::select(id, LHeverpos, daterated, mensdayonefirst, LHposdayfirst, cycleday) %>% View()

```

# Review Data, looking for cycleday=0 and removing those who never had any menses onsets
#TODO automate this somehow and provide report
```{r review-data}

# Check the data 
#DONE df %>% dplyr::select(id, daterated, mensdayonefirst, cycleday, LHposdayfirst, cycleday) %>% View()

#how many observations do you have for each cycle day?
nobs <- df %>% group_by(cycleday) %>% summarize(n=n())

#DONE; NONE; View(nobs)

#do you have any observations that got assigned a cycle day of 0? this is wrong, and you should check who that happened for
df %>% filter(cycleday==0) %>% pull(id)

# NOTE 2024-07-09: There are 2 people with lots of zeroes (see Jordan's note above in chunk) and it looks to me like they did not report a menses in the daily dataset: 331, 332. They have no menses onset dates

#View in a separate window and manually scroll through
#Not needed?  df %>% dplyr::select(id, daterated, mensdayonefirst, cycleday, LHposdayfirst, cycleday) %>% View()

# List of IDs to remove - people with no menses onsets - it looks like this overlaps with the people who never reported a positive LH test
ids_w_no_menses_onset <- c(211, 292, 295, 296, 297, 298, 299, 302, 308, 313, 315, 331, 332, 333, 334, 336)

# Remove rows with specified IDs
df <- df %>% filter(!(id %in% ids_to_remove))


```

# Make daycountLH, based on positive LH test (LH test day = 0)
```{r LH-count-vars}
#make A a new temp column where pt received pos ov test
df$L <- df$LHposdayfirst

#FUNCTION for calculating the sequence
LHCount <- function(x) {
  #Get the index of 1
  inds <- which(x == 1)
  if(!length(inds)) return(0) 
  #Create a sequence with that index as 0
  num <- lapply(inds, function(i) {
    num <- seq_along(x) - i
    num[num < -7 | num > 15] <- NA 
    num
  })
  #Select the first non-NA values from the sequence
  do.call(coalesce, num)
}

#run the LHCount function and save it as as a new column called daycountLH
df<- df %>% group_by(id) %>% 
  mutate(daycountLH = LHCount(L))
#remove the temp column L
df <- df %>% dplyr::select(!L)

#Check vars
#df %>% dplyr::select(id, LHeverpos, daterated, mensdayonefirst, LHposdayfirst, daycountLH) %>% View()
```

############################################################################# CYCLE SCALING

## Using CYCLEDAY SCALING TEMPLATE - from Anisha updated September 14, 2024

```{r}
# Group the dataset by 'id', sort each group by 'daterated', and add a new column 'folmax' with NA values.
df <- df %>%
  group_by(id) %>%                          # Group the data by 'id' to ensure operations are performed within each individual.
  arrange(daterated, .by_group = TRUE) %>%  # Arrange (sort) the data by 'daterated' within each group.
  mutate(folmax = NA)                       # Add a new column named 'folmax' initialized with NA values.

# Create a new column 'A' to indicate menses onset.
# Set 'A' to 1 if 'cycleday' is equal to 1 (indicating menses onset), otherwise set to 0.
df <- df %>%
  mutate(A = ifelse(is.na(cycleday), 0, ifelse(cycleday == 1, 1, 0)))

# Calculate 'ovtoday' by lagging the 'LHposdayfirst' within each group.
# The 'lag' function retrieves the value from the previous row, allowing for the calculation of the ovulation day.
df <- df %>%
  mutate(ovtoday = dplyr::lag(LHposdayfirst))

# (Optional) Check selected columns of the dataset for verification purposes.
# Uncomment the following code to view the 'daterated', 'ovtoday', and 'LHposdayfirst' columns.
# df %>%
#   ungroup() %>% # Ungroup to avoid unnecessary grouping for this operation
#   select(daterated, ovtoday, LHposdayfirst) %>%
#   View()

```

# Calculate Menses-to-Menses Cycle Lengths 

## Calculation of Cycle Lengths and Complete Cycles using 'mcyclength' function

```{r}
# Use the 'calculate_mcyclength' function to determine menses-to-menses cycle lengths for each individual in the dataset.
# This function will also count the number of complete cycles for each person.
df <- calculate_mcyclength(df)

# Replace '-Inf' values in the 'mcyclength' column with 'NA'.
# '-Inf' can occur if the cycle is incomplete (missing a bookend menses onset date).
df$mcyclength <- ifelse(df$mcyclength == -Inf, NA, df$mcyclength)

# Mark incomplete cycles by setting 'cycle_incomplete' to 1 if 'cyclenum' is NA.
df$cycle_incomplete <- ifelse(is.na(df$cyclenum), 1, df$cycle_incomplete)

# (Optional) Check selected columns of the dataset for verification purposes.
# View the columns to ensure proper calculation of cycle information.
df %>% 
  dplyr::select(id, daterated, A, m2mcount, ovtoday, cyclenum, mcyclength, cycle_incomplete)
```



Here, I am doing scaling for baseline, washout, and PBO condition

# calculating ovtoday_impute
 
```{r}
# this is based on NC dataset 

  
  
  
df <- df %>% 
  mutate(lutlength_impute = case_when(mcyclength == 20 ~ (mcyclength* 0.46),
                                      mcyclength == 21 ~ (mcyclength*.476),
                                      mcyclength == 22 ~ (mcyclength*.491),
                                      mcyclength == 23 ~ (mcyclength*.491),
                                      mcyclength == 24 ~ (mcyclength*.492),
                                      mcyclength == 25 ~ (mcyclength*.484),
                                      mcyclength == 26 ~ (mcyclength*.481),
                                      mcyclength == 27 ~ (mcyclength*.470),
                                      mcyclength == 28 ~ (mcyclength*.461),
                                      mcyclength == 29 ~ (mcyclength*.448),
                                      mcyclength == 30 ~ (mcyclength*.437),
                                      mcyclength == 31 ~ (mcyclength*.426),
                                      mcyclength == 32 ~ (mcyclength*.416),
                                      mcyclength == 33 ~ (mcyclength*.40),
                                      mcyclength == 34 ~ (mcyclength*.391),
                                      mcyclength == 35 ~ (mcyclength*.377),
                                      mcyclength == 36 ~ (mcyclength*.369),
                                      mcyclength == 37 ~ (mcyclength*.359),
                                      TRUE ~ NA))

df <- df %>% 
  mutate(follength_impute = case_when(mcyclength == 20 ~ (mcyclength*.54),
                                      mcyclength == 21 ~ (mcyclength*.524),
                                      mcyclength == 22 ~ (mcyclength*.509),
                                      mcyclength == 23 ~ (mcyclength*.509),
                                      mcyclength == 24 ~ (mcyclength*.508),
                                      mcyclength == 25 ~ (mcyclength*.516),
                                      mcyclength == 26 ~ (mcyclength*.519),
                                      mcyclength == 27 ~ (mcyclength*.530),
                                      mcyclength == 28 ~ (mcyclength*.539),
                                      mcyclength == 29 ~ (mcyclength*.552),
                                      mcyclength == 30 ~ (mcyclength*.563),
                                      mcyclength == 31 ~ (mcyclength*.574),
                                      mcyclength == 32 ~ (mcyclength*.584),
                                      mcyclength == 33 ~ (mcyclength*.60),
                                      mcyclength == 34 ~ (mcyclength*.609),
                                      mcyclength == 35 ~ (mcyclength*.623),
                                      mcyclength == 36 ~ (mcyclength*.631),
                                      mcyclength == 37 ~ (mcyclength*.641),
                                      TRUE ~ NA))
#check data
df %>% dplyr::select(id, daterated, A, m2mcount, mcyclength, follength_impute)
#group by id, and make sure dates are in order 
df <- df %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) 
#initialize new variable- follcount1
df$follcount1 <- NA
for (i in 1:nrow(df)) {
  if (df$A[i] == 1 & !is.na(df$follength_impute[i])) {
    follcount1 <- seq_len(round(df$follength_impute[i]))
    df$follcount1[i:(i + length(follcount1) - 1)] <- follcount1
  }
}
#follcount1 forward counts from menses onset based on imputed follength from NC data 

df %>% dplyr::select(id, A, follength_impute, follcount1)

#identify ovtoday_impute based on forward count from follcount1
df <- df %>% 
  mutate(ovtoday_impute = case_when(round(follength_impute) == follcount1 ~ 1,
                               TRUE ~ NA))

#if ovtoday is NA, change to 0 
df$ovtoday <- ifelse(is.na(df$ovtoday), 0, df$ovtoday) 

#if ovtoday_impute is NA, change to 0 
df$ovtoday_impute <- ifelse(is.na(df$ovtoday_impute), 0, df$ovtoday_impute) 

#check data 
df %>% dplyr::select(id, daterated, ovtoday, ovtoday_impute) # Removed cleartrialphase
```


# percentage of luteal phase using ovtoday (LH + 1) 

 - variable is called perclut for menses-centered
 - variable is called perclut_ov for ovulation-centered 
 

```{r}
#group by id, make sure daterated is in order, initialize the variable lutmax 
df <- df  %>% 
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(lutmax = NA)
#apply the calculate_lutdaycount function. which spits out the variable lutdaycount1. lutdaycount1 forward counts from ovtoday = 1 to the next menses onset, indexed at 0 
df <- calculate_lutdaycount(df, df$ovtoday)
#check data 
df %>% dplyr::select(id, daterated, ovtoday, A, lutdaycount1)
#the below code creates lutdaycount which shifts lutdaycount1, and forward counts starting the day after ovtoday = 1, still indexed at 0 
df <- df %>%
  group_by(id) %>%
  mutate(
    lutdaycount = lag(lutdaycount1),
    lutdaycount = case_when(
      is.na(lutdaycount) | id != lag(id) ~ NA, 
      TRUE ~ lutdaycount
    )
  )

df <- df %>%
  group_by(id) %>%
  mutate(
    lut_incomplete = lag(lut_incomplete1),
    lut_incomplete = case_when(
      is.na(lut_incomplete) | id != lag(id) ~ NA, 
      TRUE ~ lut_incomplete
    )
  )


#check data 
df %>% dplyr::select(id, daterated, ovtoday, A, lutdaycount, lut_incomplete)
#lutmax corresponds to the length of the luteal phase in a complete menses-to-menses cycle (it is the max value of lutdaycount in a cycle)
for (i in 1:(nrow(df)-1)) {
  if (is.na(df$lutdaycount[i + 1] && !is.na(df$lutdaycount[i]))) {
    df$lutmax[(i-(df$lutdaycount[i])):i] = as.numeric(df$lutdaycount[i])
  }
}

df$lut_incomplete = ifelse(df$lutmax > 30, 1, df$lut_incomplete)
#check data 
df %>% dplyr::select(id, daterated, ovtoday, A, lutdaycount, lutmax, lut_incomplete)

#calculates lutperc which is luteal phase scaled from 0 to 1, using ovtoday 
df <- df %>%
  mutate(lutperc = ifelse(lut_incomplete == 0, (lutdaycount / lutmax), NA))

#calculates perclut_base which is luteal phase scaled from -1 to 0, using ovtoday. This is the variable that will be used in the menses-centered scaled_cycleday 
df$perclut = df$lutperc -1 

# df <- df %>%
#   mutate(perclut = ifelse(A == 1, 0, perclut))

#check data
df %>% dplyr::select(id, daterated, ovtoday, A, lutmax, perclut, lut_incomplete)

#calculate lutdaycount_ov, which is lutdaycount but ovulation-centered 
df <- df %>%
  group_by(id) %>%
  mutate(
    lutdaycount_ov = lead(lutdaycount),
    lutdaycount_ov = case_when(is.na(lutdaycount_ov) |
                                 id != lead(id) ~ NA, TRUE ~ lutdaycount_ov)
  )

df <- df %>%
  mutate(perclut_ov = ifelse(lut_incomplete == 0, lutdaycount_ov / lutmax, NA))

# df <- df %>%
#   mutate(perclut_ov = ifelse(lutdaycount_ov == 0, 0, perclut_ov))


df %>% dplyr::select(id,
               daterated,
               ovtoday,
               A,
               lutdaycount,
               lutdaycount_ov,
               lutmax,
               perclut_ov, perclut)

#remove 'helper' variables
df <- df %>% dplyr::select(-c(lutdaycount1, lutperc, lut_incomplete1))

```

# percentage of luteal phase using ovtoday_impute (based on NC norms)


```{r}

#make sure dates are in order for each id, initialize new variable called lutmax_impute
df <- df  %>% 
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(lutmax_impute = NA)
#if A is NA, make it 0 (A is menses onset)
df$A <- ifelse(is.na(df$A), 0, df$A)
#apply calculate_lutdaycount fxn which spits out the variable lutdaycount1. lutdaycount1 forward counts from ovtoday_impute = 1 to the next menses onset, indexed at 0 
df <- calculate_lutdaycount(df, df$ovtoday_impute)
#check data
df %>% dplyr::select(id, daterated, ovtoday_impute, A, lutdaycount1)
#the below code creates lutdaycount_impute which shifts lutdaycount1, and forward counts starting the day after ovtoday_impute = 1, still indexed at 0 
df <- df %>%
  group_by(id) %>%
  mutate(
    lutdaycount_impute = lag(lutdaycount1),
    lutdaycount_impute = case_when(
      is.na(lutdaycount_impute) | id != lag(id) ~ NA, 
      TRUE ~ lutdaycount_impute
    )
  )
#check data 
df %>% dplyr::select(id, daterated, ovtoday_impute, A, lutdaycount_impute)

#lutmax_impute corresponds to the length of the luteal phase in a complete menses-to-menses cycle, using ovtoday_impute (it is the max value of lutdaycount_impute in a cycle)
for (i in 1:(nrow(df)-1)) {
  if (is.na(df$lutdaycount_impute[i + 1] && !is.na(df$lutdaycount_impute[i]))) {
    df$lutmax_impute[(i-(df$lutdaycount_impute[i])):i] = as.numeric(df$lutdaycount_impute[i])
  }
}
#lutlength1_impute is the imputed value of luteal phase based on NC norms, but lagged one day so it does align with any dates in the follicuar phase 
df$lutlength1_impute = lag(df$lutlength_impute)

#check data
df %>% dplyr::select(id, daterated, ovtoday_impute, A, lutdaycount_impute, lutmax_impute, lutlength_impute, lutlength1_impute)

#calculate lutperc_impute
df <- df %>%
  mutate(lutperc_impute = if_else(
    is.na(lutlength1_impute),
    NA,
    if_else(
      is.na(lutlength1_impute) &
        !is.na(lutmax_impute) & cycle_incomplete == 0,
      lutdaycount_impute / lutmax_impute,
      lutdaycount_impute / round(lutlength1_impute)
    )
  ))

#lutperc is scaled from 0 to 1, so substracting 1 so that it is scaled from -1 to 0 for menses-centered scaled_cycleday 
df$perclut_impute = df$lutperc_impute -1 

#check data
df %>% dplyr::select(id, daterated, ovtoday_impute, A, mcyclength, perclut_impute, perclut) 

#calculate lutdaycount_imp_ov, which is imputed lutdaycount but ovulation-centered 
df <- df %>%
  group_by(id) %>%
  mutate(
    lutdaycount_imp_ov = lead(lutdaycount_impute),
    lutdaycount_imp_ov = case_when(
      is.na(lutdaycount_imp_ov) | id != lead(id) ~ NA, 
      TRUE ~ lutdaycount_imp_ov
    )
  )

#calculate lutperc_imp_ov which is the variable that will go into ovulation-centered scaled cycleday 
df <- df %>%
  mutate(perclut_imp_ov = if_else(
    is.na(lutlength1_impute) ,
    NA,
    if_else(
      is.na(lutlength1_impute) & !is.na(lutmax) & cycle_incomplete == 0,
      lutdaycount1 / lutmax_impute,
      lutdaycount1 / round(lutlength1_impute)
    )
  ))


#if ovtoday_impute == 1, set lutperc_imp_ov to 0
# df <- df %>%
#   mutate(perclut_imp_ov = ifelse(ovtoday_impute == 1, 0, perclut_imp_ov))

#check data 
df %>% dplyr::select(id, daterated, ovtoday_impute, A, lutdaycount, lutlength1_impute, lutdaycount1, lutmax_impute, perclut_impute, perclut_imp_ov)

#remove helper variables
df <- df %>% dplyr::select (-c(lutperc_impute, lutdaycount1))
```

# percentage of follicular phase using ovtoday (LH+1)

```{r}
# Check for missing values
table(df$id)
table(df$ovtoday)

#remove obs with missing id or ovtoday
df <- df %>%
  filter(!is.na(id) & !is.na(ovtoday))

# Ensure daterated is in order by id and initialize folmax variable
df <- df %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax = NA)

#make sure daterated is in order by id, and initialize folmax variable 
df <- df %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax = NA)

#apply calculate foldaycount function using ovtoday 
df <- calculate_foldaycount(df, df$ovtoday)

#foldaycount forward counts starting at menses onset and ends at ovtoday 
df %>% dplyr::select(id, daterated, A, ovtoday, foldaycount)

#assigns folmax as the max value of foldaycount within a cycle 
for (i in 1:(nrow(df)-1)) {
  if (is.na(df$foldaycount[i + 1] && !is.na(df$foldaycount[i]))) {
    df$folmax[(i-(df$foldaycount[i])):i] = as.numeric(df$foldaycount[i])
  }
}

#follength is the length of the follicular phase that cycle (since folmax is indexed at 0)
df$follength = df$folmax + 1 

#check data
df %>% dplyr::select(id, daterated, ovtoday, A, foldaycount, folmax, follength, fol_incomplete)

df <- df %>%
  mutate(percfol = ifelse(fol_incomplete != 1, foldaycount / (folmax), NA))

df$percfol_ov = df$percfol - 1

df %>% dplyr::select(id, daterated, ovtoday, A, foldaycount, folmax, percfol, percfol_ov)

#renaming foldaycount based on ovtoday to be called foldaycount_ov. the variable name 'foldaycount' get overwritten in the code chunk below when the calculate_foldaycount() function is run 
df <- df %>% rename(foldaycount_ov = foldaycount)

```

# percentage of follicular phase using ovtoday_impute (based on NC norms)

```{r}


#yes, I'm constantly arranging by daterated because I'm paranoid. Initialize the variable folmax_impute 
df <- df %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax_impute = NA)
#see comment on line 512
df <- calculate_foldaycount(df, df$ovtoday_impute)
df <- df %>% rename(foldaycount_impute = foldaycount)
df %>% dplyr::select(id, daterated, ovtoday_impute, A, foldaycount_impute)

#create folmax_impute which is the max value of foldaycount_impute and matches the imputed follicular length in complete cycles 
for (i in 1:(nrow(df)-1)) {
  if (is.na(df$foldaycount_impute[i + 1] && !is.na(df$foldaycount_impute[i]))) {
    df$folmax_impute[(i-(df$foldaycount_impute[i])):i] = as.numeric(df$foldaycount_impute[i])
  }
}

df <- df %>%
  mutate(percfol_impute = ifelse(cycle_incomplete == 0, foldaycount_impute / (folmax_impute), NA))

# ovulation-centered percfol based on ovtoday_impute 
df$percfol_imp_ov = df$percfol_impute - 1


df %>% dplyr::select(id, daterated, ovtoday_impute, A, percfol_impute, percfol_imp_ov)
```




# prioritize LH test-based scaled values over imputed values 

```{r}

#functions to prioritize perc_base over perc

create_percent <- function(df, percentvar, percvar, percvar_impute) {
  percentvar <- ensym(percentvar)
  percvar <- ensym(percvar)
  percvar_impute <- ensym(percvar_impute)
  
  df %>%
    group_by(id, cyclenum) %>%
    mutate(
      !!percentvar := if (all(is.na(!!percvar) | !!percvar == 0)) {
        # if percvar contains only NA or 0, use percvar_impute
        !!percvar_impute
      } else {
        # otherwise, use percvar
        !!percvar
      }
    ) %>%
    ungroup()
}


df = create_percent(df, percentlut, perclut, perclut_impute)
df = create_percent(df, percentfol, percfol, percfol_impute)
df = create_percent(df, percentlut_ov, perclut_ov, perclut_imp_ov)
df = create_percent(df, percentfol_ov, percfol_ov, percfol_imp_ov)

df %>% dplyr::select(id, daterated, A, ovtoday, ovtoday_impute, cyclenum, mcyclength, percfol, percfol_impute, percentlut_ov)
```


# creating scaled_cycleday 

```{r}


df <- df %>%
  mutate(scaled_cycleday = ifelse(is.na(percentlut), percentfol, percentlut))
df %>% dplyr::select(id, daterated, percentlut, percentfol, scaled_cycleday)

```

# creating scaled_cycleday_ov

```{r}
df <- df %>%
  mutate(scaled_cycleday_ov = ifelse(is.na(percentlut_ov), percentfol_ov, percentlut_ov))
df %>% dplyr::select(id, daterated, percentlut_ov, percentfol_ov, scaled_cycleday_ov)

```


## Rounding Percents for LUTEAL-FOLLICULAR ORDER

```{r}


df <- df %>%
  mutate(cycleday_perc = (scaled_cycleday + 1) / 2) %>%
  mutate(cycleday_perc_round = round(cycleday_perc, 1)) %>%
  mutate(cycleday_10perc = round(cycleday_perc / 0.10) * 0.10) %>%
  mutate(cycleday_5perc = round(cycleday_perc / 0.05) * 0.05) %>%
  mutate(cycleday_2perc = round(cycleday_perc / 0.02) * 0.02)


```


## Rounding Percents for FOLLICULAR-LUTEAL ORDER

```{r}


df <- df %>%
  mutate(cycledayov_perc = (scaled_cycleday_ov + 1) / 2) %>%
  mutate(cycledayov_perc_round = round(cycledayov_perc, 1)) %>%
  mutate(cycledayov_10perc = round(cycledayov_perc / 0.10) * 0.10) %>%
    mutate(cycledayov_5perc = round(cycledayov_perc / 0.05) * 0.05) %>%
  mutate(cycledayov_2perc = round(cycledayov_perc / 0.02) * 0.02)


```


#RE-CALCULATE DEVATIONS AND STD AND ROLLING AVGS


```{r}


#create rolling averages on RAW variables
for (i in outcomelist) {
  df <- create.3day.rolling.avg(df, !!sym({{i}}), 3)
}

#MEANS

#execute for loop: run create.person.mean() on everything in "outcomelist.roll"
for (i in outcomelist.roll) {
  df <- create.person.mean(df, !!sym({{i}}), id)
}

#execute for loop: run create.person.mean() on everything in "outcomelist"
for (i in outcomelist) {
  df <- create.person.mean(df, !!sym({{i}}), id)
}

#PERSON-DEVIATIONS

#for raw deviations
#execute for loop: run create.deviation() on everything in list
for (i in outcomelist) {
  df <- create.deviation(df, !!sym({{i}}), !!sym(paste0({{i}}, ".m")))
}

#for rolling avgs deviations
#execute for loop: run create.deviation() on everything in list
for (i in outcomelist.roll) {
  df <- create.deviation(df, !!sym({{i}}), !!sym(paste0({{i}}, ".m")))
}


#Check 
df %>% dplyr::select(id, E2, E2.m, E2.d, E2.roll, E2.roll.d) %>% View()

```




# Count participants and rows - L2N = 97, L1N = 4808
```{r CountIDs}

# Count how many remaining ids I have in the dataset
unique_id_count <- length(unique(df$id))
# Print the number of unique IDs
print(unique_id_count)

# NUMBER OF ROWS
print(nrow(df))
```


# Create "id_list": list of all remaining participant IDs to loop through
```{r}

# Assuming df is your dataframe
# Count how many remaining ids you have in the dataset
unique_id_count <- length(unique(df$id))

# Get a list of unique IDs in the dataset
id_list <- unique(df$id)

# Print the number of unique IDs and the list of unique IDs in a sentence
cat("There are", unique_id_count, "unique IDs in the dataset. The IDs are:", paste(id_list, collapse = ", "), ".\n")

```

# Remove people with bad hormone IDs (after that, L2N=85, L1N=4194)
```{r}


# There are 12 people whose hormones should probably be removed for sensitivity analysis
badhorm_ids <- c(221, 235, 243, 267, 272, 273, 278, 283, 305, 307, 312, 317)
#Filtering for sensitivity analyses: 

# Create a new dataset removing IDs with bad hormones
df <- df

df <- df %>% filter(!(id %in% badhorm_ids))

```


# AFTER: Create "id_list": list of all remaining participant IDs to loop through
```{r}

# Assuming df is your dataframe
# Count how many remaining ids you have in the dataset
unique_id_count <- length(unique(df$id))

# Get a list of unique IDs in the dataset
id_list <- unique(df$id)

# Print the number of unique IDs and the list of unique IDs in a sentence
cat("There are", unique_id_count, "unique IDs in the dataset. The IDs are:", paste(id_list, collapse = ", "), ".\n")



# ---- Placeholder for Missing Dates ----

# Display the number of rows BEFORE adding placeholders
cat("Number of rows BEFORE adding placeholders: ", nrow(df), "\n")

df <- df %>%
  group_by(id) %>%
  complete(daterated = seq.Date(min(daterated), max(daterated), by = "day")) %>%
  ungroup()

# Display the number of rows after adding placeholders
cat("Number of rows AFTER adding placeholders: ", nrow(df), "\n")

```

# Count participants and rows - FULL DATASET

```{r}
# Count how many remaining ids I have in the dataset
unique_id_count <- length(unique(df$id))
# Print the number of unique IDs
print(unique_id_count)

# NUMBER OF ROWS
print(nrow(df))
```


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

##### END OF DATA PREP 


# Save out Prepped Dataset for Easier Use Later On

## DATASET (L2N=85, L1N=4195)


```{r}

write.csv(df, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/adhd_daily_df_20241017_L2N85.csv", row.names = FALSE)

variable_names <- names(df)
formatted_list <- paste(variable_names, collapse = ", ")
cat(formatted_list)

```




# Input dataset

```{r}
# Load your CSV file (adjust the path to your actual file location)
df <- read_csv("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/adhd_daily_df_20241017_L2N85.csv")
```



# Check Association between cycleday variable and days since starting

```{r}

df$TubeNumber <- as.numeric(df$TubeNumber) # Convert TubeNumber to numeric

df_first <- df %>%
  group_by(id) %>%
  filter(TubeNumber == 1) %>%
  ungroup()

hist(df_first$scaled_cycleday, breaks = 30)


#cor(x=as.numeric(df$TubeNumber), y=df$scaled_cycleday, use="complete.obs")

#plot(x=as.numeric(df$TubeNumber), y=df$scaled_cycleday, use="complete.obs")

```

# 2024-10-17 - HORIZON PLOTS OF RAW DATA

<!-- HCL palettes -->

<!-- Type:  Qualitative  -->
<!-- Names: Pastel 1, Dark 2, Dark 3, Set 2, Set 3, Warm, Cold, Harmonic, Dynamic -->

<!-- Type:  Sequential (single-hue)  -->
<!-- Names: Grays, Light Grays, Blues 2, Blues 3, Purples 2, Purples 3, Reds 2, Reds 3, Greens 2, Greens 3, -->
<!--        Oslo -->

<!-- Type:  Sequential (multi-hue)  -->
<!-- Names: Purple-Blue, Red-Purple, Red-Blue, Purple-Orange, Purple-Yellow, Blue-Yellow, Green-Yellow, -->
<!--        Red-Yellow, Heat, Heat 2, Terrain, Terrain 2, Viridis, Plasma, Inferno, Rocket, Mako, Dark -->
<!--        Mint, Mint, BluGrn, Teal, TealGrn, Emrld, BluYl, ag_GrnYl, Peach, PinkYl, Burg, BurgYl, -->
<!--        RedOr, OrYel, Purp, PurpOr, Sunset, Magenta, SunsetDark, ag_Sunset, BrwnYl, YlOrRd, YlOrBr, -->
<!--        OrRd, Oranges, YlGn, YlGnBu, Reds, RdPu, PuRd, Purples, PuBuGn, PuBu, Greens, BuGn, GnBu, -->
<!--        BuPu, Blues, Lajolla, Turku, Hawaii, Batlow -->

<!-- Type:  Diverging  -->
<!-- Names: Blue-Red, Blue-Red 2, Blue-Red 3, Red-Green, Purple-Green, Purple-Brown, Green-Brown, Blue-Yellow -->
<!--        2, Blue-Yellow 3, Green-Orange, Cyan-Magenta, Tropic, Broc, Cork, Vik, Berlin, Lisbon, -->
<!--        Tofino -->

```{r warning=FALSE}

#colorspace::hcl_palettes() # Lists available HCL palettes.


horiz_plot <-df %>%  
  ggplot() +  # Start the ggplot chain with the dataset `df`
  
  # Create a horizon plot using the geom_horizon function
  # The 'aes' function specifies the x and y aesthetics for the plot.
  # 'scaled_cycleday' is mapped to the x-axis (indicating cycle days),
  # and 'E2' (estradiol levels) is mapped to the y-axis.
  geom_horizon(aes(scaled_cycleday_ov, 
                   E2zd), # Use the 'E2zd' variable for the y-axis.
               # The 'origin' argument defines the baseline for splitting positive/negative values.
               origin = 'midpoint',  # Split the plot at the midpoint between positive and negative values.
               
               # 'horizonscale' defines how many layers (shades) the plot will have to represent different ranges.
               horizonscale = 7) +  # Use 4 levels of shading.
  
  # Add a color scale using the HCL color palette ('BluGrn').
  # 'reverse = T' reverses the color scheme so that lower values have darker colors and higher values are lighter.
  
  scale_fill_hcl(palette = 'Heat', reverse = T) + 
  
  
  # Create a faceted plot with individual panels for each 'id' (participant ID) along the y-axis.
  # '~.' specifies that there's only faceting on the y-axis (id~.). Each ID will get its own horizontal plot.
  facet_grid(id~.) +
  
  # Apply the 'theme_few' theme for a clean, minimal look.
  theme_few() +
  
  # Customize the theme further:
  theme(
    # Set the vertical spacing between panels to zero lines.
    panel.spacing.y = unit(0, "lines"),
    
    # Customize the text of the facet strips (which show the participant IDs).
    # Size is set to 7, text is horizontal (angle = 0), and aligned to the left (hjust = 0).
    strip.text.y = element_text(size = 6, angle = 0, hjust = 0),
    
    # Remove the legend from the plot.
    legend.position = 'right',
    
    # Remove the y-axis labels (numbers/text), the y-axis title, and the y-axis ticks.
    axis.text.y = element_blank(),  # No y-axis text.
    axis.title.y = element_blank(),  # No y-axis title.
    axis.ticks.y = element_blank(),  # No ticks on the y-axis.
    
    # Remove the border around each panel.
    panel.border = element_blank()
  ) +
  
  # Optionally, you could uncomment the line below if you want to format the x-axis to display date labels.
  # Here, 'scale_x_date' expands the x-axis to avoid clipping at the ends and sets a date format with daily breaks.
  # scale_x_date(expand=c(0,0), date_breaks = "1 da", date_labels = "%b") +
  
  # Add a title to the plot.
  ggtitle('Person-Std E2 Across (Menses to Menses) Cycle by ID') +
  
  # Add a label to the x-axis.
  xlab('Scaled Cycleday (Ovulation at 0)')

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-17/E2_horizon_plot_mens-mens.png", 
       plot = horiz_plot, 
       width = 8, 
       height = 6)

horiz_plot <-df %>%  
  ggplot() +  # Start the ggplot chain with the dataset `df`
  
  # Create a horizon plot using the geom_horizon function
  # The 'aes' function specifies the x and y aesthetics for the plot.
  # 'scaled_cycleday' is mapped to the x-axis (indicating cycle days),
  # and 'E2' (estradiol levels) is mapped to the y-axis.
  geom_horizon(aes(scaled_cycleday, 
                   E2zd), # Use the 'E2zd' variable for the y-axis.
               # The 'origin' argument defines the baseline for splitting positive/negative values.
               origin = 'midpoint',  # Split the plot at the midpoint between positive and negative values.
               
               # 'horizonscale' defines how many layers (shades) the plot will have to represent different ranges.
               horizonscale = 7) +  # Use 4 levels of shading.
  
  # Add a color scale using the HCL color palette ('BluGrn').
  # 'reverse = T' reverses the color scheme so that lower values have darker colors and higher values are lighter.
  
  scale_fill_hcl(palette = 'Heat', reverse = T) + 
  
  
  # Create a faceted plot with individual panels for each 'id' (participant ID) along the y-axis.
  # '~.' specifies that there's only faceting on the y-axis (id~.). Each ID will get its own horizontal plot.
  facet_grid(id~.) +
  
  # Apply the 'theme_few' theme for a clean, minimal look.
  theme_few() +
  
  # Customize the theme further:
  theme(
    # Set the vertical spacing between panels to zero lines.
    panel.spacing.y = unit(0, "lines"),
    
    # Customize the text of the facet strips (which show the participant IDs).
    # Size is set to 7, text is horizontal (angle = 0), and aligned to the left (hjust = 0).
    strip.text.y = element_text(size = 6, angle = 0, hjust = 0),
    
    # Remove the legend from the plot.
    legend.position = 'right',
    
    # Remove the y-axis labels (numbers/text), the y-axis title, and the y-axis ticks.
    axis.text.y = element_blank(),  # No y-axis text.
    axis.title.y = element_blank(),  # No y-axis title.
    axis.ticks.y = element_blank(),  # No ticks on the y-axis.
    
    # Remove the border around each panel.
    panel.border = element_blank()
  ) +
  
  # Optionally, you could uncomment the line below if you want to format the x-axis to display date labels.
  # Here, 'scale_x_date' expands the x-axis to avoid clipping at the ends and sets a date format with daily breaks.
  # scale_x_date(expand=c(0,0), date_breaks = "1 da", date_labels = "%b") +
  
  # Add a title to the plot.
  ggtitle('Person-Std E2 Across (Ov to Ov) Cycle by ID') +
  
  # Add a label to the x-axis.
  xlab('Scaled Cycleday (Menses at 0)')

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-17/E2_horizon_plot_ov-ov.png", 
       plot = horiz_plot, 
       width = 8, 
       height = 6)

```

```{r}
# Function to create horizon plots for a list of outcomes (menses to menses cycle)
horizon_plot_menses_to_menses_list <- function(df, outcomes, filename_prefix) {
  # Loop through each outcome in the list of outcomes
  for (outcome in outcomes) {
    # Create the standardized outcome variable name (e.g., 'E2' -> 'E2.zd')
    outcome.zd <- paste0(outcome, '.zd')
    # Create the filename for saving the plot
    filename <- paste0(filename_prefix, outcome, '_horizon_plot_mens-mens.png')
    
    # Generate the plot
    plot <- df %>%  
      ggplot() +
      # Create a horizon plot for the given outcome
      geom_horizon(aes(scaled_cycleday_ov, .data[[outcome.zd]]),
                   origin = 'midpoint',  # Set the baseline at the midpoint
                   horizonscale = 7) +  # Set the number of shading levels
      # Set the color scale using the HCL 'Heat' palette
      scale_fill_hcl(palette = 'Heat', reverse = TRUE) + 
      # Facet by participant ID to create individual panels for each participant
      facet_grid(id~.) +
      # Use a minimal theme for the plot
      theme_few() +
      # Customize the theme further
      theme(
        panel.spacing.y = unit(0, "lines"),  # Remove vertical spacing between panels
        strip.text.y = element_text(size = 6, angle = 0, hjust = 0),  # Customize facet strip text
        legend.position = 'right',  # Place the legend on the right side
        axis.text.y = element_blank(),  # Remove y-axis text
        axis.title.y = element_blank(),  # Remove y-axis title
        axis.ticks.y = element_blank(),  # Remove y-axis ticks
        panel.border = element_blank()  # Remove panel borders
      ) +
      # Add a title to the plot
      ggtitle(paste('Person-Std', outcome, 'Across (Menses to Menses) Cycle by ID')) +
      # Add a label to the x-axis
      xlab('Scaled Cycleday (Ovulation at 0)')
    
    # Save the plot to the specified filename (using the old file path)
    ggsave(filename = filename, plot = plot, width = 8, height = 6)
  }
}

# Function to create horizon plots for a list of outcomes (ovulation to ovulation cycle)
horizon_plot_ovulation_to_ovulation_list <- function(df, outcomes, filename_prefix) {
  # Loop through each outcome in the list of outcomes
  for (outcome in outcomes) {
    # Create the standardized outcome variable name (e.g., 'E2' -> 'E2.zd')
    outcome.zd <- paste0(outcome, '.zd')
    # Create the filename for saving the plot
    filename <- paste0(filename_prefix, outcome, '_horizon_plot_ov-ov.png')
    
    # Generate the plot
    plot <- df %>%  
      ggplot() +
      # Create a horizon plot for the given outcome
      geom_horizon(aes(scaled_cycleday, .data[[outcome.zd]]),
                   origin = 'midpoint',  # Set the baseline at the midpoint
                   horizonscale = 7) +  # Set the number of shading levels
      # Set the color scale using the HCL 'Heat' palette
      scale_fill_hcl(palette = 'Heat', reverse = TRUE) + 
      # Facet by participant ID to create individual panels for each participant
      facet_grid(id~.) +
      # Use a minimal theme for the plot
      theme_few() +
      # Customize the theme further
      theme(
        panel.spacing.y = unit(0, "lines"),  # Remove vertical spacing between panels
        strip.text.y = element_text(size = 6, angle = 0, hjust = 0),  # Customize facet strip text
        legend.position = 'right',  # Place the legend on the right side
        axis.text.y = element_blank(),  # Remove y-axis text
        axis.title.y = element_blank(),  # Remove y-axis title
        axis.ticks.y = element_blank(),  # Remove y-axis ticks
        panel.border = element_blank()  # Remove panel borders
      ) +
      # Add a title to the plot
      ggtitle(paste('Person-Std', outcome, 'Across (Ov to Ov) Cycle by ID')) +
      # Add a label to the x-axis
      xlab('Scaled Cycleday (Menses at 0)')
    
    # Save the plot to the specified filename (using the old file path)
    ggsave(filename = filename, plot = plot, width = 8, height = 6)
  }
}

outcomelist <- c(
  "DRSP_1", "DRSP_2", "DRSP_3", "DRSP_4", "DRSP_5", "DRSP_6", "DRSP_7", "DRSP_8", "DRSP_9", 
  "DRSP_10", "DRSP_11", "DRSP_12", "DRSP_13", "DRSP_14", "DRSP_15", "DRSP_16", "DRSP_17", 
  "DRSP_18", "DRSP_19", "DRSP_20", "DRSP_21", "DRSP_22", "DRSP_23", 
  "UPPS_NU_avg", "UPPS_Persev_avg", "UPPS_Premed_avg", "UPPS_Sens_avg", "UPPS_PU_avg", 
  "CSS_Fx_Total", "CSS_Inatt", "CSS_HypImp", "CSS_Inatt_Count", "CSS_HypImp_Count", 
  "score_pinball", "score_robot", "BDEFS_Total", "BDEFS_WM_avg", "BDEFS_RI_avg", 
  "UPPS_Total", "DEBQ_Total"
)

horizon_plot_menses_to_menses_list(df, outcomelist, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-17/")

horizon_plot_ovulation_to_ovulation_list(df, outcomelist, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-17/")

```



# 2024-09-25 - PLOTS - LUTEAL then FOLLICULAR - (OVULATION to OVULATION)
```{r}

# Define the function to generate plots for a list of DVs
plot_DVs <- function(DV_list, df) {
  
  # Create person-standardized (z-scored within each participant) versions of each DV
  for (DV in DV_list) {
    zd_var <- paste0(DV, ".zd")  # Name for the person-standardized version
    
    # Add the person-standardized columns for each DV
    df <- df %>%
      group_by(id) %>%
      mutate(!!zd_var := scale(!!sym(DV), center = TRUE, scale = TRUE)) %>%
      ungroup()
  }
  
  # Calculate person-rescaled E2 and P4 (scaled within each person, sd = 0.5)
  df <- df %>%
    group_by(id) %>%
    mutate(E2.rescale = scale(E2, center = TRUE, scale = sd(E2, na.rm=TRUE)/0.5), #changed here
           P4.rescale = scale(P4, center = TRUE, scale = sd(P4, na.rm=TRUE)/0.5)) %>% #changed here
    ungroup()
  
  # Indicators for menstrual bleeding
  bleeding_indicator <- data.frame(xmin = .5, xmax = 0.7, ymin = -Inf, ymax = Inf)
  
  for (DV in DV_list) {
    
    if (DV %in% c("E2", "P4", "LH")) {
      # Raw plot for E2, P4, LH
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p1 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.1) +
        geom_point(size = 1) +
        geom_line(size = 1) +
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      ggsave(filename = paste0(output_folder, "/", DV, "_", "raw", ".png"), plot = last_plot(), width = 8, height = 6)

      
    } else {
      # For DVs that are NOT E2, P4, LH
      
      # Raw data points and line for the dependent variable
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
    # Person-rescaled E2 and P4 lines (thin dotted)  <- Changed variable names here
      e2_std <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(E2.rescale, na.rm = TRUE)) #changed here

      p4_std <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(P4.rescale, na.rm = TRUE))  #changed here
      
      p1 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # Thin dotted lines for E2 and P4
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      # Deviations plot
      dev_var <- paste0(DV, ".d")
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p2 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p2)
      
            ggsave(filename = paste0(output_folder, "/", DV, "_", "dev", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Person-standardized outcome (zd)
      zd_var <- paste0(DV, ".zd")
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(zd_var), na.rm = TRUE),
                  se_value = sd(!!sym(zd_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p3 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
                  linetype = "solid", color = "forestgreen", size = 1, alpha = 0.9) +  # E2
        geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
                  linetype = "solid", color = "red", size = 1, alpha = 0.8) +  # P4
        ggtitle(paste("Person-standardized", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Person-standardized Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p3)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "zd", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Rolling deviations plot
      roll_dev_var <- paste0(DV, ".roll.d")
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(roll_dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(roll_dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p4 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Rolling Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Rolling Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p4)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "rolld", ".png"), plot = last_plot(), width = 8, height = 6)

    }
  }
}

# Define the folder location for saving the plots
output_folder <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03"


plot_DVs(outcomelist, df)





```

# 2024-09-25 - PLOTS - FOLLICULAR then LUTEAL - (MENSES to MENSES)

```{r warning=TRUE}

# Load necessary libraries
library(dplyr)   # Data manipulation
library(ggplot2) # Plotting
library(rlang)   # Symbolic programming utilities
library(here)    # Constructing file paths

# Define the function to generate plots for a list of DVs
# Args:
#   dv_list: A named vector of dependent variables (DVs) to be plotted.
#   df: A data frame containing the data for analysis and plotting.
#   output_folder: The folder path where the generated plots should be saved.
plot_DVs_M2M <- function(dv_list, df, output_folder) {
  
  # Create person-standardized (z-scored within each participant) versions of each DV
  for (DV in dv_list) {
    zd_var <- paste0(DV, ".zd")  # Name for the person-standardized version
    
    # Add the person-standardized columns for each DV
    df <- df %>%
      group_by(id) %>%
      mutate(!!zd_var := scale(!!sym(DV), center = TRUE, scale = TRUE)) %>%
      ungroup()
  }
  
  # Calculate person-rescaled E2 and P4 (scaled within each person, sd = 0.5)
  # This transformation helps in visual comparison by keeping the SD consistent across participants
  df <- df %>%
    group_by(id) %>%
    mutate(E2.rescale = scale(E2, center = TRUE, scale = (sd(E2, na.rm = TRUE)*1.75)),
           P4.rescale = scale(P4, center = TRUE, scale = (sd(P4, na.rm = TRUE)*1.75))) %>%
    ungroup()
  
  # Indicators for menstrual bleeding (static values for highlighting cycle day range)
  bleeding_indicator <- data.frame(xmin = 0, xmax = 0.2, ymin = -Inf, ymax = Inf)
  
  # Loop through each DV to generate plots
  for (DV in dv_list) {
    # Get the label for the DV from dv_list
    DV_label <- names(dv_list)[which(dv_list == DV)]
    
    # Calculate mean and standard error for the raw dependent variable
    dv <- df %>%
      group_by(cycledayov_10perc) %>%
      summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
    
    # Calculate mean and standard error for the person-z-scored outcome (zd)
    zd_var <- paste0(DV, ".zd")
    dv_zd <- df %>%
      group_by(cycledayov_10perc) %>%
      summarise(mean_value = mean(!!sym(zd_var), na.rm = TRUE),
                se_value = sd(!!sym(zd_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
    
    # Generate plot for the person-standardized outcome (zd)
p3 <- ggplot(dv_zd, aes(x = cycledayov_10perc, y = mean_value)) +
  # Plotting the mean values for the person-standardized outcome with LOESS smoothing
  geom_smooth(method = "loess", span = .7, size = 1.5, se = FALSE, color = "black") +  # Use geom_smooth for the main DV with CI
  # Plotting the rescaled E2 and P4 values with LOESS smoothing
  geom_smooth(data = df, aes(x = cycledayov_10perc, y = E2.rescale, color = "E2"), method = "loess", span = 0.5, 
              linetype = "dashed", size = 1, alpha = 0.9, se = FALSE) +
  geom_smooth(data = df, aes(x = cycledayov_10perc, y = P4.rescale, color = "P4"), method = "loess", span = 0.5, 
              linetype = "dashed", size = 1, alpha = 0.8, se = FALSE) +
  # Manual color settings for different lines in the plot
  scale_color_manual(values = c("E2" = "forestgreen", "P4" = "red")) +
  # Set axis labels and plot title
  xlab("Cycle Day (10% bins)") + ylab(paste("Smoothed Person-Z-Scored", DV_label)) +
  # Apply minimal theme for cleaner look
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.margin = margin(15, 5, 50, 5),
        legend.title = element_blank(),
        legend.position = "right") +
  coord_cartesian(clip = "off") +
  ggtitle(label=DV_label)+
  # Highlight menstrual bleeding days with a red rectangle
  geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), 
            fill = "red", alpha = 0.2, inherit.aes = FALSE)

# Print the plot to the graphics device
print(p3)
    
    # Save the plot to the specified output folder
    ggsave(filename = file.path(output_folder, paste0(DV, "_", "ov_zd_noSE", ".png")), plot = p3, width = 8, height = 6)
  }
}

# Rename the variables based on DRSP items
# This creates a named vector to assign meaningful labels to each variable for better interpretation in the plots
names(dv_list) <- c(
  "Depressed Mood", # DRSP_1
  "Hopelessness", # DRSP_2
  "Worthlessness/Guilt", # DRSP_3
  "Anxiety/Tension", # DRSP_4
  "Mood Swings", # DRSP_5
  "Rejection Sensitivity", # DRSP_6
  "Anger/Irritability", # DRSP_7
  "Interpersonal Conflict", # DRSP_8
  "Less Interest", # DRSP_9
  "Difficulty Concentrating", # DRSP_10
  "Lethargy/Fatigue", # DRSP_11
  "Incr Appetite/Overate", # DRSP_12
  "Food Cravings", # DRSP_13
  "Hypersomnia", # DRSP_14
  "Insomnia", # DRSP_15
  "Overwhelm/Can't Cope", # DRSP_16
  "Out of Control", # DRSP_17
  "Breast Tenderness", # DRSP_18
  "Swelling/Bloat/Wt Gain", # DRSP_19
  "Joint/Muscle Pain", # DRSP_20
  "Headache", # DRSP_21
  "Work/School Imp", 
  "Relational Imp",
  "Inattention Sx", 
  "Hyperactivity/Imp Sx", 
  "Pinball Score",
  "Robot Score",
  "BDEFS Total",
  "BDEFS Working Memory",
  "BDEFS Resp Inhibition",
  "Negative Urgency",
  "Positive Urgency",
  "Lack of Premeditation",
  "Lack of Perseverance",
  "Sensation Seeking",
  "DEBQ Total",
  "Inattention Sx Count",
  "Hyperactivity Sx Count",
  "Impulsivity Sx Count",
  "Hyp/Imp Sx Count"
)

# Define the folder location for saving the plots
# Define the folder location for saving the plots
output_folder <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-10"

# Call the function with the dataframe and output folder
plot_DVs_M2M(dv_list, df, output_folder)

```





# FITTING GAMMs 

# run_gamm_for_outcome(): This function runs a GAMM model for scaled_cycleday for a given outcome variable--  
# it logs the outcome, fits the model, performs hierarchical partitioning, 
# and saves both the model summary and partitioning output to a file.

```{r}

# Function to run GAMM for each outcome and save results
run_gamm_for_outcome <- function(outcome_var, df, output_dir) {
  # Step 1: Log-transform the outcome variable
  # The log transformation helps stabilize variance and normalize the data
  df[[paste0(outcome_var, "log")]] <- log(df[[outcome_var]] + 1)
  
  # Step 2: Fit a GAMM model
  # The model is fit using the log-transformed outcome variable.
  # The formula specifies random effects (bs = 're') for 'id' and 'scaled_cycleday',
  # and a smooth function (s) to capture the non-linear effect of scaled_cycleday.
  gamm_model <- gam(
    as.formula(paste0(outcome_var, "log ~ s(id, bs = 're') + s(scaled_cycleday, id, bs = 're') + s(scaled_cycleday, k = 20)")),
    data = df,
    method = "REML"  # REML (Restricted Maximum Likelihood) is used for model fitting
  )
  
  # Step 3: Output the model summary
  # The summary provides detailed information about the model fit,
  # including the significance of terms, smooth terms, and model diagnostics.
  model_summary <- summary(gamm_model)
  print(model_summary)
  
  # Step 4: Perform hierarchical partitioning
  # Hierarchical partitioning calculates the relative contribution of each predictor to the model fit.
  var_part <- gam.hp::gam.hp(gamm_model)
  print(var_part$hierarchical.partitioning)
  
  # Step 5: Capture the output for both model summary and hierarchical partitioning
  # The capture.output function stores the printed output in a character vector
  # that can be written to a file.
  summary_output <- capture.output(model_summary)
  partitioning_output <- capture.output(var_part$hierarchical.partitioning)
  
  # Step 6: Combine the model summary and hierarchical partitioning results
  # Here, both outputs are combined into a single object to be saved together.
  combined_output <- c(summary_output, "", "Hierarchical Partitioning:", partitioning_output)
  
  # Step 7: Define the output file path
  # The output file is saved with a name corresponding to the outcome variable.
  summary_file_path <- file.path(output_dir, paste0(outcome_var, "model.txt"))
  
  # Step 8: Save the combined output to a text file
  # This writes the model summary and hierarchical partitioning into the text file.
  writeLines(combined_output, summary_file_path)
  cat("Model summary and hierarchical partitioning saved to:", summary_file_path, "\n")
  
  # Step 9: Plot the GAMM model results
  # The plot shows the smooth term for 'scaled_cycleday' and its relationship with the outcome.
  # Select = 3 means we're selecting the smooth term corresponding to scaled_cycleday.
  plot.gam(gamm_model, select = 3)
  
  # Return the model object for further analysis if needed
  return(gamm_model)
}

# Example Usage:
# dv_list is a list of dependent variables (outcomes) for which the model will be run.
# These variables should be present in the dataset (df).
test_list <- c("E2", "P4")  # Replace with actual outcome names

# Define the directory where the output files will be saved
# This should be an existing directory on your system.
output_directory <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-17/"

# Step 10: Apply the function to each outcome in the list
# This will run the GAMM model for each outcome and save the results.
lapply(test_list, run_gamm_for_outcome, df = df, output_dir = output_directory)

```









# GAMM and initial plot - E2 - Ov to Ov
```{r}

hist(df$E2)
df$E2log <- log(df$E2+1)
hist(df$E2log)

gamm_E2 <- gam(E2log ~ s(id, bs = "re") + 
                 s(scaled_cycleday, id, bs = "re") + 
                 s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_E2)


# Save the model summary as a text file
summary_output <- capture.output(summary(gamm_E2))
summary_file_path <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-17/E2model.txt"
writeLines(summary_output, summary_file_path)
cat("Model summary saved to:", summary_file_path, "\n")

var.part = gam.hp::gam.hp(gamm_E2)
var.part$hierarchical.partitioning

plot.gam(gamm_e2, select = 3)

```



# Model-Implied Plot - E2 - Ov to Ov
```{r}

e2dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_e2, newdata = e2dat, type = "response", transform = function(x) exp(x) - 1)

#don't need to include anything for 'transform' if your outcome is not log-transformed. This undoes the logtransform so model-implied values are not on the log scale 

e2dat$estimate = pred$estimate
e2dat$conf.low = pred$conf.low
e2dat$conf.high = pred$conf.high

# Plotting
e2plot <- ggplot(e2dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Salivary Estradiol") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

e2plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/E2.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)

```


# Load required libraries
library(VennDiagram)
library(ggplot2)
library(gam.hp)

# GAMM and initial plot - LH
```{r}
hist(df$LH) # Check the distribution of the LH variable
df$LHlog <- log(df$LH+1) # Log-transform the LH variable
hist(df$LHlog) # Check the distribution of the log-transformed LH variable



# Fit the model and save the summary
gamm_LH <- gam(LHlog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re") + s(scaled_cycleday, k = 20), data = df, method = "REML")
summary_output <- capture.output(summary(gamm_LH))
summary_file_path <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/LHmodel.txt"
writeLines(summary_output, summary_file_path)
cat("Model summary saved to:", summary_file_path, "\n")

# Perform variance partitioning and extract data
var.part <- gam.hp::gam.hp(gamm_LH)
var_partition_data <- as.data.frame(var.part$hierarchical.partitioning)
data <- data.frame(Term = rownames(var_partition_data), I_perc = var_partition_data[, "I.perc(%)"])

# Create a bar plot using ggplot
ggplot(data, aes(x = Term, y = I_perc, fill = Term)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Percentage Contribution of Terms", x = "Term", y = "I.perc (%)") +
  theme_minimal() +
  theme(legend.position = "none")

# Extract variance contributions and overlaps for Venn diagram
venn_data <- setNames(as.list(var_partition_data[, "I.perc(%)"]), rownames(var_partition_data))
n12 <- var_partition_data[grep("s\(id, bs = \"re\"\)", rownames(var_partition_data)), "Average.share"]
n13 <- var_partition_data[grep("s\(scaled_cycleday, k = 20\)", rownames(var_partition_data)), "Average.share"]
n23 <- var_partition_data[grep("s\(scaled_cycleday, id, bs = \"re\"\)", rownames(var_partition_data)), "Average.share"]
n123 <- min(n12, n13, n23)

# Create and save the Venn diagram
png(filename = "variance_partitioning_venn.png", width = 800, height = 600)
draw.triple.venn(
  area1 = venn_data[[1]],
  area2 = venn_data[[2]],
  area3 = venn_data[[3]],
  n12 = n12,
  n13 = n13,
  n23 = n23,
  n123 = n123,
  category = names(venn_data),
  fill = c("red", "blue", "green"),
  lty = "blank",
  cex = 1.5,
  cat.cex = 1.5,
  main = "Variance Partitioning Venn Diagram"
)
dev.off()

# Display the Venn diagram in the RStudio viewer
grid::grid.newpage()
draw.triple.venn(
  area1 = venn_data[[1]],
  area2 = venn_data[[2]],
  area3 = venn_data[[3]],
  n12 = n12,
  n13 = n13,
  n23 = n23,
  n123 = n123,
  category = names(venn_data),
  fill = c("red", "blue", "green"),
  lty = "blank",
  cex = 1.5,
  cat.cex = 1.5,
  main = "Variance Partitioning Venn Diagram"
)



```


# Model-Implied Plot - LH
```{r}

LHdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_LH, newdata = LHdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

LHdat$estimate = pred$estimate
LHdat$conf.low = pred$conf.low
LHdat$conf.high = pred$conf.high

# Plotting
LHplot <- ggplot(LHdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "LH") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

LHplot


ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/LH.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)

```


# GAMM and initial plot - P4
```{r}
hist(df$P4)
df$P4log <- log(df$P4+1)
hist(df$P4log)

gamm_P4 <- gam(P4log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 10), data = df, method = "REML")

summary(gamm_P4)


# Save the model summary as a text file
summary_output <- capture.output(summary(gamm_P4))
summary_file_path <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/gamm_P4.txt"
writeLines(summary_output, summary_file_path)
cat("Model summary saved to:", summary_file_path, "\n")

plot.gam(gamm_P4, select = 3)

```

# Model-Implied Plot - P4
```{r}

P4dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_P4, newdata = P4dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

P4dat$estimate = pred$estimate
P4dat$conf.low = pred$conf.low
P4dat$conf.high = pred$conf.high


# Plotting
P4plot <- ggplot(P4dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Salivary P4") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

P4plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/P4.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)

```









```{r}

# Function to run the GAMM and generate plots for a given outcome variable
gamm_model_loop <- function(outcome, df, output_path, plot_path) {
  
  # Step 1: Create a histogram for the outcome variable to check its distribution
  hist(df[[outcome]], main = paste("Histogram of", outcome), xlab = outcome)
  
  # Step 2: Log-transform the outcome variable to deal with skewness
  # Add 1 to avoid log(0) issues, which is undefined
  log_outcome <- paste0(outcome, "log")  # Create a name for the log-transformed variable
  df[[log_outcome]] <- log(df[[outcome]] + 1)  # Apply log transformation and store in a new column
  hist(df[[log_outcome]], main = paste("Histogram of Log-Transformed", outcome), xlab = log_outcome)  # Create a histogram for the transformed data
  
  # Step 3: Fit a Generalized Additive Mixed Model (GAMM)
  # The formula includes smooth terms for the id (random effect) and scaled_cycleday
  gamm_model <- gam(as.formula(paste0(log_outcome, " ~ s(id, bs = 're') + s(scaled_cycleday, id, bs = 're') + s(scaled_cycleday, k = 30)")),
                    data = df, method = "REML")  # REML method is recommended for smoother estimation
  
  # Step 4: Display the summary of the model
 summary(gamm_model)
  
  
  # Step 5: Save the model summary to a text file
  summary_output <- capture.output(summary(gamm_model))  # Capture the summary output as a character vector
  summary_file_path <- file.path(output_path, paste0("gamm_", outcome, ".txt"))  # Define the path to save the summary
  writeLines(summary_output, summary_file_path)  # Write the summary to the file
  cat("Model summary saved to:", summary_file_path, "\n")  # Print confirmation
  
  # Step 6: Create a dataset for making predictions from the model
  # We create a grid of values for scaled_cycleday ranging from -1 to 1
  pred_data <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),  # Values of scaled_cycleday for prediction
                           id = 0)  # We use id = 0 (population-level prediction)
  
  # Step 7: Make predictions using the `marginaleffects` package and undo the log transformation
  pred <- predictions(gamm_model, newdata = pred_data, type = "response", transform = function(x) exp(x) - 1)  # Use predictions function
  pred_data$estimate <- pred$estimate  # Store the predicted estimates
  pred_data$conf.low <- pred$conf.low  # Store the lower bound of the 95% confidence interval
  pred_data$conf.high <- pred$conf.high  # Store the upper bound of the 95% confidence interval
  
  # Step 8: Plot the predicted values and confidence intervals
  outcome_plot <- ggplot(pred_data, aes(x = scaled_cycleday, y = estimate)) +
    scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), 
                       labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +  # Custom labels for x-axis
    labs(x = "Cycle Day (Scaled)", y = outcome) +  # Labels for axes
    geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
              fill = "grey70", alpha = 0.2, color = "white") +  # Highlight the menses onset period
    geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
              fill = "grey87", alpha = 0.2, color = "white") +  # Highlight the ovulation period
    geom_line(size = 1, show.legend = TRUE) +  # Line plot for the estimated values
    theme_minimal()  # Use a minimal theme for cleaner visualization
  
  # Display the plot
  print(outcome_plot)
  
  # Step 9: Save the plot to a file
  plot_file_path <- file.path(plot_path, paste0(outcome, "_k30.png"))  # Define the path for saving the plot
  ggsave(filename = plot_file_path, plot = outcome_plot, width = 8, height = 6)  # Save the plot as a PNG file
  cat("Plot saved to:", plot_file_path, "\n")  # Print confirmation
}

# Define paths for saving outputs (modify as per your folder structure)
output_path <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/"
plot_path <- file.path(output_path, "GAMMplots_k30")

# List of outcomes to loop through (replace with your actual outcomes)
# already exists as "outcomelist" above

# Loop through each outcome and apply the GAMM function
for (outcome in outcomelist) {
  gamm_model_loop(outcome, df, output_path, plot_path)  # Apply the function to each outcome
}

```




# Trying a version of the loop that merges in E2: 

```{r}


gamm_model_loop <- function(outcome, df, output_path, plot_path) {
  
  # Step 1: Create a histogram for the outcome variable to check its distribution
  hist(df[[outcome]], main = paste("Histogram of", outcome), xlab = outcome)
  
  # Step 2: Log-transform the outcome variable to deal with skewness
  log_outcome <- paste0(outcome, "log")  
  df[[log_outcome]] <- log(df[[outcome]] + 1)  
  hist(df[[log_outcome]], main = paste("Histogram of Log-Transformed", outcome), xlab = log_outcome)
  
  # Step 3: Fit a GAMM
  gamm_model <- gam(as.formula(paste0(log_outcome, " ~ s(id, bs = 're') + s(scaled_cycleday, id, bs = 're') + s(scaled_cycleday, k = 30)")),
                    data = df, method = "REML")
  
  # Step 4: Save the model summary
  summary_output <- summary(gamm_model)
  summary_file_path <- file.path(output_path, paste0("gamm_", outcome, ".txt"))
  writeLines(capture.output(summary_output), summary_file_path)
  
  # Step 4a: Extract p-value and edf for scaled_cycleday
  scaled_cycleday_term <- summary_output$s.table["s(scaled_cycleday)", ]
  p_value <- scaled_cycleday_term["p-value"]
  edf <- scaled_cycleday_term["edf"]

  # Determine significance symbol
  significance <- ""
  if (p_value < 0.001) {
    significance <- "***"
  } else if (p_value < 0.01) {
    significance <- "**"
  } else if (p_value < 0.05) {
    significance <- "*"
  } else if (p_value < 0.15) {
    significance <- ""
  }

 # Step 5: Create a dataset for predictions from the model
pred_data <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1), id = 0)
pred <- predict(gamm_model, newdata = pred_data, type = "response", se.fit = TRUE) # Predict on the link scale

# Calculate confidence intervals on the link scale
pred_data$conf.low <- pred$fit - 1.96 * pred$se.fit 
pred_data$conf.high <- pred$fit + 1.96 * pred$se.fit

# Transform predictions and confidence intervals to the response scale
pred_data$estimate <- exp(pred$fit) - 1
pred_data$conf.low <- exp(pred_data$conf.low) - 1
pred_data$conf.high <- exp(pred_data$conf.high) - 1

# Scale the transformed values  <-- This is the moved line
pred_data$estimate <- scale(pred_data$estimate)
pred_data$conf.low <- scale(pred_data$conf.low)
pred_data$conf.high <- scale(pred_data$conf.high) 

  # Step 6: Plot predicted values and confidence intervals for the outcome and add E2 curve
  outcome_plot <- ggplot(pred_data, aes(x = scaled_cycleday)) +
    scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), 
                       labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
    labs(x = "Cycle Day (Scaled)", y = "Scaled Predicted Values") +
    geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
              fill = "grey70", alpha = 0.2, color = "white") +
    geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
              fill = "grey87", alpha = 0.2, color = "white") +
    
    # Confidence ribbons for the outcome estimates
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "black", alpha = 0.1) +
    
    # Line plot for outcome
    geom_line(aes(y = estimate, color = "outcome"), size = 1, show.legend = TRUE) +  
    
    # Step 6a: Add E2 and P4 curves on top (using e2dat and P4dat)
    geom_line(data = e2dat, aes(x = scaled_cycleday, y = scale(estimate), color = "E2"), size = 1, linetype = "dashed") +  # E2 curve
    geom_line(data = P4dat, aes(x = scaled_cycleday, y = scale(estimate), color = "P4"), size = 1, linetype = "dashed") +  # P4 curve
    
    # Step 6b: Customize legend with desired order
    scale_color_manual(name = "Key", 
                       values = c("outcome" = "black", "E2" = "forestgreen", "P4" = "red"),
                       labels = c("outcome" = outcome, "E2" = "E2", "P4" = "P4"),
                       breaks = c("outcome", "E2", "P4")) +  # Ensure correct legend order
    
    theme_minimal() +
    theme(legend.position = "right")

  # Create a label for EDF and p-value, and add it below the legend
  annotation_text <- paste("EDF:", round(edf, 2), significance)
  annotated_plot <- ggdraw(outcome_plot) +
    draw_label(annotation_text, x = 0.85, y = 0.2, hjust = 0, size = 10, fontface = "bold")

  # Display the plot with annotation
  print(annotated_plot)

  # Step 7: Save the plot to a file
  plot_file_path <- file.path(plot_path, paste0(outcome, "_with_horm.png"))
  ggsave(filename = plot_file_path, plot = annotated_plot, width = 8, height = 6)
  cat("Plot with Hormone overlays saved to:", plot_file_path, "\n")
}

# Define paths for saving outputs (modify as per your folder structure)
output_path <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-10/"
plot_path <- file.path(output_path, "Plots with Hormone Overlays")

# List of outcomes to loop through (replace with your actual outcomes)
outcomelist_test <- c("CSS_Inatt")

outcomelist <- c("CSS_Inatt", "CSS_HypImp", "score_pinball", "score_robot", "UPPS_NU_avg", "UPPS_Persev_avg", "UPPS_Premed_avg", "UPPS_Sens_avg", "UPPS_PU_avg", 
  "CSS_Fx_Total",  "CSS_Inatt_Count", "CSS_HypImp_Count", "BDEFS_WM_avg", "BDEFS_RI_avg", "DEBQ_Total", "DRSP_1", "DRSP_7")

# Loop through each outcome and apply the GAMM function
for (outcome in outcomelist) {
  gamm_model_loop(outcome, df, output_path, plot_path)  # Apply the function to each outcome
}

```


Alt Patchwork Code
```{r}

  library(patchwork)

# Create separate plots for Outcome, E2, and P4
outcome_plot <- ggplot(pred_data, aes(x = scaled_cycleday, y = estimate)) +
  geom_line(size = 1, color = "blue") +
  labs(x = "Cycle Day (Scaled)", y = outcome) +
  theme_minimal()

e2_plot <- ggplot(e2dat, aes(x = scaled_cycleday, y = estimate)) +
  geom_line(size = 1, color = "forestgreen", linetype = "dashed") +
  labs(x = "Cycle Day (Scaled)", y = "E2") +
  theme_minimal()

p4_plot <- ggplot(P4dat, aes(x = scaled_cycleday, y = estimate)) +
  geom_line(size = 1, color = "red", linetype = "dashed") +
  labs(x = "Cycle Day (Scaled)", y = "P4") +
  theme_minimal()

# Arrange all three plots in a single view
combined_plot <- outcome_plot / e2_plot / p4_plot
print(combined_plot)
```




# GAMM and initial plot - DRSP_1 - MS F, NS R
```{r}
hist(df$DRSP_1)
df$DRSP_1log <- log(df$DRSP_1+1)
hist(df$DRSP_1log)
gamm_DRSP_1 <- gam(DRSP_1log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_1)

plot.gam(gamm_DRSP_1, select = 3)

hist(df$DRSP_1)
```


# Model-Implied Plot - DRSP_1
```{r}

DRSP_1dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_1, newdata = DRSP_1dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_1dat$estimate = pred$estimate
DRSP_1dat$conf.low = pred$conf.low
DRSP_1dat$conf.high = pred$conf.high

# Plotting
DRSP_1plot <- ggplot(DRSP_1dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Depressed Mood") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_1plot


ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/depblue.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_2 - MS F, NS R
```{r}
hist(df$DRSP_2)
df$DRSP_2log <- log(df$DRSP_2+1)
hist(df$DRSP_2log)
gamm_DRSP_2 <- gam(DRSP_2log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_2)

plot.gam(gamm_DRSP_2, select = 3)

hist(df$DRSP_2)
```


# Model-Implied Plot - DRSP2
```{r}

DRSP_2dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_2, newdata = DRSP_2dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_2dat$estimate = pred$estimate
DRSP_2dat$conf.low = pred$conf.low
DRSP_2dat$conf.high = pred$conf.high

# Plotting
DRSP_2plot <- ggplot(DRSP_2dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Hopelessness") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_2plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/hopeless.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```

# GAMM and initial plot - DRSP_3 - NS F, NS R
```{r}
hist(df$DRSP_3)
df$DRSP_3log <- log(df$DRSP_3+1)
hist(df$DRSP_3log)
gamm_DRSP_3 <- gam(DRSP_3log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_3)

plot.gam(gamm_DRSP_3, select = 3)

hist(df$DRSP_3)
```


# Model-Implied Plot - DRSP_3
```{r}

DRSP_3dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_3, newdata = DRSP_3dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_3dat$estimate = pred$estimate
DRSP_3dat$conf.low = pred$conf.low
DRSP_3dat$conf.high = pred$conf.high

# Plotting
DRSP_3plot <- ggplot(DRSP_3dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Worthlessness & Guilt") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_3plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/worthguilt.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_4 - MS F, SIG R
```{r}
hist(df$DRSP_4)
df$DRSP_4log <- log(df$DRSP_4+1)
hist(df$DRSP_4log)
gamm_DRSP_4 <- gam(DRSP_4log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_4)

plot.gam(gamm_DRSP_4, select = 3)

hist(df$DRSP_4)
```


# Model-Implied Plot - DRSP_4
```{r}

DRSP_4dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_4, newdata = DRSP_4dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_4dat$estimate = pred$estimate
DRSP_4dat$conf.low = pred$conf.low
DRSP_4dat$conf.high = pred$conf.high

# Plotting
DRSP_4plot <- ggplot(DRSP_4dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Anxiety & Tension") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_4plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/anxiety.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_5 - SIG F, SIG R
```{r}
hist(df$DRSP_5)
df$DRSP_5log <- log(df$DRSP_5+1)
hist(df$DRSP_5log)
gamm_DRSP_5 <- gam(DRSP_5log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_5)

plot.gam(gamm_DRSP_5, select = 3)

hist(df$DRSP_5)
```


# Model-Implied Plot - DRSP_5
```{r}

DRSP_5dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_5, newdata = DRSP_5dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_5dat$estimate = pred$estimate
DRSP_5dat$conf.low = pred$conf.low
DRSP_5dat$conf.high = pred$conf.high

# Plotting
DRSP_5plot <- ggplot(DRSP_5dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Mood Swings") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_5plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/moodswings.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_6 - NS F, MS R
```{r}
hist(df$DRSP_6)
df$DRSP_6log <- log(df$DRSP_6+1)
hist(df$DRSP_6log)
gamm_DRSP_6 <- gam(DRSP_6log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_6)

plot.gam(gamm_DRSP_6, select = 3)

hist(df$DRSP_6)
```


# Model-Implied Plot - DRSP_6
```{r}

DRSP_6dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_6, newdata = DRSP_6dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_6dat$estimate = pred$estimate
DRSP_6dat$conf.low = pred$conf.low
DRSP_6dat$conf.high = pred$conf.high

# Plotting
DRSP_6plot <- ggplot(DRSP_6dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Rejection Sensitivity") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_6plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/rejsens.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```



# GAMM and initial plot - DRSP_7 - SIG F, NS R
```{r}
hist(df$DRSP_7)
df$DRSP_7log <- log(df$DRSP_7+1)
hist(df$DRSP_7log)
gamm_DRSP_7 <- gam(DRSP_7log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_7)

plot.gam(gamm_DRSP_7, select = 3)

hist(df$DRSP_7)
```


# Model-Implied Plot - DRSP_7
```{r}

DRSP_7dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_7, newdata = DRSP_7dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_7dat$estimate = pred$estimate
DRSP_7dat$conf.low = pred$conf.low
DRSP_7dat$conf.high = pred$conf.high

# Plotting
DRSP_7plot <- ggplot(DRSP_7dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Anger or Irritability") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_7plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/angirr.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_8 - NS F, NS R
```{r}
hist(df$DRSP_8)
df$DRSP_8log <- log(df$DRSP_8+1)
hist(df$DRSP_8log)
gamm_DRSP_8 <- gam(DRSP_8log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_8)

plot.gam(gamm_DRSP_8, select = 3)

hist(df$DRSP_8)
```


# Model-Implied Plot - DRSP_8
```{r}

DRSP_8dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_8, newdata = DRSP_8dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_8dat$estimate = pred$estimate
DRSP_8dat$conf.low = pred$conf.low
DRSP_8dat$conf.high = pred$conf.high

# Plotting
DRSP_8plot <- ggplot(DRSP_8dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Interpersonal Conflict") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_8plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/intconf.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```

# GAMM and initial plot - DRSP_9 - Sig F, NS R
```{r}
hist(df$DRSP_9)
df$DRSP_9log <- log(df$DRSP_9+1)
hist(df$DRSP_9log)
gamm_DRSP_9 <- gam(DRSP_9log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_9)

plot.gam(gamm_DRSP_9, select = 3)

hist(df$DRSP_9)
```


# Model-Implied Plot - DRSP_9
```{r}

DRSP_9dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_9, newdata = DRSP_9dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_9dat$estimate = pred$estimate
DRSP_9dat$conf.low = pred$conf.low
DRSP_9dat$conf.high = pred$conf.high

# Plotting
DRSP_9plot <- ggplot(DRSP_9dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Lack of Interest or Motivation") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_9plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/lackintmot.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```

# GAMM and initial plot - DRSP_10 - NS F, NS R
```{r}
hist(df$DRSP_10)
df$DRSP_10log <- log(df$DRSP_10+1)
hist(df$DRSP_10log)
gamm_DRSP_10 <- gam(DRSP_10log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_10)

plot.gam(gamm_DRSP_10, select = 3)

hist(df$DRSP_10)
```


# Model-Implied Plot - DRSP_10
```{r}

DRSP_10dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_10, newdata = DRSP_10dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_10dat$estimate = pred$estimate
DRSP_10dat$conf.low = pred$conf.low
DRSP_10dat$conf.high = pred$conf.high

# Plotting
DRSP_10plot <- ggplot(DRSP_10dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Difficulty Concentrating") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_10plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/diffconc.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```

# GAMM and initial plot - DRSP_11 - MS F, NS R
```{r}
hist(df$DRSP_11)
df$DRSP_11log <- log(df$DRSP_11+1)
hist(df$DRSP_11log)
gamm_DRSP_11 <- gam(DRSP_11log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_11)

plot.gam(gamm_DRSP_11, select = 3)

hist(df$DRSP_11)
```


# Model-Implied Plot - DRSP_11
```{r}

DRSP_11dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_11, newdata = DRSP_11dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_11dat$estimate = pred$estimate
DRSP_11dat$conf.low = pred$conf.low
DRSP_11dat$conf.high = pred$conf.high

# Plotting
DRSP_11plot <- ggplot(DRSP_11dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Lethargy, Fatigue") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_11plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/fatigue.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_12 - SIG F, NS R
```{r}
hist(df$DRSP_12)
df$DRSP_12log <- log(df$DRSP_12+1)
hist(df$DRSP_12log)
gamm_DRSP_12 <- gam(DRSP_12log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_12)

plot.gam(gamm_DRSP_12, select = 3)

hist(df$DRSP_12)
```


# Model-Implied Plot - DRSP_12
```{r}

DRSP_12dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_12, newdata = DRSP_12dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_12dat$estimate = pred$estimate
DRSP_12dat$conf.low = pred$conf.low
DRSP_12dat$conf.high = pred$conf.high

# Plotting
DRSP_12plot <- ggplot(DRSP_12dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Increased Appetite, Overeating") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_12plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/Appoverate.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```

# GAMM and initial plot - DRSP_13 - SIG F, NS R
```{r}
hist(df$DRSP_13)
df$DRSP_13log <- log(df$DRSP_13+1)
hist(df$DRSP_13log)
gamm_DRSP_13 <- gam(DRSP_13log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_13)

plot.gam(gamm_DRSP_13, select = 3)

hist(df$DRSP_13)
```


# Model-Implied Plot - DRSP_13
```{r}

DRSP_13dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_13, newdata = DRSP_13dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_13dat$estimate = pred$estimate
DRSP_13dat$conf.low = pred$conf.low
DRSP_13dat$conf.high = pred$conf.high

# Plotting
DRSP_13plot <- ggplot(DRSP_13dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Food Cravings") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_13plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/foodcrave.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```

# GAMM and initial plot - DRSP_14 - NS F, NS R
```{r}
hist(df$DRSP_14)
df$DRSP_14log <- log(df$DRSP_14+1)
hist(df$DRSP_14log)
gamm_DRSP_14 <- gam(DRSP_14log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_14)

plot.gam(gamm_DRSP_14, select = 3)

hist(df$DRSP_14)
```


# Model-Implied Plot - DRSP_14
```{r}

DRSP_14dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_14, newdata = DRSP_14dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_14dat$estimate = pred$estimate
DRSP_14dat$conf.low = pred$conf.low
DRSP_14dat$conf.high = pred$conf.high

# Plotting
DRSP_14plot <- ggplot(DRSP_14dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Hypersomnia") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_14plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/Hypersomnia.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_15 - NS F, NS R
```{r}
hist(df$DRSP_15)
df$DRSP_15log <- log(df$DRSP_15+1)
hist(df$DRSP_15log)
gamm_DRSP_15 <- gam(DRSP_15log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_15)

plot.gam(gamm_DRSP_15, select = 3)

hist(df$DRSP_15)
```


# Model-Implied Plot - TEMPLATE
```{r}

DRSP_15dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_15, newdata = DRSP_15dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_15dat$estimate = pred$estimate
DRSP_15dat$conf.low = pred$conf.low
DRSP_15dat$conf.high = pred$conf.high

# Plotting
DRSP_15plot <- ggplot(DRSP_15dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Insomnia") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_15plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/Insomnia.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_16 - NS F, NS R
```{r}
hist(df$DRSP_16)
df$DRSP_16log <- log(df$DRSP_16+1)
hist(df$DRSP_16log)
gamm_DRSP_16 <- gam(DRSP_16log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_16)

plot.gam(gamm_DRSP_16, select = 3)

hist(df$DRSP_16)
```


# Model-Implied Plot - DRSP_16
```{r}

DRSP_16dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_16, newdata = DRSP_16dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_16dat$estimate = pred$estimate
DRSP_16dat$conf.low = pred$conf.low
DRSP_16dat$conf.high = pred$conf.high

# Plotting
DRSP_16plot <- ggplot(DRSP_16dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Overwhelmed") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_16plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/overwhelm.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_17 - Sig F, NS R
```{r}
hist(df$DRSP_17)
df$DRSP_17log <- log(df$DRSP_17+1)
hist(df$DRSP_17log)
gamm_DRSP_17 <- gam(DRSP_17log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_17)

plot.gam(gamm_DRSP_17, select = 3)

hist(df$DRSP_17)
```


# Model-Implied Plot - TEMPLATE
```{r}

DRSP_17dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_17, newdata = DRSP_17dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_17dat$estimate = pred$estimate
DRSP_17dat$conf.low = pred$conf.low
DRSP_17dat$conf.high = pred$conf.high

# Plotting
DRSP_17plot <- ggplot(DRSP_17dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Out of Control") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_17plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/OOC.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```



# GAMM and initial plot - DRSP_18 - Sig F, Sig R
```{r}
hist(df$DRSP_18)
df$DRSP_18log <- log(df$DRSP_18+1)
hist(df$DRSP_18log)
gamm_DRSP_18 <- gam(DRSP_18log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_18)

plot.gam(gamm_DRSP_18, select = 3)

hist(df$DRSP_18)
```


# Model-Implied Plot - DRSP_18
```{r}

DRSP_18dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_18, newdata = DRSP_18dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_18dat$estimate = pred$estimate
DRSP_18dat$conf.low = pred$conf.low
DRSP_18dat$conf.high = pred$conf.high

# Plotting
DRSP_18plot <- ggplot(DRSP_18dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Breast Tenderness") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_18plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/Breast Tender.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DRSP_19 - SIG F, NS R
```{r}
hist(df$DRSP_19)
df$DRSP_19log <- log(df$DRSP_19+1)
hist(df$DRSP_19log)
gamm_DRSP_19 <- gam(DRSP_19log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_19)

plot.gam(gamm_DRSP_19, select = 3)

hist(df$DRSP_19)
```


# Model-Implied Plot - DRSP_19
```{r}

DRSP_19dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_19, newdata = DRSP_19dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_19dat$estimate = pred$estimate
DRSP_19dat$conf.low = pred$conf.low
DRSP_19dat$conf.high = pred$conf.high

# Plotting
DRSP_19plot <- ggplot(DRSP_19dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Swelling, Bloating, or Weight Gain") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_19plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/swellbloatgain.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```


# GAMM and initial plot - DSRP_20 - MS F, NS R
```{r}
hist(df$DRSP_20)
df$DRSP_20log <- log(df$DRSP_20+1)
hist(df$DRSP_20log)
gamm_DRSP_20 <- gam(DRSP_20log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_20)

plot.gam(gamm_DRSP_20, select = 3)

hist(df$DRSP_20)
```


# Model-Implied Plot - DSRP_20
```{r}

DRSP_20dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_20, newdata = DRSP_20dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_20dat$estimate = pred$estimate
DRSP_20dat$conf.low = pred$conf.low
DRSP_20dat$conf.high = pred$conf.high

# Plotting
DRSP_20plot <- ggplot(DRSP_20dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Headache") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_20plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/headache.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```




# GAMM and initial plot - DRSP_21 - NS F, NS R
```{r}
hist(df$DRSP_21)
df$DRSP_21log <- log(df$DRSP_21+1)
hist(df$DRSP_21log)
gamm_DRSP_21 <- gam(DRSP_21log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_21)

plot.gam(gamm_DRSP_21, select = 3)

hist(df$DRSP_21)
```


# Model-Implied Plot - DRSP_21
```{r}

DRSP_21dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_21, newdata = DRSP_21dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_21dat$estimate = pred$estimate
DRSP_21dat$conf.low = pred$conf.low
DRSP_21dat$conf.high = pred$conf.high

# Plotting
DRSP_21plot <- ggplot(DRSP_21dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Joint or Muscle Pain") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_21plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/jointmuscpain.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```

# GAMM and initial plot - DRSP_22 - Sig F, NS R
```{r}
hist(df$DRSP_22)
df$DRSP_22log <- log(df$DRSP_22+1)
hist(df$DRSP_22log)
gamm_DRSP_22 <- gam(DRSP_22log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_22)

plot.gam(gamm_DRSP_22, select = 3)

hist(df$DRSP_22)
```


# Model-Implied Plot - DRSP_22
```{r}

DRSP_22dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_22, newdata = DRSP_22dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_22dat$estimate = pred$estimate
DRSP_22dat$conf.low = pred$conf.low
DRSP_22dat$conf.high = pred$conf.high

# Plotting
DRSP_22plot <- ggplot(DRSP_22dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "School or Work Impairment") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_22plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/Workimp.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```



# GAMM and initial plot - DRSP_23 - MS F, NS R
```{r}
hist(df$DRSP_23)
df$DRSP_23log <- log(df$DRSP_23+1)
hist(df$DRSP_23log)
gamm_DRSP_23 <- gam(DRSP_23log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_DRSP_23)

plot.gam(gamm_DRSP_23, select = 3)

hist(df$DRSP_23)
```


# Model-Implied Plot - DRSP_23
```{r}

DRSP_23dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_23, newdata = DRSP_23dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_23dat$estimate = pred$estimate
DRSP_23dat$conf.low = pred$conf.low
DRSP_23dat$conf.high = pred$conf.high

# Plotting
DRSP_23plot <- ggplot(DRSP_23dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Relationship Interference") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_23plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/GAMMplots/relimp.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)
```

# Output all Model Files to Box

```{r}

outcomelist <- c(
  "DRSP_1", "DRSP_2", "DRSP_3", "DRSP_4", "DRSP_5", "DRSP_6", "DRSP_7", "DRSP_8", "DRSP_9", 
  "DRSP_10", "DRSP_11", "DRSP_12", "DRSP_13", "DRSP_14", "DRSP_15", "DRSP_16", "DRSP_17", 
  "DRSP_18", "DRSP_19", "DRSP_20", "DRSP_21", "DRSP_22", "DRSP_23", 
  "UPPS_NU_avg", "UPPS_Persev_avg", "UPPS_Premed_avg", "UPPS_Sens_avg", "UPPS_PU_avg", 
  "CSS_Fx_Total", "CSS_Inatt", "CSS_HypImp", "CSS_Inatt_Count", "CSS_HypImp_Count", 
  "score_pinball", "score_robot", "BDEFS_Total", "BDEFS_WM_avg", "BDEFS_RI_avg", 
  "UPPS_Total", "DEBQ_Total"
)


# Define your list of outcomes
print(outcomelist)

# Function to save summary of GAMM models to a file
save_gamm_summary <- function(outcome) {
  # Dynamically create model variable name
  model_var <- paste0("gamm_", outcome)
  
  # Dynamically create the file path for each outcome
  file_path <- paste0("/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-09-30/GAMMmodels/", outcome, "_gam_model_summary.txt")
  
  # Capture and write the summary to the file
  writeLines(capture.output(summary(get(model_var))), file_path)
}

# Loop over each outcome and save the summary
lapply(outcomelist, save_gamm_summary)

```




##### Reference and template info below


# OUTCOMES

BDEFS_1, BDEFS_2, BDEFS_3, BDEFS_4, BDEFS_5, BDEFS_6, DRSP_1, DRSP_2, DRSP_3, DRSP_4, DRSP_5, DRSP_6, DRSP_7, DRSP_8, DRSP_9, DRSP_10, DRSP_11, DRSP_12, DRSP_13, DRSP_14, DRSP_15, DRSP_16, DRSP_17, DRSP_18, DRSP_19, DRSP_20, DRSP_21, DRSP_22, DRSP_23, CSS_B_1, CSS_B_2, CSS_B_3, CSS_B_4, CSS_B_5, CSS_B_6, CSS_B_7, CSS_B_8, CSS_B_9, CSS_B_10, CSS_B_11, CSS_B_12, CSS_B_13, CSS_B_14, CSS_B_15, CSS_B_16, CSS_B_17, CSS_B_18, CSS_Function_1, CSS_Function_2, CSS_Function_3, CSS_Function_4, CSS_Function_5, CSS_Function_6, CSS_Function_7, CSS_Function_8, CSS_Function_9, CSS_Function_10, CSS_B2_1, CSS_B2_2, CSS_B2_3, CSS_B2_4, CSS_B2_5, CSS_B2_6, CSS_B2_7, CSS_B2_8, UPPS_1, UPPS_2, UPPS_3, UPPS_4, UPPS_5, UPPS_6, UPPS_9, UPPS_10, UPPS_11, UPPS_12, UPPS_13, UPPS_14, UPPS_15, DEBQ_1, DEBQ_2, DEBQ_3, DEBQ_4, DEBQ_5, DEBQ_6, DEBQ_7, DEBQ_8, DEBQ_9, DEBQ_10, DEBQ_11, DEBQ_12, DEBQ_13

BDEFS_WM_avg, BDEFS_RI_avg, UPPS_NU_avg, UPPS_Persev_avg, UPPS_Premed_avg, UPPS_Sens_avg, UPPS_PU_avg, game_pinball, game_name_pinball, score_pinball, user_level_pinball, session_level_pinball, game_nth_pinball, game_lpi_pinball, RecordedDate_pinball, recorded_date_pinball, hour_recorded_pinball, midnight_to_seven_pinball, game_type_pinball, daterated_dontuse_pinball, game_robot, game_name_robot, score_robot, user_level_robot, session_level_robot, game_nth_robot, game_lpi_robot, RecordedDate_robot, recorded_date_robot, hour_recorded_robot, midnight_to_seven_robot, game_type_robot, daterated_dontuse_robot, nth_pinball_squared, nth_robot_squared, RES_robot, RES_pinball,


DRSP_1, DRSP_2, DRSP_3, DRSP_4, DRSP_5, DRSP_6, DRSP_7, DRSP_8, DRSP_9, DRSP_10, DRSP_11, DRSP_12, DRSP_13, DRSP_14, DRSP_15, DRSP_16, DRSP_17, DRSP_18, DRSP_19, DRSP_20, DRSP_21, DRSP_22, DRSP_23, UPPS_NU_avg, UPPS_Persev_avg, UPPS_Premed_avg, UPPS_Sens_avg, UPPS_PU_avg

# GAMM SCALED CYCLE DAY Effects - TEMPLATE MODEL
```{r}
hist(df$P4)
df$P4log <- log(df$P4+1)
hist(df$P4log)
gamm_p4 <- gam(P4log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_p4)

plot.gam(gamm_p4, select = 3)

hist(df$P4)
```


# GAMM SCALED CYCLE DAY Effects - TEMPLATE PLOT
```{r}

P4dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_p4, newdata = P4dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

P4dat$estimate = pred$estimate
P4dat$conf.low = pred$conf.low
P4dat$conf.high = pred$conf.high

# Plotting
P4plot <- ggplot(P4dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "P4") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

P4plot


```








# HORMONE MODELS

## Prepare Hormones

```{r}

#df$logE2 = log(df$E2 + 1)
#df$logP4 = log(df$P4 + 1)

df <- df %>%
  group_by(id) %>%
  mutate(
      logE2= log(E2+1), 
    logP4= log(P4+1),
    E2zd = scale(E2),
    P4zd = scale(P4),
    
    # Calculate 5th and 95th percentiles for E2 and P4 within each id
    E2_lower = quantile(E2zd, 0.05, na.rm = TRUE),
    E2_upper = quantile(E2zd, 0.95, na.rm = TRUE),
    P4_lower = quantile(P4zd, 0.05, na.rm = TRUE),
    P4_upper = quantile(P4zd, 0.95, na.rm = TRUE),
    
    # Manually Winsorize by clamping values to the 5th and 95th percentiles
    E2zd = pmin(pmax(E2zd, E2_lower), E2_upper),
    P4zd = pmin(pmax(P4zd, P4_lower), P4_upper),
    
    # Daily derivatives for E2 and P4
    E2zch = c(NA, diff(E2zd)),  # Winsorized E2 derivative
    P4zch = c(NA, diff(P4zd))   # Winsorized P4 derivative
  ) %>%
  filter(
    !is.na(E2zd) & !is.nan(E2zd) & !is.infinite(E2zd) &
      !is.na(P4zd) & !is.nan(P4zd) & !is.infinite(P4zd) &
      !is.na(E2zch) & !is.nan(E2zch) & !is.infinite(E2zch) &
      !is.na(P4zch) & !is.nan(P4zch) & !is.infinite(P4zch)
  ) %>%
  ungroup()


hist(df$E2zd)
hist(df$P4zd)

df <- df %>%
  group_by(id) %>%
  mutate(
    logE2= log(E2+1), 
    logP4= log(P4+1),
    E2zd = scale(E2),
    P4zd = scale(P4),
    
    # Calculate 5th and 95th percentiles for E2 and P4 within each id
    E2_lower = quantile(E2zd, 0.05, na.rm = TRUE),
    E2_upper = quantile(E2zd, 0.95, na.rm = TRUE),
    P4_lower = quantile(P4zd, 0.05, na.rm = TRUE),
    P4_upper = quantile(P4zd, 0.95, na.rm = TRUE),
    
    # Manually Winsorize by clamping values to the 5th and 95th percentiles
    E2zd = pmin(pmax(E2zd, E2_lower), E2_upper),
    P4zd = pmin(pmax(P4zd, P4_lower), P4_upper),
    
    # Daily derivatives for E2 and P4
    E2zch = c(NA, diff(E2zd)),  # Winsorized E2 derivative
    P4zch = c(NA, diff(P4zd))   # Winsorized P4 derivative
  ) %>%
  filter(
    !is.na(E2zd) & !is.nan(E2zd) & !is.infinite(E2zd) &
      !is.na(P4zd) & !is.nan(P4zd) & !is.infinite(P4zd) &
      !is.na(E2zch) & !is.nan(E2zch) & !is.infinite(E2zch) &
      !is.na(P4zch) & !is.nan(P4zch) & !is.infinite(P4zch)
  ) %>%
  ungroup()


```

# Looping through hormone effects - FIXED: E2zd, P4zd, E2zd*P4zd, E2zch, P4zch

```{r}

# Function to Loop Through Outcomes and Generate GAMM Models
create_gamm_models <- function(outcomelist, df, save_dir) {
  for (outcome in outcomelist) {
    # Prepare variables dynamically
    outcome_log <- paste0(outcome, "log")
    df[[outcome_log]] <- log(df[[outcome]] + 1)

    # Plot histogram for transformed outcome
    hist(df[[outcome]], main = paste("Histogram of", outcome))
    hist(df[[outcome_log]], main = paste("Histogram of Log-transformed", outcome))

    # GAMM model with hormone z-scores and derivatives
    gamm_formula <- as.formula(paste0(
      outcome_log, " ~ s(id, bs = \"re\") + s(E2zd) +",
      " s(P4zd)  + ti(E2zd, P4zd) +",
      " s(E2zch) + s(P4zch)"
    ))

    gamm_model <- gam(
      gamm_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Summary and plot of the model
    model_summary <- summary(gamm_model)
    print(model_summary)

    # Save the model summary as a text file
    summary_output <- capture.output(model_summary)
    summary_file_path <- file.path(save_dir, paste0(outcome, "_fixed__wzch_85_model_EP_summary.txt"))
    writeLines(summary_output, summary_file_path)
    cat("Model summary saved to:", summary_file_path, "\n")

    # Plot the GAMM effects
    plot.gam(gamm_model, select = 2, main = paste("Estrogen Effect on", outcome))
    plot.gam(gamm_model, select = 3, main = paste("Progesterone Effect on", outcome))
   plot.gam(gamm_model, select = 5, main = paste("Estrogen Change Effect on", outcome))
   plot.gam(gamm_model, select = 6, main = paste("Progesterone Change Effect on", outcome))

    # Simpler model without random effects for visualization
    gamm_simple_formula <- as.formula(paste0(
      outcome_log, " ~ s(E2zd) + s(P4zd) + ti(E2zd, P4zd)"
    ))

    gamm_model_simple <- gam(
      gamm_simple_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Create the grid for contour plot
    grid <- expand.grid(
      E2zd = seq(
        min(df$E2zd, na.rm = TRUE),
        max(df$E2zd, na.rm = TRUE),
        length.out = 100
      ),
      P4zd = seq(
        min(df$P4zd, na.rm = TRUE),
        max(df$P4zd, na.rm = TRUE),
        length.out = 100
      )
    )

    # Predict values
    grid$predicted <- predict(gamm_model_simple,
                              newdata = grid,
                              type = "response",
                              transform = function(x) exp(x) - 1)

    # Contour plot
    plot_title <- paste("Predicting", outcome, "from E2 and P4 (Person Standardized)")
    contour_plot <- ggplot() +
      geom_tile(data = grid, aes(x = E2zd, y = P4zd, fill = predicted)) +
      geom_contour(data = grid, aes(x = E2zd, y = P4zd, z = predicted), color = "black") +
      geom_point(data = df, aes(x = E2zd, y = P4zd), color = "black", alpha = 0.25) +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(grid$predicted)) +
      labs(x = "E2zd", y = "P4zd", fill = "Outcome") +
      theme_minimal() +
      ggtitle(plot_title)

    print(contour_plot)

    # Save the contour plot
    plot_file_path <- file.path(save_dir, paste0(outcome, "_85_wzch_fixed.png"))
    ggsave(filename = plot_file_path, plot = contour_plot, width = 8, height = 6)
    cat("Contour plot saved to:", plot_file_path, "\n")
  }
}

# CALL THE LOOP

#OutcomeList already exists above

create_gamm_models(outcomelist, df, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/EP_Models_Plots")

```



 
# TEMPLATE GAMM .zd and Derivative effects of Hormones - TEMPLATE

```{r}


hist(df$CSS_Inatt)
df$CSS_Inattlog <- log(df$CSS_Inatt+1)
hist(df$CSS_Inattlog)

gamm_hormzd_CSS_Inatt <- gam(
  CSS_Inattlog ~ s(id, bs = "re") + s(E2zd) + s(E2zd, id, bs = "re") +
    s(P4zd) + s(P4zd, id, bs = "re") + ti(E2zd, P4zd) +
    s(E2zch) + s(E2zch, id, bs = "re") + s(P4zch) + s(P4zch, id, bs = "re"),
  data = df,
  family = gaussian,
  method = "REML"
)

# Summary and plot of the model
summary(gamm_hormzd_CSS_Inatt)


# Save the model summary as a text file
summary_output <- capture.output(summary(gamm_hormzd_CSS_Inatt))
summary_file_path <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/EP_Models_Plots/CSS_Inatt_model_EP_summary.txt"
writeLines(summary_output, summary_file_path)
cat("Model summary saved to:", summary_file_path, "\n")

plot.gam(gamm_hormzd_CSS_Inatt, select=2) #Estrogen
plot.gam(gamm_hormzd_CSS_Inatt, select=4) #Progesterone
plot.gam(gamm_hormzd_CSS_Inatt, select=7) #Estrogen CHANGE
plot.gam(gamm_hormzd_CSS_Inatt, select=8) #Progesterone CHANGE


# Simpler model without random effects for visualization
gamm_horm_CSS_Inatt_simple <- gam(
  CSS_Inattlog ~ s(E2zd) + s(P4zd) + ti(E2zd, P4zd),
  data = df,
  family = gaussian,
  method = "REML"
)

# Create the grid for contour plot
grid <- expand.grid(
  E2zd = seq(
    min(df$E2zd, na.rm = TRUE),
    max(df$E2zd, na.rm = TRUE),
    length.out = 100
  ),
  P4zd = seq(
    min(df$P4zd, na.rm = TRUE),
    max(df$P4zd, na.rm = TRUE),
    length.out = 100
  )
)

# Predict values
grid$predicted <- predict(gamm_horm_CSS_Inatt_simple,
                          newdata = grid,
                          type = "response", 
                         transform = function(x) exp(x) - 1)

# Contour plot
ggplot() +
  geom_tile(data = grid, aes(x = E2zd, y = P4zd, fill = predicted)) +
  geom_contour(data = grid,
               aes(x = E2zd, y = P4zd, z = predicted),
               color = "black") +
  geom_point(
    data = df,
    aes(x = E2zd, y = P4zd),
    color = "black",
    alpha = 0.25
  ) +
  scale_fill_gradient2(
    low = "blue",
    mid = "white",
    high = "red",
    midpoint = median(grid$predicted)) +
  labs(x = "E2zd", y = "P4zd", fill = "Outcome") +
  theme_minimal() +
  ggtitle("Predicting CSS_Inatt from E2 and P4 (Person Standardized)")

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-03/EP_Models_Plots/CSS_Inatt.png", 
       plot = last_plot(), 
       width = 8, 
       height = 6)

```



# Looping through hormone effects - FIXED E2zd*P4zd TENSOR PRODUCT SMOOTH

```{r}
library(plotly)
library(htmlwidgets)

# Function to Loop Through Outcomes and Generate GAMM Models
create_gamm_models <- function(outcomelist, df, save_dir) {
  for (outcome in outcomelist) {
    # Prepare variables dynamically
    outcome_log <- paste0(outcome, "log")
    df[[outcome_log]] <- log(df[[outcome]] + 1)

    # Plot histogram for transformed outcome
    hist(df[[outcome]], main = paste("Histogram of", outcome))
    hist(df[[outcome_log]], main = paste("Histogram of Log-transformed", outcome))

    # GAMM model with hormone z-scores and derivatives
    gamm_formula <- as.formula(paste0(
      outcome_log, " ~ s(id, bs = \"re\") + te(E2zd, P4zd)"
    ))

    gamm_model <- gam(
      gamm_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Summary and plot of the model
    model_summary <- summary(gamm_model)
    print(model_summary)

    # Save the model summary as a text file
    summary_output <- capture.output(model_summary)
    summary_file_path <- file.path(save_dir, paste0(outcome, "_fixed__wzch_85_model_EP_summary.txt"))
    writeLines(summary_output, summary_file_path)
    cat("Model summary saved to:", summary_file_path, "\n")

    # Plot the GAMM effects
   # plot.gam(gamm_model, select = 2, main = paste("Estrogen Effect on", outcome))
   # plot.gam(gamm_model, select = 3, main = paste("Progesterone Effect on", outcome))
  # plot.gam(gamm_model, select = 5, main = paste("Estrogen Change Effect on", outcome))
  # plot.gam(gamm_model, select = 6, main = paste("Progesterone Change Effect on", outcome))

    # Simpler model without random effects for visualization
    gamm_simple_formula <- as.formula(paste0(
      outcome_log, " ~ te(E2zd, P4zd)"
    ))

    gamm_model_simple <- gam(
      gamm_simple_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Create the grid for contour plot
    grid <- expand.grid(
      E2zd = seq(
        min(df$E2zd, na.rm = TRUE),
        max(df$E2zd, na.rm = TRUE),
        length.out = 100
      ),
      P4zd = seq(
        min(df$P4zd, na.rm = TRUE),
        max(df$P4zd, na.rm = TRUE),
        length.out = 100
      )
    )

    # Predict values
    grid$predicted <- predict(gamm_model_simple,
                              newdata = grid,
                              type = "response",
                              transform = function(x) exp(x) - 1)

    # Contour plot
    plot_title <- paste("Predicting", outcome, "from E2 and P4 (Person Standardized)")
    contour_plot <- ggplot() +
      geom_tile(data = grid, aes(x = E2zd, y = P4zd, fill = predicted)) +
      geom_contour(data = grid, aes(x = E2zd, y = P4zd, z = predicted), color = "black") +
      geom_point(data = df, aes(x = E2zd, y = P4zd), color = "black", alpha = 0.25) +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(grid$predicted)) +
      labs(x = "E2zd", y = "P4zd", fill = "Outcome") +
      theme_minimal() +
      ggtitle(plot_title)

    print(contour_plot)

    # Save the contour plot
    plot_file_path <- file.path(save_dir, paste0(outcome, "_te_zd_fixed.png"))
    ggsave(filename = plot_file_path, plot = contour_plot, width = 8, height = 6)
    cat("Contour plot saved to:", plot_file_path, "\n")
    
     # Create the 3D surface plot using Plotly
    grid_matrix <- matrix(grid$predicted, nrow = 100, byrow = TRUE)
    surface_plot <- plot_ly(
      x = seq(min(df$E2zd, na.rm = TRUE), max(df$E2zd, na.rm = TRUE), length.out = 100),
      y = seq(min(df$P4zd, na.rm = TRUE), max(df$P4zd, na.rm = TRUE), length.out = 100),
      z = ~grid_matrix
    ) %>%
      add_surface() %>%
      layout(
        title = paste("3D Surface Plot of E2zd and P4zd Interaction for", outcome),
        scene = list(
          xaxis = list(title = "E2zd"),
          yaxis = list(title = "P4zd"),
          zaxis = list(title = "Predicted Outcome")
        )
      )

    # Save the interactive surface plot as an HTML file
    surface_plot_file_path <- file.path(save_dir, paste0(outcome, "_zd_3D_surface.html"))
    saveWidget(surface_plot, surface_plot_file_path)
    cat("3D surface plot saved to:", surface_plot_file_path, "\n")
  }
}


# CALL THE LOOP

outcomelist <- c("UPPS_NU_avg", "UPPS_Persev_avg", "UPPS_Premed_avg", "UPPS_Sens_avg", "UPPS_PU_avg", 
  "CSS_Fx_Total", "CSS_Inatt", "CSS_HypImp", "CSS_Inatt_Count", "CSS_HypImp_Count", 
  "score_pinball", "score_robot", "BDEFS_Total", "BDEFS_WM_avg", "BDEFS_RI_avg", 
  "UPPS_Total", "DEBQ_Total")

create_gamm_models(outcomelist, df, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-10/")

```

"DRSP_1", "DRSP_2", "DRSP_3", "DRSP_4", "DRSP_5", "DRSP_6", "DRSP_7", "DRSP_8", "DRSP_9", 
  "DRSP_10", "DRSP_11", "DRSP_12", "DRSP_13", "DRSP_14", "DRSP_15", "DRSP_16", "DRSP_17", 
  "DRSP_18", "DRSP_19", "DRSP_20", "DRSP_21", "DRSP_22", "DRSP_23",

# Looping through hormone effects - FIXED - RAW - TENSOR PRODUCT SMOOTH

```{r}

# Function to Loop Through Outcomes and Generate GAMM Models
create_gamm_models <- function(outcomelist, df, save_dir) {
  for (outcome in outcomelist) {
    # Prepare variables dynamically
    outcome_log <- paste0(outcome, "log")
    df[[outcome_log]] <- log(df[[outcome]] + 1)

    # Plot histogram for transformed outcome
    hist(df[[outcome]], main = paste("Histogram of", outcome))
    hist(df[[outcome_log]], main = paste("Histogram of Log-transformed", outcome))

    # GAMM model with hormone z-scores and derivatives
    gamm_formula <- as.formula(paste0(
      outcome_log, " ~ s(id, bs = \"re\") + te(E2, P4)"
    ))

    gamm_model <- gam(
      gamm_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Summary and plot of the model
    model_summary <- summary(gamm_model)
    print(model_summary)

    # Save the model summary as a text file
    summary_output <- capture.output(model_summary)
    summary_file_path <- file.path(save_dir, paste0(outcome, "_fixed_te_rawEP_model_EP_summary.txt"))
    writeLines(summary_output, summary_file_path)
    cat("Model summary saved to:", summary_file_path, "\n")

    # Plot the GAMM effects
   # plot.gam(gamm_model, select = 2, main = paste("Estrogen Effect on", outcome))
   # plot.gam(gamm_model, select = 3, main = paste("Progesterone Effect on", outcome))
  # plot.gam(gamm_model, select = 5, main = paste("Estrogen Change Effect on", outcome))
  # plot.gam(gamm_model, select = 6, main = paste("Progesterone Change Effect on", outcome))

    # Simpler model without random effects for visualization
    gamm_simple_formula <- as.formula(paste0(
      outcome_log, " ~ te(E2, P4)"
    ))

    gamm_model_simple <- gam(
      gamm_simple_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Create the grid for contour plot
    grid <- expand.grid(
      E2 = seq(
        min(df$E2, na.rm = TRUE),
        max(df$E2, na.rm = TRUE),
        length.out = 100
      ),
      P4 = seq(
        min(df$P4, na.rm = TRUE),
        max(df$P4, na.rm = TRUE),
        length.out = 100
      )
    )

    # Predict values
    grid$predicted <- predict(gamm_model_simple,
                              newdata = grid,
                              type = "response",
                              transform = function(x) exp(x) - 1)

    # Contour plot
    plot_title <- paste("Predicting", outcome, "from E2 and P4 (Person Standardized)")
    contour_plot <- ggplot() +
      geom_tile(data = grid, aes(x = E2, y = P4, fill = predicted)) +
      geom_contour(data = grid, aes(x = E2, y = P4, z = predicted), color = "black") +
      geom_point(data = df, aes(x = E2, y = P4), color = "black", alpha = 0.25) +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(grid$predicted)) +
      labs(x = "E2", y = "P4", fill = "Outcome") +
      theme_minimal() +
      ggtitle(plot_title)

    print(contour_plot)

    # Save the contour plot
    plot_file_path <- file.path(save_dir, paste0(outcome, "rawEP_te_fixed.png"))
    ggsave(filename = plot_file_path, plot = contour_plot, width = 8, height = 6)
    cat("Contour plot saved to:", plot_file_path, "\n")
    
    
  }
}


# CALL THE LOOP

#OutcomeList already exists above

create_gamm_models(outcomelist, df, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-04/")

```


# Looping through hormone effects - FIXED - RAW LOG - TENSOR PRODUCT SMOOTH

```{r}

# Function to Loop Through Outcomes and Generate GAMM Models
create_gamm_models <- function(outcomelist, df, save_dir) {
  for (outcome in outcomelist) {
    # Prepare variables dynamically
    outcome_log <- paste0(outcome, "log")
    df[[outcome_log]] <- log(df[[outcome]] + 1)

    # Plot histogram for transformed outcome
    hist(df[[outcome]], main = paste("Histogram of", outcome))
    hist(df[[outcome_log]], main = paste("Histogram of Log-transformed", outcome))

    # GAMM model with hormone z-scores and derivatives
    gamm_formula <- as.formula(paste0(
      outcome_log, " ~ s(id, bs = \"re\") + te(logE2 , logP4)"
    ))

    gamm_model <- gam(
      gamm_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Summary and plot of the model
    model_summary <- summary(gamm_model)
    print(model_summary)

    # Save the model summary as a text file
    summary_output <- capture.output(model_summary)
    summary_file_path <- file.path(save_dir, paste0(outcome, "_fixed_te_rawlogEP_model_EP_summary.txt"))
    writeLines(summary_output, summary_file_path)
    cat("Model summary saved to:", summary_file_path, "\n")

    # Plot the GAMM effects
   # plot.gam(gamm_model, select = 2, main = paste("Estrogen Effect on", outcome))
   # plot.gam(gamm_model, select = 3, main = paste("Progesterone Effect on", outcome))
  # plot.gam(gamm_model, select = 5, main = paste("Estrogen Change Effect on", outcome))
  # plot.gam(gamm_model, select = 6, main = paste("Progesterone Change Effect on", outcome))

    # Simpler model without random effects for visualization
    gamm_simple_formula <- as.formula(paste0(
      outcome_log, " ~ te(logE2 , logP4)"
    ))

    gamm_model_simple <- gam(
      gamm_simple_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Create the grid for contour plot
    grid <- expand.grid(
      logE2  = seq(
        min(df$logE2 , na.rm = TRUE),
        max(df$logE2 , na.rm = TRUE),
        length.out = 100
      ),
      logP4 = seq(
        min(df$logP4, na.rm = TRUE),
        max(df$logP4, na.rm = TRUE),
        length.out = 100
      )
    )

    # Predict values
    grid$predicted <- predict(gamm_model_simple,
                              newdata = grid,
                              type = "response",
                              transform = function(x) exp(x) - 1)

    # Contour plot
    plot_title <- paste("Predicting", outcome, "from logE2  and logP4")
    contour_plot <- ggplot() +
      geom_tile(data = grid, aes(x = logE2 , y = logP4, fill = predicted)) +
      geom_contour(data = grid, aes(x = logE2 , y = logP4, z = predicted), color = "black") +
      geom_point(data = df, aes(x = logE2 , y = logP4), color = "black", alpha = 0.25) +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(grid$predicted)) +
      labs(x = "logE2 ", y = "logP4", fill = "Outcome") +
      theme_minimal() +
      ggtitle(plot_title)

    print(contour_plot)

    # Save the contour plot
    plot_file_path <- file.path(save_dir, paste0(outcome, "rawlogEP_te_fixed.png"))
    ggsave(filename = plot_file_path, plot = contour_plot, width = 8, height = 6)
    cat("Contour plot saved to:", plot_file_path, "\n")
  }
}


# CALL THE LOOP

#OutcomeList already exists above

create_gamm_models(outcomelist, df, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-04/")

# Simulate data for logE2, logP4, and outcome
logE2 <- seq(-2, 2, length.out = 100)
logP4 <- seq(-2, 2, length.out = 100)
z <- outer(logE2, logP4, function(e2, p4) sin(e2) * cos(p4)) # Replace with actual model estimates

plot_ly(x = ~logE2, y = ~logP4, z = ~z, type = "surface") %>%
  layout(title = "Interaction Effect of logE2 and logP4 on Outcome",
         scene = list(
           xaxis = list(title = "logE2"),
           yaxis = list(title = "logP4"),
           zaxis = list(title = "Predicted Outcome")
         ))


```






# Function for te(???? not sure) in 85 dataset with 3D html plot output
```{r}
# Load required libraries
library(dplyr)
library(tidyr)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(mgcv)
library(plotly)
library(htmlwidgets)

# Function to Loop Through Outcomes and Generate GAMM Models
create_gamm_models <- function(outcomelist, df, save_dir) {
  for (outcome in outcomelist) {
    # Prepare variables dynamically
    outcome_log <- paste0(outcome, "log")
    df <- df %>% mutate(!!outcome_log := log(!!sym(outcome) + 1))

    # Plot histogram for transformed outcome using ggplot2
    hist_orig <- ggplot(df, aes(x = !!sym(outcome))) +
      geom_histogram(binwidth = 0.5, fill = "skyblue", color = "black") +
      labs(title = paste("Histogram of", outcome), x = outcome, y = "Count") +
      theme_minimal()

    hist_log <- ggplot(df, aes(x = !!sym(outcome_log))) +
      geom_histogram(binwidth = 0.5, fill = "skyblue", color = "black") +
      labs(title = paste("Histogram of Log-transformed", outcome), x = paste0(outcome, " (log)"), y = "Count") +
      theme_minimal()

    # Arrange the two histograms side by side and save
    histograms <- grid.arrange(hist_orig, hist_log, ncol = 2)
    hist_file_path <- file.path(save_dir, paste0(outcome, "_histograms.png"))
    ggsave(filename = hist_file_path, plot = histograms, width = 12, height = 6)
    cat("Histograms saved to:", hist_file_path, "\n")

    # GAMM model with hormone z-scores and derivatives
    gamm_formula <- as.formula(paste0(
      outcome_log, " ~ s(id, bs = \"re\") + te(logE2 , logP4)"
    ))

    gamm_model <- gam(
      gamm_formula,
      data = df,
      family = gaussian(),
      method = "REML"
    )

    # Summary and plot of the model
    model_summary <- summary(gamm_model)
    print(model_summary)

    # Save the model summary as a text file
    summary_output <- capture.output(model_summary)
    summary_file_path <- file.path(save_dir, paste0(outcome, "_fixed_te_rawlogEP_model_EP_summary.txt"))
    writeLines(summary_output, summary_file_path)
    cat("Model summary saved to:", summary_file_path, "\n")

    # Simpler model without random effects for visualization
    gamm_simple_formula <- as.formula(paste0(
      outcome_log, " ~ te(logE2 , logP4)"
    ))

    gamm_model_simple <- gam(
      gamm_simple_formula,
      data = df,
      family = gaussian(),
      method = "REML"
    )

    # Create the grid for contour plot
    grid <- expand_grid(
      logE2 = seq(
        min(df$logE2, na.rm = TRUE),
        max(df$logE2, na.rm = TRUE),
        length.out = 100
      ),
      logP4 = seq(
        min(df$logP4, na.rm = TRUE),
        max(df$logP4, na.rm = TRUE),
        length.out = 100
      )
    )

    # Predict values for contour plot
    grid <- grid %>%
      mutate(predicted = predict(gamm_model_simple, newdata = ., type = "response"))

    # Contour plot using ggplot2
    plot_title <- paste("Predicting", outcome, "from logE2 and logP4")
    contour_plot <- ggplot(grid, aes(x = logE2, y = logP4, z = predicted)) +
      geom_tile(aes(fill = predicted)) +
      geom_contour(color = "black") +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(grid$predicted, na.rm = TRUE)) +
      labs(x = "logE2", y = "logP4", fill = "Predicted Outcome") +
      theme_minimal() +
      ggtitle(plot_title)

    print(contour_plot)

    # Save the contour plot
    plot_file_path <- file.path(save_dir, paste0(outcome, "_rawlogEP_te_fixed.png"))
    ggsave(filename = plot_file_path, plot = contour_plot, width = 8, height = 6)
    cat("Contour plot saved to:", plot_file_path, "\n")

    # Create the 3D surface plot using Plotly
    grid_matrix <- matrix(grid$predicted, nrow = 100, byrow = TRUE)
    surface_plot <- plot_ly(
      x = seq(min(df$logE2, na.rm = TRUE), max(df$logE2, na.rm = TRUE), length.out = 100),
      y = seq(min(df$logP4, na.rm = TRUE), max(df$logP4, na.rm = TRUE), length.out = 100),
      z = ~grid_matrix
    ) %>%
      add_surface() %>%
      layout(
        title = paste("3D Surface Plot of logE2 and logP4 Interaction for", outcome),
        scene = list(
          xaxis = list(title = "logE2"),
          yaxis = list(title = "logP4"),
          zaxis = list(title = "Predicted Outcome")
        )
      )

    # Save the interactive surface plot as an HTML file
    surface_plot_file_path <- file.path(save_dir, paste0(outcome, "_3D_surface.html"))
    saveWidget(surface_plot, surface_plot_file_path)
    cat("3D surface plot saved to:", surface_plot_file_path, "\n")
  }
}

# CALL THE LOOP
create_gamm_models(outcomelist, df, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-04/")

```

