---
title: "ADHDCYCLE_daily"
output: 
  html_document: 
    toc: true
    fig_caption: true
    number_sections: true
    df_print: default
date: "Last compiled on `r format(Sys.time(), '%B %d, %Y')`"
---


# ---------------------------------------------------------------------------------- SETUP


# ---- Setup ----
- Turns of Scientific Notation
- Saves 'current_date' as a string in YYYYMMDD format
- Sets the number of digits (3) to display in output
- Saves Current Date as a string in YYYYMMDD format
- Sets the 'output_folder' as path to the output folder for saving files
```{r setup}

knitr::opts_chunk$set(echo = TRUE) # Setting options for knitr to display R code in output
options(scipen = 999) # Turn off scientific notation
options(digits = 3) # Set number of digits to display

current_date <- format(Sys.Date(), "%Y%m%d")  # Produces date as YYYYMMDD

output_folder <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/"

```


# ---- Load Packages (no cache) ----
```{r packages, warning=FALSE}

# ---- Global Chunk Options and Settings ----

# Setting options for knitr to display R code in output
knitr::opts_chunk$set(echo = TRUE)

# Prevent scientific notation in outputs
options(scipen = 999)

# ---- Data Manipulation and Cleaning ----

# Core tidyverse libraries for data manipulation and visualization
library(dplyr)       # Data manipulation (part of tidyverse)
library(tidyr)       # Data tidying (part of tidyverse)
library(tidyverse)   # Meta-package, includes dplyr, tidyr, ggplot2, and others
library(janitor)     # For cleaning data, e.g., renaming columns, removing empty rows
library(skimr)       # Summarize and inspect data quickly


# ---- Reading and Working with Files ----

# Libraries for reading various file formats
library(haven)       # For reading SPSS, Stata, and SAS files
library(readxl)      # For reading Excel files
library(readr)       # For reading CSV and other text files

?haven

# ---- Plotting and Visualization ----

# Core and extended libraries for data visualization
library(ggplot2)     # Core plotting library
library(ggdist)      # Visualizing distributions and uncertainty
library(ggforce)     # Extending ggplot2 functionality with advanced features
library(ggrepel)     # For adding non-overlapping text labels to ggplot2
library(visdat)      # Visualizing missing data and data structure
library(sjPlot)      # Plotting for statistical models (e.g., mixed models)
library(corrplot)    # For creating correlation matrix visualizations
library(grid)        # Base R graphics system for visual layout
library(gridExtra)   # Arranging multiple plots in a grid
library(see)         # Visualizing model checks and diagnostics
library(DescTools)  # Descriptive statistics and plotting tools

# ---- Time Series and Rolling Averages ----

# Libraries for time series data and handling dates
library(zoo)         # Working with rolling means/averages and time series
library(lubridate)   # Date and time manipulation


# ---- Mixed-Effects Models and Analysis ----

# Libraries for mixed-effects models and related analysis
library(lme4)        # Fitting mixed-effects models (linear and generalized)
library(lmerTest)    # Adds p-values for lme4 models
library(nlme)        # Linear and nonlinear mixed-effects models
library(emmeans)     # Compute estimated marginal means (EMMs) for model outputs
library(broom.mixed) # Tidying mixed model results into tidy data frames
library(performance) # Model performance metrics (e.g., R-squared for mixed models)
library(pbkrtest)    # Parametric bootstrap and Kenward-Roger methods for mixed models

# Generalized additive models and marginal effects
library(mgcv)        # Fitting generalized additive models (GAMs)
library(marginaleffects) # Tools for calculating marginal effects from regression models


# ---- Statistical Tools ----

# Libraries for specific statistical methods
#library(psych)       # Descriptive statistics and psychometrics
#library(GPArotation) # Factor analysis rotations (e.g., Varimax)
library(rmcorr)      # Repeated measures correlations
#library(MASS)        # Functions for statistical methods, e.g., Mahalanobis distance
library(careless)    # Detecting careless responses in surveys
library(responsePatterns) # Analyzing response patterns in data


# ---- GitHub, Project Management, and Reproducibility ----

# Libraries for project and version control management
library(usethis)     # Simplifies setting up GitHub repositories and managing projects
library(gitcreds)    # Managing Git credentials for GitHub interactions
#library(renv)        # Manages dependencies for reproducible environments
#library(targets)     # Workflow management for reproducible research pipelines

library(janitor)
library(pdftools)
library(magick)
```

# ---- Check for Package Conflicts and Declare Preferences (no cache) ----
```{r package conflicts, warning=FALSE}
library(conflicted) # Managing conflicts between package namespaces

conflict_scout() # Check for conflicts between package namespaces

conflicts_prefer(dplyr::filter)
conflicts_prefer(tidyr::complete)
conflicts_prefer(dplyr::lag)
```

# ---- Store Functions ----
Instructions: Please keep these chunks minimized when not in use. 

## standardize_index_names(): Function to standardize index variable names
- Inputs: Dataframe with misformatted "ID" or "date_rated" variables
- Outputs: @id and @daterated
#TODO: add hormones and other variables here, need to make it more flexible to pick up on other options
```{r standardize_index_names, cache=TRUE}

standardize_index_names <- function(df) {
    df %>%
        rename_with(~ gsub("([Dd]ate.?rated|daterated)", "daterated", .), # Standardize daterated column names
                    matches("date|daterated")) %>% # Match date or daterated in the column name
        rename_with(~ gsub("([Ii][Dd])", "id", .), matches("ID|id")) %>% # Standardize id column names
   # Standardize estradiol/estrogen-related column names to "E2" with word boundaries %>%
    rename_with(~ gsub("\\b([Ee]strogen|[Ee]stradiol|[Ee]2)\\b", "E2", .), 
                matches("\\bestrogen\\b|\\bEstradiol\\b|\\bE2\\b")) %>%
  # Standardize progesterone-related column names to "P4" with word boundaries
    rename_with(~ gsub("\\b([Pp]rogesterone|[Pp]4)\\b", "P4", .), 
                matches("\\bprogesterone\\b|\\bProgesterone\\b|\\bP4\\b"))
}



```

## count_rows_ids Function to count rows and unique ids
- Inputs: Any Dataframe with @id variable
- Outputs: Number of rows in the dataset, number of unique id values, and a list of unique id values
```{r count_rows_ids, cache=TRUE}

count_rows_ids <- function(df) {
  cat("Number of rows: ", nrow(df), "\n")
  cat("Number of unique ids: ", n_distinct(df$id), "\n")
  
  # Get a list of unique IDs in the dataset
  id_list <- unique(df$id)

  # Print the number of unique IDs and the list of unique IDs in a sentence
  cat("The id values are:", "\n", "\n", paste(id_list, collapse = ", "), "\n", "\n")
}

```

## print.variable.names() Function to print variable names
- Inputs: Any Dataframe
- Outputs: Names of all variables in the dataset
```{r print.variable.names, cache=TRUE}
print.variable.names <- function(df) {
  variable_names <- names(df)
  formatted_list <- paste(variable_names, collapse = ", ")
cat("-------- Names of variables in the raw dataset --------   ", formatted_list)
}
```

## create.person.metrics() Function to calculate person-level metrics for a given variable
- Inputs: @df dataset, @alldailyvars list, @id id variable
- Outputs: Dataframe with person-level metrics for the specified variable including: 
-     .d, .zd, .3roll, .5roll, .d.3roll, .d.5roll, .zd.3roll, and .zd.5roll
```{r create.person.metrics, cache=TRUE}
# Create a function to calculate person-level metrics for a given variable
create.person.metrics <- function(df, var, id) {
  # Capture the variable name
  var <- enquo(var)

  # Create person means for the specified variable, grouped by the id
  df <- df %>%
    group_by({{ id }}) %>%
    mutate(!!paste0(quo_name(var), ".m") := mean(!!var, na.rm = TRUE)) %>%
    ungroup()

  # Create person standard deviations for the specified variable, grouped by the id
  df <- df %>%
    group_by({{ id }}) %>%
    mutate(!!paste0(quo_name(var), ".sd") := sd(!!var, na.rm = TRUE)) %>%
    ungroup()

  # Create person deviations from the mean for the specified variable
  df <- df %>%
    mutate(!!paste0(quo_name(var), ".d") := (!!var) - .data[[paste0(quo_name(var), ".m")]])

  # Create person standardized values (z-scores) for the specified variable
  df <- df %>%
    mutate(!!paste0(quo_name(var), ".zd") := (.data[[quo_name(var)]] - .data[[paste0(quo_name(var), ".m")]]) / .data[[paste0(quo_name(var), ".sd")]])

  # Return the modified dataframe with the new metrics
  return(df)
}
```

## create.rolling.avgs(): Function to create 3- and 5-day rolling averages on raw, .d, and .zd variables in alldailyvars list
- Inputs: @df dataset, @alldailyvars list
- Outputs: Dataframe with 3- and 5-day rolling averages for the specified variable
```{r}
create.rolling.avgs <- function(df, var) {
  df %>%
    group_by(id) %>%
    mutate("{{var}}.3roll" := rollapply({{var}}, 3, function(x) mean(x, na.rm = TRUE), align="center", fill=NA, partial=TRUE), 
           "{{var}}.5roll" := rollapply({{var}}, 5, function(x) mean(x, na.rm = TRUE), align="center", fill=NA, partial=TRUE))
}
```



# ---- Store Global Lists of final variable names and labels ----
- Create Lists of Variables for Analysis
-   @dv_list: List of dependent variables for analysis
-   @hormlist: List of hormone variables for analysis
-   @alldailyvars: dv_list and hormlist combined

```{r make lists, cache=TRUE}

dv_list <- c(
  "CSS_Inatt",
  "CSS_HypImp",
  "score_pinball",
  "score_robot",
  "BDEFS_Total",
  "BDEFS_WM_avg",
  "BDEFS_RI_avg",
  "UPPS_NU_avg",
  "UPPS_PU_avg",
  "UPPS_Premed_avg",
  "UPPS_Persev_avg",
  "UPPS_Sens_avg",
  "DEBQ_Total",
  "CSS_Inatt_Count",
  "CSS_Hyp_Count",
  "CSS_Imp_Count",
  "CSS_HypImp_Count",
  "DRSP_1",
  "DRSP_2",
  "DRSP_3",
  "DRSP_4",
  "DRSP_5",
  "DRSP_6",
  "DRSP_7",
  "DRSP_8",
  "DRSP_9",
  "DRSP_10",
  "DRSP_11",
  "DRSP_12",
  "DRSP_13",
  "DRSP_14",
  "DRSP_15",
  "DRSP_16",
  "DRSP_17",
  "DRSP_18",
  "DRSP_19",
  "DRSP_20",
  "DRSP_21",
  "DRSP_22",
  "DRSP_23"
) %>% noquote()


# Rename the variables based on DRSP items
# This creates a named vector to assign meaningful labels to each variable for better interpretation in the plots
names(dv_list) <- c(
  "Inattention Sx", 
  "Hyperactivity/Imp Sx", 
  "Pinball Score",
  "Robot Score",
  "BDEFS Total",
  "BDEFS Working Memory",
  "BDEFS Resp Inhibition",
  "Negative Urgency",
  "Positive Urgency",
  "Lack of Premeditation",
  "Lack of Perseverance",
  "Sensation Seeking",
  "DEBQ Total",
  "Inattention Sx Count",
  "Hyperactivity Sx Count",
  "Impulsivity Sx Count",
  "Hyp/Imp Sx Count",
  "Depressed Mood", # DRSP_1
  "Hopelessness", # DRSP_2
  "Worthlessness/Guilt", # DRSP_3
  "Anxiety/Tension", # DRSP_4
  "Mood Swings", # DRSP_5
  "Rejection Sensitivity", # DRSP_6
  "Anger/Irritability", # DRSP_7
  "Interpersonal Conflict", # DRSP_8
  "Less Interest", # DRSP_9
  "Difficulty Concentrating", # DRSP_10
  "Lethargy/Fatigue", # DRSP_11
  "Incr Appetite/Overate", # DRSP_12
  "Food Cravings", # DRSP_13
  "Hypersomnia", # DRSP_14
  "Insomnia", # DRSP_15
  "Overwhelm/Can't Cope", # DRSP_16
  "Out of Control", # DRSP_17
  "Breast Tenderness", # DRSP_18
  "Swelling/Bloat/Wt Gain", # DRSP_19
  "Joint/Muscle Pain", # DRSP_20
  "Headache", # DRSP_21
  "Work/School Imp", 
  "Relational Imp"
)


# Rename the variables based on DRSP items
names(dv_list) <- c(
  "Depressed Mood", # DRSP_1
  "hopelessness", # DRSP_2
  "Worthlessness/Guilt", # DRSP_3
  "Anxiety/Tension", # DRSP_4
  "Mood Swings", # DRSP_5
  "Rejection Sensitivity", # DRSP_6
  "Anger/Irritability", # DRSP_7
  "Interpersonal Conflict", # DRSP_8
  "Less Interest", # DRSP_9
  "Difficulty Concentrating", # DRSP_10
  "Lethargy/Fatigue", # DRSP_11
  "Increased Appetite/Overate", # DRSP_12
  "Food Cravings", # DRSP_13
  "Hypersomnia", # DRSP_14
  "Insomnia", # DRSP_15
  "Overwhelm/Can't Cope", # DRSP_16
  "Out of Control", # DRSP_17
  "Breast Tenderness", # DRSP_18
  "Swelling/Bloating/Weight Gain", # DRSP_19
  "Joint/Muscle Pain", # DRSP_20
  "Headache", # DRSP_21
  "Work/School Impairment", 
  "Relational Impairment",
  "Inattention Symptoms", 
  "Hyperactivity/Impulsivity Symptoms", 
  "Pinball Score",
  "Robot Score",
  "BDEFS Total",
  "BDEFS Working Memory",
  "BDEFS Response Inhibition",
  "Negative Urgency",
  "Positive Urgency",
  "Lack of Premeditation",
  "Lack of Perseverance",
  "Sensation Seeking",
  "DEBQ Total",
  "Inattention Sx Count",
  "Hyperactivity Sx Count",
  "Impulsivity Sx Count",
  "Hyperactivity/Impulsivity Sx Count"
)

hormlist <- c(
  "E2",
  "P4",
  "LH"
) %>% noquote()

#Create another list that combines both dv_list and hormlist above
alldailyvars <- c(dv_list, hormlist) %>% noquote()
```

# ---------------------------------------------------------------------------------- DATA PREPARATION AND CLEANING



```{r}
# Load first raw dataset

# New file emailed by Emily Knapp and Urveesha June 2025

rawdf1 <- read_csv("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/02_datasets/CYCADHD_DAILY/03_cleaned_data/adhdcyc_daily_2024_07_09_horm.csv") 

#count_rows_ids(rawdf1) 66 ids: 203, 205, 206, 208, 209, 213, 214, 218, 221, 223, 224, 225, 227, 228, 230, 232, 233, 235, 237, 239, 241, 242, 243, 245, 246, 248, 249, 251, 252, 254, 256, 258, 259, 260, 261, 262, 263, 265, 266, 267, 268, 270, 271, 272, 273, 275, 277, 278, 279, 281, 283, 284, 286, 287, 289, 290, 293, 305, 307, 310, 312, 314, 317, 318, 321, 324 

# Standardize variable names
rawdf1 <- standardize_index_names(rawdf1)

names(rawdf1)

# Create new date variable called daterated 
rawdf1 <- rawdf1 %>%
  mutate(daterated = as.Date(date, format = "%Y-%m-%d")) # Convert date_rated to Date format

# Keep id, daterated, E2, P4, LH, StartPeriod, PosLHTest
rawdf1 <- rawdf1 %>%
  select(id, date, daterated, E2, P4, LH, StartPeriod, PosLHTest)

View(rawdf1)
```



# ---- Load New Raw Data (save it as both rawdf and df) ----
```{r load data}

# Load your CSV file (adjust the path to your actual file location)

# New file emailed by Emily Knapp and Urveesha June 2025

rawdf <- read_sav("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/02_datasets/CYCADHD_DAILY/02_data_prep_workspace/2025-08-20/2025.06.02 Daily Master.sav") 

# Create new dbl variable called id from ID
rawdf <- rawdf %>%
  mutate(id = as.numeric(ID)) %>% # Convert ID to numeric
  select(-ID) # Drop the original ID column

# move id to the start of the file
rawdf <- rawdf %>%
  select(id, everything()) # Move id to the first column

# Standardize variable names
rawdf <- standardize_index_names(rawdf)

View(rawdf)

# Change the path to your file

df <- rawdf

print.variable.names(df)

##View(df)

count_rows_ids(df)

# remove observations where date_rated is NA
df <- df %>%
  filter(!is.na(daterated))

count_rows_ids(df)


# add placeholder rows for missing dates by id (date_rated)
df <- df %>%
  group_by(id) %>%
  complete(daterated = seq.Date(min(daterated), max(daterated), by = "day")) %>%
  ungroup()

count_rows_ids(df)

# View id, daterated, E2 in df
View(df %>% select(id, daterated, E2))


```

# Merge rawdf1 hormones into new rawdf
```{r}
#check formats of id and daterated in both datasets
str(df$id) #check id format (dbl)
str(rawdf1$id) #check id format (dbl)
str(df$daterated) #check daterated format (date)
str(rawdf1$daterated) #check daterated format (date)


# Merge finalhormonebatch into df based on id and daterated (many to many):
df <- df %>%
  left_join(rawdf1, by = c("id", "daterated"), suffix = c("", ".new"))

# If E2, P4, or LH in df is NA, replace it with the value from finalhormonebatch
df <- df %>%
  mutate(
    E2 = ifelse(is.na(E2), E2.new, E2),
    P4 = ifelse(is.na(P4), P4.new, P4),
    LH = ifelse(is.na(LH), LH.new, LH)  ) %>%
  select(-ends_with(".new")) # Remove the temporary columns created during the join

View(df)

# View id, daterated, E2 in df
View(df %>% select(id, daterated, E2))


```

# Merge in additional cycle and ov dates from Emily Knapp in August of 2025

```{r}
# Load additional cycle data

knapp_dates <- read_csv("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/02_datasets/CYCADHD_DAILY/02_data_prep_workspace/2025-08-20/cycadhd_mensov_iso.csv")

#check formats of id in both datasets
str(df$id) #check id format (dbl)
str(knapp_dates$id) #check id format (chr)

# Convert id in knapp_dates to numeric to match df
knapp_dates <- knapp_dates %>%
  mutate(id = as.numeric(id))

# Stndardize names
knapp_dates <- standardize_index_names(knapp_dates)

# Check for duplicate id and daterated combinations in knapp_dates
duplicates_knapp <- knapp_dates %>%
  group_by(id) %>%
  filter(n() > 1)

##View(duplicates_knapp) #None

# Merge knapp_dates into df based on id (one to many): 
df <- df %>%
  left_join(knapp_dates, by = "id")

# View items in knapp_dates in the new df file merged

#View(df)

# Drop if RecordedDate is NA
df <- df %>%
  filter(!is.na(RecordedDate))

# remove duplicate combinations of id and daterated
df <- df %>%
  distinct(id, daterated, .keep_all = TRUE)

count_rows_ids(df)

```


# Import final hormone batch from Emily with dates added

```{r}
finalhormonebatch <- read_csv("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/02_datasets/CYCADHD_DAILY/02_data_prep_workspace/2025-08-25/Martel_IRB52576_Results_E2_P4_LH 7-23-2025.csv")

View(finalhormonebatch)
#names(finalhormonebatch)

finalhormonebatch <- standardize_index_names(finalhormonebatch)

#set id to numeric
finalhormonebatch <- finalhormonebatch %>%
  mutate(id = as.numeric(id)) # Convert id to numeric to match df

#set daterated to iso date format
finalhormonebatch <- finalhormonebatch %>%
  mutate(daterated = as.Date(daterated, format = "%Y-%m-%d")) # Convert daterated to Date format

df <- df %>%
  mutate(daterated = as.Date(daterated, format = "%Y-%m-%d")) # Convert daterated to Date format

finalhormonebatch <- finalhormonebatch %>%
  separate(sample, into = c("id_sample", "TubeNumber"), sep = "-")

# Drop id_sample variable
finalhormonebatch <- finalhormonebatch %>%
  select(-id_sample)

# Determine which ids are not shared between finalhormonebatch and df
ids_not_in_df <- setdiff(finalhormonebatch$id, df$id)

ids_not_in_df
# Good, all ids in in both dataframes

# Check for duplicate id and TubeNumber combinations in finalhormonebatch
duplicates_hormone <- finalhormonebatch %>%
  group_by(id, TubeNumber) %>%
  filter(n() > 1)

##View(duplicates_hormone) #None

count_rows_ids(df)

```

```{r}
# ---- Standardize Names ----
df <- standardize_index_names(df)



# Drop TubeNumber from df and finalhormonebatch if it exists in either dataset


finalhormonebatch <- finalhormonebatch %>%
  select(-TubeNumber)


finalhormonebatch <- finalhormonebatch %>% 
  group_by(id) %>%              # 1. Group the data by participant/ID
  fill(daterated) %>%          # 2. Fill in missing values of `date_rated` within each group
  ungroup()                     # 3. Remove the grouping

View(finalhormonebatch)

#Print unique ids
#unique(finalhormonebatch$id)
 # ids in this new finalhormonebatch list: 323 324 325 326 327 329 330 331 332 333 334 336 337 338 340 341 343 344 345 346 347 348

# ---- Sort df by id and daterated ----
finalhormonebatch <- finalhormonebatch %>%
  arrange(id, daterated)

df <- df %>%
  arrange(id, daterated)

# Check formats of E2, P4, and LH in both datasets
str(finalhormonebatch$E2) #num - NOTE: set <.000 to 0
str(finalhormonebatch$P4) #num - NOTE: set <.000 to 0
str(finalhormonebatch$LH) #num
str(df$E2) #num
str(df$P4) #num
str(df$LH) #num

# save id, daterated, E2, P4, LH, and hormone_assay_note from the finalhormonebatch dataset
finalhormonebatch <- finalhormonebatch %>%
  select(id, daterated, E2, P4, LH, hormone_assay_note)


#Format date_rated as ISO in both datasets
finalhormonebatch$daterated <- as.Date(finalhormonebatch$daterated, format = "%Y-%m-%d")

# Format daterated as ISO in both datasets
df$daterated <- as.Date(df$daterated, format = "%Y-%m-%d")

names(df)
names(finalhormonebatch)


count_rows_ids(df)
count_rows_ids(finalhormonebatch)


```





```{r}

#check formats of id and daterated and TubeNumber and LH in both datasets
str(df$id) #check id format (dbl)
str(finalhormonebatch$id) #check id format (dbl)
str(df$daterated) #check daterated format (date)
str(finalhormonebatch$daterated) #check daterated format (date)

#View(finalhormonebatch)

# Merge finalhormonebatch into df based on id and daterated (many to many):
df <- df %>%
  left_join(finalhormonebatch, by = c("id", "daterated"), suffix = c("", ".new"))

# If E2, P4, or LH in df is NA, replace it with the value from finalhormonebatch
df <- df %>%
  mutate(
    E2 = ifelse(is.na(E2), E2.new, E2),
    P4 = ifelse(is.na(P4), P4.new, P4),
    LH = ifelse(is.na(LH), LH.new, LH)  ) %>%
  select(-ends_with(".new")) # Remove the temporary columns created during the join

View(df)

names(df)

# add a copy of daterated called date and format as iso
df <- df %>%
  mutate(date = as.Date(daterated, format = "%Y-%m-%d")) # Convert daterated to Date format

```


# ---- Standardize Variable Names ----
- This includes standardizing the names of the index variables (id and daterated)
- Also includes renaming to E2, P4, CSS_Inatt_Count, CSS_Hyp_Count, and CSS_Imp_Count
```{r renaming variables}

df <- standardize_index_names(df)

df <- df %>%
  rename(
    CSS_Inatt_Count = IA_Count, 
    CSS_Hyp_Count = Hyp_Count, 
    CSS_Imp_Count = Imp_Count)

print.variable.names(df)

View(df)

```

# ---- Setting Variable Formats  ----
- Convert daterated to Date format using lubridate if necessary (ensure date format matches)
```{r updating formats, include=TRUE}
convert_date_if_needed <- function(df, date_column) {
  # Check if the date column is in Date format
  if (!inherits(df[[date_column]], "Date")) {
    df <- df %>%
      mutate({{ date_column }} := lubridate::mdy(!!sym(date_column))) # Convert to mm/dd/yyyy format if not already in Date format
  }
  return(df)
}

# Call
df <- convert_date_if_needed(df, "daterated")
```

# ---- Sort df by id and daterated ----
```{r sort df}
df <- df %>%
  arrange(id, daterated)
```


# ---- Removing rows with NA for all, for id, or for daterated  ----
```{r removing NAs}
# Remove rows where all values are NA
df <- df[rowSums(is.na(df)) != ncol(df), ]

# Remove rows with NA in key columns (e.g., id, daterated)
df <- df %>%
  filter(!is.na(id), !is.na(daterated))

count_rows_ids(df)
```


# ---- Add Placeholder for Missing Dates ----

```{r add-placeholder-days}

# Display the number of rows BEFORE adding placeholders
cat("Before adding placeholder dates, this is the number of rows: ", nrow(df), "\n")

df <- df %>%
  group_by(id) %>%
  complete(daterated = seq.Date(min(daterated), max(daterated), by = "day")) %>%
  ungroup()

# Display the number of rows after adding placeholders
cat("Placeholder dates added (i.e., added blank lines for days when there were no surveys but the participant was in the study). AFTER adding placeholder dates, this is the number of rows: ", nrow(df), "\n")
```

```{r}
#count the number of unique ids in the dataset 
count_rows_ids(df)

# how many ids have at least one non-NA value for E2? 
ids_with_E2 <- df %>%
  filter(!is.na(E2)) %>%
  distinct(id)
ids_with_E2

# 89

# Create a list of the ids in ids_with_E2
ids_with_E2_list <- ids_with_E2$id

ids_with_E2_list

# 203 205 206 207 208 209 210 213 214 218 219 221 223 224 225 227 228 230 232 233 235 237 239 241 242 243 245 246 248 249 252 254 256 258 259 260 261 262 263 265 266 267 268 270 271 272 273 275 277 278 279 281 283 284 286 287 289 290 293 305 307 310 312 314 317 318 321 323 324 325 326 327 329 330 331 332 333 334 336 337 338 340 341 343 344 345 346 347 348

```




# ---- Hard-Coded Fixes ----
```{r hard-coded-changes}
# Hard-coding changes based on manual review

df$StartPeriod[df$id == 208 & df$TubeNumber == 27] <- 1
# Fix date issues for participant 210
df$daterated[df$id == 210 & df$daterated == as.Date("2021-11-20")] <- as.Date("2020-11-20")
df$daterated[df$id == 210 & df$daterated == as.Date("2021-11-21")] <- as.Date("2020-11-21")



# Add in missing menses onset dates from Urveesha
# <!-- Calculated menses onset (although almost all of these are recorded in the tracking sheet? Not sure why missing): -->
# <!-- 206 - 4/25/21 -->
# <!-- 208 - 2/27/21 -->
# <!-- 209 - 2/15/21 -->
# <!-- 255- 7/2/22 -->
# <!-- 258 - 7/11/22 -->
# <!-- 270 - 9/4/22 -->
# <!-- 279 - 10/27/22 -->
# <!-- 290 - 2/21/23 -->
# <!-- 291 - 2/10/23 -->
# <!-- 293 - 2/3/23 -->
# <!-- 312 - 7/4/23 -->
# <!-- 331 - 1/3/24 -->
# <!-- 332 - 1/21/24     -->

# Convert the dates to Date format
df[["daterated"]] <- as.Date(df[["daterated"]], format = "%m/%d/%y")

# Define a vector of IDs and their corresponding menses onset dates
menses_onset_data <- data.frame(
  id = c(206, 208, 209, 255, 258, 270, 279, 290, 291, 293, 312, 331, 332),
  onset_date = as.Date(c("2021-04-25", "2021-02-27", "2021-02-15", "2022-07-02", "2022-07-11", 
                         "2022-09-04", "2022-10-27", "2023-02-21", "2023-02-10", "2023-02-03", 
                         "2023-07-04", "2024-01-03", "2024-01-21"))
)

# Update StartPeriod in df for these ID and date combinations
for (i in 1:nrow(menses_onset_data)) {
  df[["StartPeriod"]][df[["id"]] == menses_onset_data$id[i] & df[["daterated"]] == menses_onset_data$onset_date[i]] <- 1
}
```

# ---- TURNED OFF: Set E2, P4, LH to NA for patients with unusable hormone data (based on Tory and Ashley Eng inspection of salivary E2 and P4) ----
- Note that their raw data can still be accessed in @rawdf
- The variable @removed_from_horm_analysis is created and set to 1 for all observations from these IDs
```{r}
# List of IDs whose hormone data should be flagged for missingness due to poor quality

#badhorm_ids <- c(221, 235, 243, 267, 272, 273, 278, 283, 305, 307, 312, 317)

# Add a new binary column `remove_from_horm_analysis` to flag the IDs

#df <- df %>%
 # mutate(removed_from_horm_analysis = ifelse(id %in% badhorm_ids, 1, 0))

# For these ids, set variables E2 and P4 to missing
#df <- df %>%
#  mutate(E2 = ifelse(id %in% badhorm_ids, NA, E2),
#         P4 = ifelse(id %in% badhorm_ids, NA, P4),
#         LH = ifelse(id %in% badhorm_ids, NA, LH))

```

# ---- Calculate ADHD, UPPS, BDEFS, and DEBQ Scores ----
- reverse code pinball and robot
- Score ADHD, UPPS, and BDEFS Scales
#TODO add UPPS subscales here
```{r score-rename-scales}

df <- df %>%
  group_by(id) %>%
  mutate(
    # Convert columns to numeric to ensure proper summation
    CSS_Inatt = rowMeans(across(
      c(
        CSS_B_1,
        CSS_B_3,
        CSS_B_5,
        CSS_B_7,
        CSS_B_9,
        CSS_B_11,
        CSS_B_13,
        CSS_B_15,
        CSS_B_17
      ),
      ~ as.numeric(.)
    ), na.rm = TRUE),
    # Convert each column to numeric, handle missing values with na.rm = TRUE
    
    CSS_HypImp = rowMeans(across(
      c(
        CSS_B_2,
        CSS_B_4,
        CSS_B_6,
        CSS_B_8,
        CSS_B_10,
        CSS_B_12,
        CSS_B_14,
        CSS_B_16,
        CSS_B_18
      ),
      ~ as.numeric(.)
    ), na.rm = TRUE),
    # Same process for CSS_HypImp scores
    
    # Adding the counts without needing row-wise summation
    CSS_HypImp_Count = CSS_Imp_Count + CSS_Hyp_Count,
    
    # Direct summation of these variables, assuming they are already numeric
    
    # Functional Total Score: Summing specific function-related columns
    CSS_Fx_Total = rowMeans(across(
      c(
        CSS_Function_1,
        CSS_Function_2,
        CSS_Function_3,
        CSS_Function_4,
        CSS_Function_5,
        CSS_Function_6,
        CSS_Function_7,
        CSS_Function_8,
        CSS_Function_9,
        CSS_Function_10
      ),
      ~ as.numeric(.)
    ), na.rm = TRUE),
    
    # DEBQ Total Score summing all DEBQ columns
    DEBQ_Total = rowMeans(across(
      c(
        DEBQ_1,
        DEBQ_2,
        DEBQ_3,
        DEBQ_4,
        DEBQ_5,
        DEBQ_6,
        DEBQ_7,
        DEBQ_8,
        DEBQ_9,
        DEBQ_10,
        DEBQ_11,
        DEBQ_12,
        DEBQ_13
      ),
      ~ as.numeric(.)
    ), na.rm = TRUE),
    
    # BDEFS Total Score summing all BDEFS columns
    BDEFS_Total = rowMeans(across(
      c(BDEFS_1, BDEFS_2, BDEFS_3, BDEFS_4, BDEFS_5, BDEFS_6),
      ~ as.numeric(.)
    ), na.rm = TRUE)
  ) %>%
  ungroup()

# Reverse code pinball and robot

# Step 1: Find the maximum values for both variables
max_robot <- max(df$score_robot, na.rm = TRUE)
max_pinball <- max(df$score_pinball, na.rm = TRUE)

# Step 2: Reverse code the variables WITH SAME NAME
df$score_robot <- max_robot - df$score_robot
df$score_pinball <- max_pinball - df$score_pinball


# Check Histograms - they are all zero inflated

#hist(df$CSS_Inatt, breaks = 10, main = "Histogram of CSS_Inatt", xlab = "CSS_Inatt", col = "lightblue")
#hist(df$CSS_HypImp, breaks = 10, main = "Histogram of CSS_HypImp", xlab = "CSS_HypImp", col = "lightblue")
#hist(df$BDEFS_Total, breaks = 10, main = "Histogram of BDEFS_Total", xlab = "BDEFS_Total", col = "lightblue")
#hist(df$BDEFS_WM_avg, breaks = 10, main = "Histogram of BDEFS_WM_avg", xlab = "BDEFS_WM_avg", col = "lightblue")
#hist(df$BDEFS_RI_avg)

#hist(df$DEBQ_Total, breaks = 10, main = "Histogram of DEBQ_Total", xlab = "DEBQ_Total", col = "lightblue")

# Checking direction - They are all positively correlated

#cor(df$IA_Count, df$DEBQ_Total, use="pairwise.complete.obs")
#cor(df$BDEFS_Total, df$BDEFS_WM_avg, use="pairwise.complete.obs")
#cor(df$BDEFS_WM_avg, df$score_pinball, use="pairwise.complete.obs")
#cor(df$BDEFS_RI_avg, df$score_robot, use="pairwise.complete.obs")
```

# ---- Calculate Person Metrics .d, .zd, .m, and .sd for all daily variables ----
```{r run person metrics}

# Loop through each variable in alldailyvars list and create person-level metrics

for (var in alldailyvars) {
  df <- create.person.metrics(df=df, var = !!sym(var), id = id)
}

```

# ---- Calculate 3- and 5-day Rolling averages on raw, .d, .zd for all daily variables ----

```{r run rolling avgs}

# Loop through each variable and create 3- and 5-day rolling averages for each RAW variable in alldailyvars

for (var in alldailyvars) {
  df <- create.rolling.avgs(df, var = !!sym(var))
}

# Loop through each variable and create 3- and 5-day rolling averages for each .d variable in alldailyvars
for (var in alldailyvars) {
  # Create the .d version of the variable name
  var.d <- paste0(quo_name(var), ".d")
  
  # Pass the .d version as a symbol to the function
  df <- create.rolling.avgs(df, var = !!sym(var.d))
}

# Loop through each variable and create 3- and 5-day rolling averages for each .zd variable in alldailyvars
for (var in alldailyvars) {
  # Create the .zd version of the variable name
  var.zd <- paste0(quo_name(var), ".zd")
  
  # Pass the .d version as a symbol to the function
  df <- create.rolling.avgs(df, var = !!sym(var.zd))
}

# Confirm the calculation of new metrics .d.3roll, .d.5roll, .zd.3roll, and .zd.5roll

#DONE df %>% dplyr::select(id, daterated, DRSP_1, DRSP_1.d.3roll, DRSP_1.zd.3roll) %>% #View()

```

# Open menstrualcycleR
```{r}
#remotes::install_github("eisenlohrmoullab/menstrualcycleR")
library(menstrualcycleR)
```

```{r}
# create a new variable called "menses" where StartPeriod = 1
df <- df %>%
  mutate(menses = ifelse(StartPeriod == 1, 1, 0))

# If c1_menses or c2_menses or c3_menses match date, set menses to 1
df <- df %>%
  mutate(menses = ifelse(date %in% c(c1_menses, c2_menses, c3_menses), 1, menses))

View(df)

count_rows_ids(df)

# how many ids have at least one non-NA value for E2? 
ids_with_E2 <- df %>%
  filter(!is.na(E2)) %>%
  distinct(id)
ids_with_E2 #89

```

# Create "LHposday" (0/1/NA) that represents the positive LH day.
```{r create LHposday}


####View(df)
  
  df$PosLHTest <- as.numeric(df$PosLHTest)

df <- df %>%
  mutate(LHposday = case_when(
    is.na(PosLHTest) ~ NA_real_,
    PosLHTest == 1 ~ 1,
    TRUE ~ 0
  ))

####View(df)

# Eliminate all but the first pos Ov day in a new variable called "LHposdayfirst"
df <- df %>%
  arrange(id, date) %>%  # Arrange the data by id and daterated
  group_by(id) %>%  # Group the data by id
  mutate(
    LHposdayfirst = case_when(
      is.na(LHposday) ~ NA_real_,
      LHposday == 1 & lag(LHposday, order_by = date) != 1 ~ 1,
      TRUE ~ 0
    )
  ) %>% 
  ungroup()  # Remove the grouping

#Check vars
#DONE df %>% dplyr::select(id, daterated, mensdayonefirst, LHposdayfirst) %>% #View()

# Create "ovtoday" variable that is 1 on the day after LHposdayfirst, 0 otherwise
df <- df %>%
  arrange(id, date) %>%  # Arrange the data by id and daterated
  group_by(id) %>%  # Group the data by id
  mutate(
    ovtoday = case_when(
      is.na(LHposdayfirst) ~ NA_real_,
      lag(LHposdayfirst, order_by = date) == 1 ~ 1,
      TRUE ~ 0
    )
  ) %>% 
  ungroup()  # Remove the grouping

# List unique ids in df
list <-unique(df$id)

#list



```

# Create plots by id with date on the x axis and person-standardized E2, P4, and LH values on the Y axis
```{r}

# USE THE SCRIPT "hormone_prep_template" in the adhd-cycle repository to create daily hormone graphs


```



# LEFT OF HERE-- NEXT STEP IS TO FINALIZE MENSES AND OVTODAY VALUES BY CODING










```{r create cycle plots by id, message=FALSE, warning=FALSE}
# ---------------------------------------------------------------------------------- PRINT DATA INFO

# ---- Count Rows and Unique IDs ----
```{r count rows and ids}
count_rows_ids(df)
```

# ---- Specific Ns for Days in Study, Survey Data, and Hormone Data ----        
```{r data N details}

# Filter the data for non-missing E2 values and count unique ids
non_missing_E2 <- df %>%
  filter(!is.na(E2))

non_missing_E2_count <- n_distinct(non_missing_E2$id)
non_missing_E2_ids <- unique(non_missing_E2$id)

# Get IDs with missing E2 values
missing_E2_ids <- setdiff(unique(df$id), non_missing_E2_ids)

# Print the result for non-missing E2 values
cat("Number of people WITH usable hormones:", non_missing_E2_count, "\n")
cat("The id values are:", "\n", paste(non_missing_E2_ids, collapse = ", "), "\n", "\n")

# Print the result for missing E2 values
cat("Number of people WITHOUT usable hormone data:", length(missing_E2_ids), "\n")
cat("Their id values are:", "\n", paste(missing_E2_ids, collapse = ", "), "\n", "\n")
cat("Of those, these ids were removed due to non-cyclic/insufficient hormone data as reviewed by Tory Eisenlohr-Moul and Ashley Eng:", "\n", paste(badhorm_ids, collapse = ", "), "\n", "\n")

# Filter the data for non-missing survey values and count unique ids
non_missing_survey <- df %>%
  filter(!is.na(DRSP_1))

non_missing_survey_count <- n_distinct(non_missing_survey$id)
non_missing_survey_ids <- unique(non_missing_survey$id)

# Get IDs with missing survey values
missing_survey_ids <- setdiff(unique(df$id), non_missing_survey_ids)

# Print the result for non-missing survey values
cat("Number of people WITH any surveys:", non_missing_survey_count, "\n")
cat("Their id values are:", "\n", paste(non_missing_survey_ids, collapse = ", "), "\n", "\n")

# Print the result for missing survey values
cat("Number of people WITHOUT any surveys:", length(missing_survey_ids), "\n")
cat("Their id values are:", "\n", paste(missing_survey_ids, collapse = ", "), "\n", "\n")

# Find the intersection of available hormone data and available survey data
intersection_ids <- intersect(non_missing_E2_ids, non_missing_survey_ids)
intersection_count <- length(intersection_ids)

# Print the result for the intersection of hormone and survey data
cat("Number of people WITH both usable hormone and any survey data:", intersection_count, "\n")
cat("Their id values are:", "\n", paste(intersection_ids, collapse = ", "), "\n", "\n")

# Count the non-missing observations of DRSP_1 and E2 for people with both hormone and survey data
non_missing_intersection <- df %>%
  filter(id %in% intersection_ids, !is.na(DRSP_1), !is.na(E2))

non_missing_intersection_count <- nrow(non_missing_intersection)

# Print the result for non-missing observations of DRSP_1 and E2
# NOTE THAT THERE WILL BE MORE PEOPLE WITH SCALED CYCLEDAY DATA
cat("Number of non-missing observations of DRSP_1 and E2 for people with both hormone and survey data:", non_missing_intersection_count, "\n")

# Create a list of IDs with the number of days with both E2 and DRSP
usable_days_list <- non_missing_intersection %>%
  group_by(id) %>%
  summarise(usable_days = n()) %>%
  arrange(usable_days)

# Print the list of IDs with the number of days in words
cat("List of IDs with the number of days having both E2 and DRSP (sorted by number of observations ascending):", "\n")
for (i in 1:nrow(usable_days_list)) {
  cat("id", usable_days_list$id[i], "has", usable_days_list$usable_days[i], "hormone-survey pairs.", "\n")
}

```

# ---- Plot Overlap of Available Data  ----        
# Plot days in study, nonmissing survey observations, and E2 observations per id 
#TODO I want to add a venn diagram here. 
```{r N details plot, message=FALSE, warning=FALSE}

# Count the total number of "Days in Study" (total observations per ID)
df_count <- df %>%
  group_by(id) %>%
  summarize(days_in_study = n())

# Count the number of non-missing observations per ID for the variable DRSP_1
df_nonmissing_count <- df %>%
  group_by(id) %>%
  summarize(number_of_observations = sum(!is.na(DRSP_1)))

# Count the number of non-missing observations for the variable E2
df_e2_nonmissing_count <- df %>%
  group_by(id) %>%
  summarize(e2_nonmissing = sum(!is.na(E2)))

#### Handle Outliers ONLY for "Days in Study" ####

# Outlier removal for "Days in Study"
Q1 <- quantile(df_count$days_in_study, 0.25)
Q3 <- quantile(df_count$days_in_study, 0.75)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
df_no_outliers <- df_count %>%
  filter(days_in_study >= lower_bound & days_in_study <= upper_bound)

#### Determine Y-Axis Limits ####
y_min <- min(df_no_outliers$days_in_study, df_nonmissing_count$number_of_observations, df_e2_nonmissing_count$e2_nonmissing, na.rm = TRUE)
y_max <- max(df_no_outliers$days_in_study, df_nonmissing_count$number_of_observations, df_e2_nonmissing_count$e2_nonmissing, na.rm = TRUE)

#### Plots ####

# Plot "Days in Study" per ID (with outliers removed)
plot1_no_outliers <- ggplot(df_no_outliers, aes(x = factor(1), y = days_in_study, label = id)) +
  geom_violin(fill = "lightblue", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "blue", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Days in Study", title = "Days in Study per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Plot "Number of Observations" for DRSP_1 (without removing outliers)
plot2_no_outliers <- ggplot(df_nonmissing_count, aes(x = factor(1), y = number_of_observations, label = id)) +
  geom_violin(fill = "lightgreen", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "darkgreen", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Number of Observations (Non-missing DRSP_1)", title = "Surveys per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Plot "Number of non-missing E2 observations" (without removing outliers)
plot3_no_outliers <- ggplot(df_e2_nonmissing_count, aes(x = factor(1), y = e2_nonmissing, label = id)) +
  geom_violin(fill = "lightcoral", alpha = 0.5) +  # Violin plot to show distribution
  geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.7) +  # Boxplot inside the violin
  geom_jitter(width = 0.15, size = 2, color = "red", alpha = 0.7) +  # Dots for raw data
  geom_text(aes(label = id), hjust = -0.1, size = 3, check_overlap = TRUE) +  # Add ID labels
  labs(x = NULL, y = "Number of Observations (Non-missing E2)", title = "Hormone Days per ID") +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  ylim(y_min, y_max)

# Combine the three plots on one page using grid.arrange from gridExtra
observations_plot <- grid.arrange(plot1_no_outliers, plot2_no_outliers, plot3_no_outliers, ncol = 3)

# Save the combined plot to a file with the current date
ggsave(filename = paste0(output_folder, "N_observations_plot_", current_date, ".png"), 
       plot = observations_plot, 
       width = 8, 
       height = 6)

```

# ---- Print Variable Names ----
```{r print variable names}
print.variable.names(df)
```


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

##### END OF DATA PREP 


# Save out Prepped Dataset for Easier Use Later On



```{r}

write.csv(df, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/adhd_daily_df_20241020.csv", row.names = FALSE)


```


