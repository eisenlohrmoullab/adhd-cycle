---
title: "ADHDCYC_ScaledCycle_GAMMs"
author: "Tory Eisenlohr-Moul"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

############################################################################# CYCLE SCALING


## Using CYCLEDAY SCALING TEMPLATE - from Anisha updated September 14, 2024



```{r}

# Renaming Datasets
dat <- df

# Renaming Variables
dat$ID <-dat$id
dat$id <-dat$id
dat$daterated <-dat$date_rated


#df$LHposdayfirst
#df$mensdayonefirst
```

## Functions 

```{r}
calculate_mcyclength <- function(data) {
  # Calculate m2mcount: This counts from 1 menses onset to the next to give the length of a menses-to-menses cycle
  data <- data %>%
    group_by(id) %>%
    arrange(daterated, .by_group = TRUE) %>%
    mutate(
      m2mcount = NA,
      mcyclength = NA,
      cycle_incomplete = 0
    )
  
  for (i in seq_len(nrow(data))) {
    if (!is.na(data$A[i]) && data$A[i] == 1) {
      data$m2mcount[i] <- 1
      j <- i + 1
      
      while (j <= nrow(data) &&
             data$id[j] == data$id[i] && (is.na(data$A[j]) || data$A[j] != 1)) {
        data$m2mcount[j] <- data$m2mcount[j - 1] + 1
        j <- j + 1
      }
      
      if (j <= nrow(data) &&
          data$id[j] == data$id[i] && !is.na(data$A[j]) && data$A[j] == 1) {
        data$m2mcount[j] <- data$m2mcount[j - 1] + 1
      }
    }
  }
  
  # Identify incomplete cycles: This identifies instances where a complete menses-to-menses cycle was not captured
  data <- data %>%
    mutate(cycle_incomplete = ifelse(!is.na(m2mcount) &
                                       (is.na(lead(m2mcount)) & id != lead(id)), 1, 0))
  
  # New condition: Set cycle_incomplete = 1 if m2mcount restarts when id changes
  data <- data %>%
    group_by(id) %>%
    mutate(
      cycle_incomplete = ifelse(
        id != lag(id, default = first(id)) & m2mcount == 1, 1, cycle_incomplete
      )
    ) %>%
    ungroup()
  
  # Propagate cycle_incomplete within each group of m2mcount
  data <- data %>%
    group_by(id) %>%
    mutate(cycle_group = cumsum(!is.na(m2mcount) & m2mcount == 1)) %>%
    group_by(id, cycle_group) %>%
    mutate(
      cycle_incomplete = ifelse(any(cycle_incomplete == 1), 1, 0),
      # Fix: handle cases where all values in m2mcount are NA
      mcyclength = ifelse(all(is.na(m2mcount)), NA, max(m2mcount, na.rm = TRUE))
    ) %>%
    ungroup() %>%
    select(-cycle_group)
  
  data$cycle_incomplete = ifelse(is.na(data$cycle_incomplete), 1, 0)
  data$cycle_incomplete = ifelse(is.na(data$m2mcount), NA, data$cycle_incomplete)
  
  # Calculate cyclenum: calculates number of menses-to-menses cycles within a person
  data <- data %>%
    group_by(id) %>%
    mutate(cyclenum = cumsum(!is.na(m2mcount) & m2mcount == 1 & cycle_incomplete == 0)) %>%
    ungroup()
  
  data <- data %>%
    group_by(id) %>%
    mutate(cyclenum = ifelse(
      cycle_incomplete == 1,
      NA,
      cumsum(!is.na(m2mcount) & m2mcount == 1 & cycle_incomplete == 0)
    )) %>%
    ungroup()
  
  return(data)
}



#calculate_lutdaycount: counts length of luteal phase 

calculate_lutdaycount <- function(data, ovtoday) {
  last_id <- NULL
  lutdaycount1 <- rep(NA, nrow(data))
  lut_incomplete1 <- rep(NA, nrow(data))  # Initialize lut_incomplete
  count_started_row <- NA  # Track the starting row of a lutdaycount1 stretch
  active_count <- FALSE  # Track if lutdaycount1 is currently counting

  for (i in 1:nrow(data)) {
    # If id changes, reset lutdaycount1 and lut_incomplete
    if (is.null(last_id) || last_id != data$id[i]) {
      if (active_count) {
        # Mark the whole stretch as incomplete if stopped by id change
        lut_incomplete1[count_started_row:(i - 1)] <- 1
      }
      lutdaycount1[i] <- ifelse(ovtoday[i] == 1, 0, NA)
      active_count <- !is.na(lutdaycount1[i])  # Start counting if lutdaycount1 is initialized
      count_started_row <- ifelse(!is.na(lutdaycount1[i]), i, NA)  # Record start row
    } else if (!is.na(lutdaycount1[i - 1])) {
      lutdaycount1[i] <- lutdaycount1[i - 1] + 1
    }

    # If lutdaycount1 is active and stops because of A == 1, set lut_incomplete = 0 for the entire stretch
    if (!is.na(lutdaycount1[i]) && !is.na(data$A[i]) && data$A[i] == 1) {
      lutdaycount1[i] <- NA
      lut_incomplete1[count_started_row:(i - 1)] <- 0  # Mark stretch as complete due to A == 1
      active_count <- FALSE  # Stop counting due to A == 1
    } else if (ovtoday[i] == 1) {
      lutdaycount1[i] <- 0
      active_count <- TRUE  # Start counting at ovtoday == 1
      count_started_row <- i  # Record start row of the count
    }

    # Assign the current row to last_id for the next iteration
    last_id <- data$id[i]
  }

  # Update the dataset with lutdaycount1 and lut_incomplete
  data$lutdaycount1 <- lutdaycount1
  data$lut_incomplete1 <- lut_incomplete1
  
  return(data)
}

#calculate_foldaycount: counts length of follicular phase 

calculate_foldaycount <- function(data, ovtoday) {
  foldaycount <- NA
  fol_incomplete <- NA
  last_id <- NULL
  active_count <- FALSE  # Track if foldaycount is currently active
  count_started_row <- NULL  # Track the starting row of a foldaycount stretch
  
  for (i in 1:nrow(data)) {
    # If id changes, reset foldaycount and fol_incomplete
    if (is.null(last_id) || is.na(data$id[i]) || last_id != data$id[i]) {
      if (active_count) {
        # Mark the whole stretch as incomplete if stopped by id change
        data$fol_incomplete[count_started_row:i-1] <- 1
      }
      foldaycount <- ifelse(data$A[i] == 1, 0, NA)
      active_count <- !is.na(foldaycount)  # Start counting if foldaycount is initialized
      fol_incomplete <- NA  # Reset fol_incomplete when id changes
      count_started_row <- ifelse(!is.na(foldaycount), i, NA)  # Record start row
    } else if (!is.na(foldaycount)) {
      foldaycount <- foldaycount + 1
    }

    # If foldaycount is active and stopped because of ovtoday == 1, set fol_incomplete = 0 for the whole stretch
    if (!is.na(foldaycount) && i >= 2 && !is.na(ovtoday[i]) && ovtoday[i - 1] == 1) {
      foldaycount <- NA
      data$fol_incomplete[count_started_row:i-1] <- 0  # Mark stretch as complete due to ovulation
      active_count <- FALSE  # Stop counting due to ovulation
      fol_incomplete <- 0
    }

    # If A == 1, start or reset the count
    if (data$A[i] == 1) {
      foldaycount <- 0
      active_count <- TRUE  # Start counting
      count_started_row <- i  # Record start row of the count
    }

    # If foldaycount is actively counting and stops because of id change
    if (!is.na(last_id) && !is.na(data$id[i]) && last_id != data$id[i] && active_count) {
      data$fol_incomplete[count_started_row:i-1] <- 1  # Mark as incomplete because the count stopped due to id change
      active_count <- FALSE  # Stop counting as the id changed
    }

    # Assign foldaycount and fol_incomplete to the current row
    data$foldaycount[i] <- foldaycount
    if (is.na(fol_incomplete)) {
      data$fol_incomplete[i] <- NA
    }

    # Update last_id for the next iteration
    last_id <- data$id[i]
  }

  return(data)
}

```


<!-- ```{r} -->
<!-- #subset to only include baseline, washout, and PBO  -->
<!-- dat = dat %>% filter(cleartrialphase == 0| cleartrialphase == 1| cleartrialphase == 4| cleartrialphase == 5| cleartrialphase == 8|cleartrialphase == 9|cleartrialphase == 12) -->


```{r}

dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax = NA)

#create the variable 'A' which will represent menses onset
dat$A <- ifelse(dat$cycleday == 1, 1, 0)
dat$A <- ifelse(is.na(dat$A), 0, dat$A)
#ovtoday = LH + 1
dat$ovtoday = lag(dat$LHposdayfirst) #changed this from "posovtest"
#check data
dat %>% select(daterated, ovtoday, LHposdayfirst)
```






## Functions 

```{r}



calculate_mcyclength <- function(data) {
  # Calculate m2mcount: This counts from 1 menses onset to the next to give the length of a menses-to-menses cycle
  data <- data %>%
    group_by(id) %>%
    arrange(daterated, .by_group = TRUE) %>%
    mutate(
      m2mcount = NA,
      mcyclength = NA,
      cycle_incomplete = 0
    )
  
  for (i in seq_len(nrow(data))) {
    if (!is.na(data$A[i]) && data$A[i] == 1) {
      data$m2mcount[i] <- 1
      j <- i + 1
      
      while (j <= nrow(data) &&
             data$id[j] == data$id[i] && (is.na(data$A[j]) || data$A[j] != 1)) {
        data$m2mcount[j] <- data$m2mcount[j - 1] + 1
        j <- j + 1
      }
      
      if (j <= nrow(data) &&
          data$id[j] == data$id[i] && !is.na(data$A[j]) && data$A[j] == 1) {
        data$m2mcount[j] <- data$m2mcount[j - 1] + 1
      }
    }
  }
  
  # Identify incomplete cycles: This identifies instances where a complete menses-to-menses cycle was not captured
  data <- data %>%
    mutate(cycle_incomplete = ifelse(!is.na(m2mcount) &
                                       (is.na(lead(m2mcount)) & id != lead(id)), 1, 0))
  
  # New condition: Set cycle_incomplete = 1 if m2mcount restarts when id changes
  data <- data %>%
    group_by(id) %>%
    mutate(
      cycle_incomplete = ifelse(
        id != lag(id, default = first(id)) & m2mcount == 1, 1, cycle_incomplete
      )
    ) %>%
    ungroup()
  
  # Propagate cycle_incomplete within each group of m2mcount
  data <- data %>%
    group_by(id) %>%
    mutate(cycle_group = cumsum(!is.na(m2mcount) & m2mcount == 1)) %>%
    group_by(id, cycle_group) %>%
    mutate(
      cycle_incomplete = ifelse(any(cycle_incomplete == 1), 1, 0),
      # Fix: handle cases where all values in m2mcount are NA or max is missing
      mcyclength = ifelse(sum(!is.na(m2mcount)) > 0, max(m2mcount, na.rm = TRUE), NA)
    ) %>%
    ungroup() %>%
    select(-cycle_group)
  
  data$cycle_incomplete = ifelse(is.na(data$cycle_incomplete), 1, 0)
  data$cycle_incomplete = ifelse(is.na(data$m2mcount), NA, data$cycle_incomplete)
  
  # Calculate cyclenum: calculates number of menses-to-menses cycles within a person
  data <- data %>%
    group_by(id) %>%
    mutate(cyclenum = cumsum(!is.na(m2mcount) & m2mcount == 1 & cycle_incomplete == 0)) %>%
    ungroup()
  
  data <- data %>%
    group_by(id) %>%
    mutate(cyclenum = ifelse(
      cycle_incomplete == 1,
      NA,
      cumsum(!is.na(m2mcount) & m2mcount == 1 & cycle_incomplete == 0)
    )) %>%
    ungroup()
  
  return(data)
}


#calculate_lutdaycount: counts length of luteal phase 

calculate_lutdaycount <- function(data, ovtoday) {
  last_id <- NULL
  lutdaycount1 <- rep(NA, nrow(data))
  lut_incomplete1 <- rep(NA, nrow(data))  # Initialize lut_incomplete
  count_started_row <- NA  # Track the starting row of a lutdaycount1 stretch
  active_count <- FALSE  # Track if lutdaycount1 is currently counting

  for (i in 1:nrow(data)) {
    # If id changes, reset lutdaycount1 and lut_incomplete
    if (is.null(last_id) || last_id != data$id[i]) {
      if (active_count) {
        # Mark the whole stretch as incomplete if stopped by id change
        lut_incomplete1[count_started_row:(i - 1)] <- 1
      }
      lutdaycount1[i] <- ifelse(ovtoday[i] == 1, 0, NA)
      active_count <- !is.na(lutdaycount1[i])  # Start counting if lutdaycount1 is initialized
      count_started_row <- ifelse(!is.na(lutdaycount1[i]), i, NA)  # Record start row
    } else if (!is.na(lutdaycount1[i - 1])) {
      lutdaycount1[i] <- lutdaycount1[i - 1] + 1
    }

    # If lutdaycount1 is active and stops because of A == 1, set lut_incomplete = 0 for the entire stretch
    if (!is.na(lutdaycount1[i]) && !is.na(data$A[i]) && data$A[i] == 1) {
      lutdaycount1[i] <- NA
      lut_incomplete1[count_started_row:(i - 1)] <- 0  # Mark stretch as complete due to A == 1
      active_count <- FALSE  # Stop counting due to A == 1
    } else if (ovtoday[i] == 1) {
      lutdaycount1[i] <- 0
      active_count <- TRUE  # Start counting at ovtoday == 1
      count_started_row <- i  # Record start row of the count
    }

    # Assign the current row to last_id for the next iteration
    last_id <- data$id[i]
  }

  # Update the dataset with lutdaycount1 and lut_incomplete
  data$lutdaycount1 <- lutdaycount1
  data$lut_incomplete1 <- lut_incomplete1
  
  return(data)
}

calculate_foldaycount <- function(data, ovtoday) {
  # Initialize the foldaycount and fol_incomplete columns
  data$foldaycount <- NA
  data$fol_incomplete <- NA
  
  foldaycount <- NA
  fol_incomplete <- NA
  last_id <- NULL
  active_count <- FALSE  # Track if foldaycount is currently active
  count_started_row <- NA  # Track the starting row of a foldaycount stretch
  
  for (i in 1:nrow(data)) {
    
    # If id changes or this is the first row, reset foldaycount and fol_incomplete
    if (is.null(last_id) || is.na(data$id[i]) || (!is.na(last_id) && last_id != data$id[i])) {
      if (active_count) {
        # Mark the whole stretch as incomplete if stopped by id change
        data$fol_incomplete[count_started_row:(i-1)] <- 1
      }
      foldaycount <- ifelse(data$A[i] == 1, 0, NA)
      active_count <- !is.na(foldaycount)  # Start counting if foldaycount is initialized
      fol_incomplete <- NA  # Reset fol_incomplete when id changes
      count_started_row <- ifelse(!is.na(foldaycount), i, NA)  # Record start row
    } else if (!is.na(foldaycount)) {
      foldaycount <- foldaycount + 1
    }

    # If foldaycount is active and stopped because ovtoday == 1 (indicating ovulation)
    if (active_count && i > 1 && !is.na(ovtoday[i]) && ovtoday[i] == 1) {
      foldaycount <- NA
      data$fol_incomplete[count_started_row:(i-1)] <- 0  # Mark stretch as complete due to ovulation
      active_count <- FALSE  # Stop counting due to ovulation
      fol_incomplete <- 0
    }

    # If A == 1, start or reset the count
    if (!is.na(data$A[i]) && data$A[i] == 1) {
      foldaycount <- 0
      active_count <- TRUE  # Start counting
      count_started_row <- i  # Record start row of the count
    }

    # Assign foldaycount and fol_incomplete to the current row
    data$foldaycount[i] <- foldaycount
    data$fol_incomplete[i] <- ifelse(is.na(fol_incomplete), NA, fol_incomplete)

    # Update last_id for the next iteration, but only if it's not missing
    if (!is.na(data$id[i])) {
      last_id <- data$id[i]
    }
  }

  return(data)
}


```


# Removed the cleartrialphase piece here

# Calculate Menses-to-menses cycle lengths 

## m2mcount and cyclelength 

```{r}

#the mcyclength function, this will do forward count to give cycle lengths for menses-to-menses cycles, and count the number of complete cycles within a person 
dat <- calculate_mcyclength(dat)

#-Inf will occur if the cycle is incomplete (no bookend menses onset date) so we will change to NA
dat$mcyclength = ifelse(dat$mcyclength == -Inf , NA, dat$mcyclength)

#if cyclenum is NA, set cycle_incomplete to 1 
dat$cycle_incomplete = ifelse(is.na(dat$cyclenum), 1, dat$cycle_incomplete)

#check data
dat %>% select(id, daterated, A, m2mcount, ovtoday, cyclenum, mcyclength, cycle_incomplete) 

```



Here, I am doing scaling for baseline, washout, and PBO condition

# calculating ovtoday_impute
 
```{r}
# this is based on NC dataset 
dat <- dat %>% 
  mutate(lutlength_impute = case_when(mcyclength == 20 ~ (mcyclength* 0.46),
                                      mcyclength == 21 ~ (mcyclength*.476),
                                      mcyclength == 22 ~ (mcyclength*.491),
                                      mcyclength == 23 ~ (mcyclength*.491),
                                      mcyclength == 24 ~ (mcyclength*.492),
                                      mcyclength == 25 ~ (mcyclength*.484),
                                      mcyclength == 26 ~ (mcyclength*.481),
                                      mcyclength == 27 ~ (mcyclength*.470),
                                      mcyclength == 28 ~ (mcyclength*.461),
                                      mcyclength == 29 ~ (mcyclength*.448),
                                      mcyclength == 30 ~ (mcyclength*.437),
                                      mcyclength == 31 ~ (mcyclength*.426),
                                      mcyclength == 32 ~ (mcyclength*.416),
                                      mcyclength == 33 ~ (mcyclength*.40),
                                      mcyclength == 34 ~ (mcyclength*.391),
                                      mcyclength == 35 ~ (mcyclength*.377),
                                      mcyclength == 36 ~ (mcyclength*.369),
                                      mcyclength == 37 ~ (mcyclength*.359),
                                      TRUE ~ NA))

dat <- dat %>% 
  mutate(follength_impute = case_when(mcyclength == 20 ~ (mcyclength*.54),
                                      mcyclength == 21 ~ (mcyclength*.524),
                                      mcyclength == 22 ~ (mcyclength*.509),
                                      mcyclength == 23 ~ (mcyclength*.509),
                                      mcyclength == 24 ~ (mcyclength*.508),
                                      mcyclength == 25 ~ (mcyclength*.516),
                                      mcyclength == 26 ~ (mcyclength*.519),
                                      mcyclength == 27 ~ (mcyclength*.530),
                                      mcyclength == 28 ~ (mcyclength*.539),
                                      mcyclength == 29 ~ (mcyclength*.552),
                                      mcyclength == 30 ~ (mcyclength*.563),
                                      mcyclength == 31 ~ (mcyclength*.574),
                                      mcyclength == 32 ~ (mcyclength*.584),
                                      mcyclength == 33 ~ (mcyclength*.60),
                                      mcyclength == 34 ~ (mcyclength*.609),
                                      mcyclength == 35 ~ (mcyclength*.623),
                                      mcyclength == 36 ~ (mcyclength*.631),
                                      mcyclength == 37 ~ (mcyclength*.641),
                                      TRUE ~ NA))
#check data
dat %>% select(id, daterated, A, m2mcount, mcyclength, follength_impute)
#group by id, and make sure dates are in order 
dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) 
#initialize new variable- follcount1
dat$follcount1 <- NA
for (i in 1:nrow(dat)) {
  if (dat$A[i] == 1 & !is.na(dat$follength_impute[i])) {
    follcount1 <- seq_len(round(dat$follength_impute[i]))
    dat$follcount1[i:(i + length(follcount1) - 1)] <- follcount1
  }
}
#follcount1 forward counts from menses onset based on imputed follength from NC data 

dat %>% select(id, A, follength_impute, follcount1)

#identify ovtoday_impute based on forward count from follcount1
dat <- dat %>% 
  mutate(ovtoday_impute = case_when(round(follength_impute) == follcount1 ~ 1,
                               TRUE ~ NA))

#if ovtoday is NA, change to 0 
dat$ovtoday <- ifelse(is.na(dat$ovtoday), 0, dat$ovtoday) 

#if ovtoday_impute is NA, change to 0 
dat$ovtoday_impute <- ifelse(is.na(dat$ovtoday_impute), 0, dat$ovtoday_impute) 

#check data 
dat %>% select(id, daterated, ovtoday, ovtoday_impute) # Removed cleartrialphase
```


# percentage of luteal phase using ovtoday (LH + 1) 

 - variable is called perclut for menses-centered
 - variable is called perclut_ov for ovulation-centered 
 

```{r}
#group by id, make sure daterated is in order, initialize the variable lutmax 
dat <- dat  %>% 
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(lutmax = NA)
#apply the calculate_lutdaycount function. which spits out the variable lutdaycount1. lutdaycount1 forward counts from ovtoday = 1 to the next menses onset, indexed at 0 
dat <- calculate_lutdaycount(dat, dat$ovtoday)
#check data 
dat %>% select(id, daterated, ovtoday, A, lutdaycount1)
#the below code creates lutdaycount which shifts lutdaycount1, and forward counts starting the day after ovtoday = 1, still indexed at 0 
dat <- dat %>%
  group_by(id) %>%
  mutate(
    lutdaycount = lag(lutdaycount1),
    lutdaycount = case_when(
      is.na(lutdaycount) | id != lag(id) ~ NA, 
      TRUE ~ lutdaycount
    )
  )

dat <- dat %>%
  group_by(id) %>%
  mutate(
    lut_incomplete = lag(lut_incomplete1),
    lut_incomplete = case_when(
      is.na(lut_incomplete) | id != lag(id) ~ NA, 
      TRUE ~ lut_incomplete
    )
  )


#check data 
dat %>% select(id, daterated, ovtoday, A, lutdaycount, lut_incomplete)
#lutmax corresponds to the length of the luteal phase in a complete menses-to-menses cycle (it is the max value of lutdaycount in a cycle)
for (i in 1:(nrow(dat)-1)) {
  if (is.na(dat$lutdaycount[i + 1] && !is.na(dat$lutdaycount[i]))) {
    dat$lutmax[(i-(dat$lutdaycount[i])):i] = as.numeric(dat$lutdaycount[i])
  }
}

dat$lut_incomplete = ifelse(dat$lutmax > 30, 1, dat$lut_incomplete)
#check data 
dat %>% select(id, daterated, ovtoday, A, lutdaycount, lutmax, lut_incomplete)

#calculates lutperc which is luteal phase scaled from 0 to 1, using ovtoday 
dat <- dat %>%
  mutate(lutperc = ifelse(lut_incomplete == 0, (lutdaycount / lutmax), NA))

#calculates perclut_base which is luteal phase scaled from -1 to 0, using ovtoday. This is the variable that will be used in the menses-centered scaled_cycleday 
dat$perclut = dat$lutperc -1 

# dat <- dat %>%
#   mutate(perclut = ifelse(A == 1, 0, perclut))

#check data
dat %>% select(id, daterated, ovtoday, A, lutmax, perclut, lut_incomplete)

#calculate lutdaycount_ov, which is lutdaycount but ovulation-centered 
dat <- dat %>%
  group_by(id) %>%
  mutate(
    lutdaycount_ov = lead(lutdaycount),
    lutdaycount_ov = case_when(is.na(lutdaycount_ov) |
                                 id != lead(id) ~ NA, TRUE ~ lutdaycount_ov)
  )

dat <- dat %>%
  mutate(perclut_ov = ifelse(lut_incomplete == 0, lutdaycount_ov / lutmax, NA))

# dat <- dat %>%
#   mutate(perclut_ov = ifelse(lutdaycount_ov == 0, 0, perclut_ov))


dat %>% select(id,
               daterated,
               ovtoday,
               A,
               lutdaycount,
               lutdaycount_ov,
               lutmax,
               perclut_ov, perclut)

#remove 'helper' variables
dat <- dat %>% select(-c(lutdaycount1, lutperc, lut_incomplete1))

```

# percentage of luteal phase using ovtoday_impute (based on NC norms)


```{r}
#make sure dates are in order for each id, initialize new variable called lutmax_impute
dat <- dat  %>% 
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(lutmax_impute = NA)
#if A is NA, make it 0 (A is menses onset)
dat$A <- ifelse(is.na(dat$A), 0, dat$A)
#apply calculate_lutdaycount fxn which spits out the variable lutdaycount1. lutdaycount1 forward counts from ovtoday_impute = 1 to the next menses onset, indexed at 0 
dat <- calculate_lutdaycount(dat, dat$ovtoday_impute)
#check data
dat %>% select(id, daterated, ovtoday_impute, A, lutdaycount1)
#the below code creates lutdaycount_impute which shifts lutdaycount1, and forward counts starting the day after ovtoday_impute = 1, still indexed at 0 
dat <- dat %>%
  group_by(id) %>%
  mutate(
    lutdaycount_impute = lag(lutdaycount1),
    lutdaycount_impute = case_when(
      is.na(lutdaycount_impute) | id != lag(id) ~ NA, 
      TRUE ~ lutdaycount_impute
    )
  )
#check data 
dat %>% select(id, daterated, ovtoday_impute, A, lutdaycount_impute)

#lutmax_impute corresponds to the length of the luteal phase in a complete menses-to-menses cycle, using ovtoday_impute (it is the max value of lutdaycount_impute in a cycle)
for (i in 1:(nrow(dat)-1)) {
  if (is.na(dat$lutdaycount_impute[i + 1] && !is.na(dat$lutdaycount_impute[i]))) {
    dat$lutmax_impute[(i-(dat$lutdaycount_impute[i])):i] = as.numeric(dat$lutdaycount_impute[i])
  }
}
#lutlength1_impute is the imputed value of luteal phase based on NC norms, but lagged one day so it does align with any dates in the follicuar phase 
dat$lutlength1_impute = lag(dat$lutlength_impute)

#check data
dat %>% select(id, daterated, ovtoday_impute, A, lutdaycount_impute, lutmax_impute, lutlength_impute, lutlength1_impute)

#calculate lutperc_impute
dat <- dat %>%
  mutate(lutperc_impute = if_else(
    is.na(lutlength1_impute),
    NA,
    if_else(
      is.na(lutlength1_impute) &
        !is.na(lutmax_impute) & cycle_incomplete == 0,
      lutdaycount_impute / lutmax_impute,
      lutdaycount_impute / round(lutlength1_impute)
    )
  ))

#lutperc is scaled from 0 to 1, so substracting 1 so that it is scaled from -1 to 0 for menses-centered scaled_cycleday 
dat$perclut_impute = dat$lutperc_impute -1 

#check data
dat %>% select(id, daterated, ovtoday_impute, A, mcyclength, perclut_impute, perclut) 

#calculate lutdaycount_imp_ov, which is imputed lutdaycount but ovulation-centered 
dat <- dat %>%
  group_by(id) %>%
  mutate(
    lutdaycount_imp_ov = lead(lutdaycount_impute),
    lutdaycount_imp_ov = case_when(
      is.na(lutdaycount_imp_ov) | id != lead(id) ~ NA, 
      TRUE ~ lutdaycount_imp_ov
    )
  )

#calculate lutperc_imp_ov which is the variable that will go into ovulation-centered scaled cycleday 
dat <- dat %>%
  mutate(perclut_imp_ov = if_else(
    is.na(lutlength1_impute) ,
    NA,
    if_else(
      is.na(lutlength1_impute) & !is.na(lutmax) & cycle_incomplete == 0,
      lutdaycount1 / lutmax_impute,
      lutdaycount1 / round(lutlength1_impute)
    )
  ))


#if ovtoday_impute == 1, set lutperc_imp_ov to 0
# dat <- dat %>%
#   mutate(perclut_imp_ov = ifelse(ovtoday_impute == 1, 0, perclut_imp_ov))

#check data 
dat %>% select(id, daterated, ovtoday_impute, A, lutdaycount, lutlength1_impute, lutdaycount1, lutmax_impute, perclut_impute, perclut_imp_ov)

#remove helper variables
dat <- dat %>% select (-c(lutperc_impute, lutdaycount1))
```

# percentage of follicular phase using ovtoday (LH+1)

```{r}
# Check for missing values
table(dat$id)
table(dat$ovtoday)

#remove obs with missing id or ovtoday
dat <- dat %>%
  filter(!is.na(id) & !is.na(ovtoday))

# Ensure daterated is in order by id and initialize folmax variable
dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax = NA)

#make sure daterated is in order by id, and initialize folmax variable 
dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax = NA)

#apply calculate foldaycount function using ovtoday 
dat <- calculate_foldaycount(dat, dat$ovtoday)

#foldaycount forward counts starting at menses onset and ends at ovtoday 
dat %>% select(id, daterated, A, ovtoday, foldaycount)

#assigns folmax as the max value of foldaycount within a cycle 
for (i in 1:(nrow(dat)-1)) {
  if (is.na(dat$foldaycount[i + 1] && !is.na(dat$foldaycount[i]))) {
    dat$folmax[(i-(dat$foldaycount[i])):i] = as.numeric(dat$foldaycount[i])
  }
}

#follength is the length of the follicular phase that cycle (since folmax is indexed at 0)
dat$follength = dat$folmax + 1 

#check data
dat %>% select(id, daterated, ovtoday, A, foldaycount, folmax, follength, fol_incomplete)

dat <- dat %>%
  mutate(percfol = ifelse(fol_incomplete != 1, foldaycount / (folmax), NA))

dat$percfol_ov = dat$percfol - 1

dat %>% select(id, daterated, ovtoday, A, foldaycount, folmax, percfol, percfol_ov)

#renaming foldaycount based on ovtoday to be called foldaycount_ov. the variable name 'foldaycount' get overwritten in the code chunk below when the calculate_foldaycount() function is run 
dat <- dat %>% rename(foldaycount_ov = foldaycount)

```

# percentage of follicular phase using ovtoday_impute (based on NC norms)

```{r}

#yes, I'm constantly arranging by daterated because I'm paranoid. Initialize the variable folmax_impute 
dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax_impute = NA)
#see comment on line 512
dat <- calculate_foldaycount(dat, dat$ovtoday_impute)
dat <- dat %>% rename(foldaycount_impute = foldaycount)
dat %>% select(id, daterated, ovtoday_impute, A, foldaycount_impute)

#create folmax_impute which is the max value of foldaycount_impute and matches the imputed follicular length in complete cycles 
for (i in 1:(nrow(dat)-1)) {
  if (is.na(dat$foldaycount_impute[i + 1] && !is.na(dat$foldaycount_impute[i]))) {
    dat$folmax_impute[(i-(dat$foldaycount_impute[i])):i] = as.numeric(dat$foldaycount_impute[i])
  }
}

dat <- dat %>%
  mutate(percfol_impute = ifelse(cycle_incomplete == 0, foldaycount_impute / (folmax_impute), NA))

# ovulation-centered percfol based on ovtoday_impute 
dat$percfol_imp_ov = dat$percfol_impute - 1


dat %>% select(id, daterated, ovtoday_impute, A, percfol_impute, percfol_imp_ov)
```




# prioritize LH test-based scaled values over imputed values 

```{r}

#functions to prioritize perc_base over perc

create_percent <- function(dat, percentvar, percvar, percvar_impute) {
  percentvar <- ensym(percentvar)
  percvar <- ensym(percvar)
  percvar_impute <- ensym(percvar_impute)
  
  dat %>%
    group_by(id, cyclenum) %>%
    mutate(
      !!percentvar := if (all(is.na(!!percvar) | !!percvar == 0)) {
        # if percvar contains only NA or 0, use percvar_impute
        !!percvar_impute
      } else {
        # otherwise, use percvar
        !!percvar
      }
    ) %>%
    ungroup()
}


dat = create_percent(dat, percentlut, perclut, perclut_impute)
dat = create_percent(dat, percentfol, percfol, percfol_impute)
dat = create_percent(dat, percentlut_ov, perclut_ov, perclut_imp_ov)
dat = create_percent(dat, percentfol_ov, percfol_ov, percfol_imp_ov)

dat %>% select(id, daterated, A, ovtoday, ovtoday_impute, cyclenum, mcyclength, percfol, percfol_impute, percentlut_ov)
```


# creating scaled_cycleday 

```{r}

dat <- dat %>%
  mutate(scaled_cycleday = ifelse(is.na(percentlut), percentfol, percentlut))
dat %>% select(id, daterated, percentlut, percentfol, scaled_cycleday)

```

# creating scaled_cycleday_ov

```{r}
dat <- dat %>%
  mutate(scaled_cycleday_ov = ifelse(is.na(percentlut_ov), percentfol_ov, percentlut_ov))
dat %>% select(id, daterated, percentlut_ov, percentfol_ov, scaled_cycleday_ov)

```


## Rounding Percents for LUTEAL-FOLLICULAR ORDER

```{r}

dat <- dat %>%
  mutate(cycleday_perc = (scaled_cycleday + 1) / 2) %>%
  mutate(cycleday_perc_round = round(cycleday_perc, 1)) %>%
  mutate(cycleday_10perc = round(cycleday_perc / 0.10) * 0.10) %>%
  mutate(cycleday_2perc = round(cycleday_perc / 0.02) * 0.02)


```


## Rounding Percents for FOLLICULAR-LUTEAL ORDER

```{r}

dat <- dat %>%
  mutate(cycledayov_perc = (scaled_cycleday_ov + 1) / 2) %>%
  mutate(cycledayov_perc_round = round(cycledayov_perc, 1)) %>%
  mutate(cycledayov_10perc = round(cycledayov_perc / 0.10) * 0.10) %>%
  mutate(cycledayov_2perc = round(cycledayov_perc / 0.02) * 0.02)


```


#RE-CALCULATE DEVATIONS AND STD AND ROLLING AVGS


```{r}

#create rolling averages on RAW variables
for (i in outcomelist) {
  dat <- create.3day.rolling.avg(dat, !!sym({{i}}), 3)
}

#MEANS

#execute for loop: run create.person.mean() on everything in "outcomelist.roll"
for (i in outcomelist.roll) {
  dat <- create.person.mean(dat, !!sym({{i}}), id)
}

#execute for loop: run create.person.mean() on everything in "outcomelist"
for (i in outcomelist) {
  dat <- create.person.mean(dat, !!sym({{i}}), id)
}

#PERSON-DEVIATIONS

#for raw deviations
#execute for loop: run create.deviation() on everything in list
for (i in outcomelist) {
  dat <- create.deviation(dat, !!sym({{i}}), !!sym(paste0({{i}}, ".m")))
}

#for rolling avgs deviations
#execute for loop: run create.deviation() on everything in list
for (i in outcomelist.roll) {
  dat <- create.deviation(dat, !!sym({{i}}), !!sym(paste0({{i}}, ".m")))
}


#Check 
#dat %>% select(id, E2, E2.m, E2.d, E2.roll, E2.roll.d) %>% View()

```

# 2024-09-25 - PLOTS - LUTEAL then FOLLICULAR - (OVULATION to OVULATION)
```{r}

# Define the folder location for saving the plots
output_folder <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-09-25"

# Define the function to generate plots for a list of DVs
plot_DVs <- function(DV_list, dat) {
  
  # Create person-standardized (z-scored within each participant) versions of each DV
  for (DV in DV_list) {
    zd_var <- paste0(DV, ".zd")  # Name for the person-standardized version
    
    # Add the person-standardized columns for each DV
    dat <- dat %>%
      group_by(id) %>%
      mutate(!!zd_var := scale(!!sym(DV), center = TRUE, scale = TRUE)) %>%
      ungroup()
  }
  
  # Calculate person-rescaled E2 and P4 (scaled within each person, sd = 0.5)
  dat <- dat %>%
    group_by(id) %>%
    mutate(E2.rescale = scale(E2, center = TRUE, scale = sd(E2, na.rm=TRUE)/0.5), #changed here
           P4.rescale = scale(P4, center = TRUE, scale = sd(P4, na.rm=TRUE)/0.5)) %>% #changed here
    ungroup()
  
  # Indicators for menstrual bleeding
  bleeding_indicator <- data.frame(xmin = .5, xmax = 0.7, ymin = -Inf, ymax = Inf)
  
  for (DV in DV_list) {
    
    if (DV %in% c("E2", "P4", "LH")) {
      # Raw plot for E2, P4, LH
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p1 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.1) +
        geom_point(size = 1) +
        geom_line(size = 1) +
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      ggsave(filename = paste0(output_folder, "/", DV, "_", "raw", ".png"), plot = last_plot(), width = 8, height = 6)

      
    } else {
      # For DVs that are NOT E2, P4, LH
      
      # Raw data points and line for the dependent variable
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
    # Person-rescaled E2 and P4 lines (thin dotted)  <- Changed variable names here
      e2_std <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(E2.rescale, na.rm = TRUE)) #changed here

      p4_std <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(P4.rescale, na.rm = TRUE))  #changed here
      
      p1 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # Thin dotted lines for E2 and P4
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      # Deviations plot
      dev_var <- paste0(DV, ".d")
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p2 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p2)
      
            ggsave(filename = paste0(output_folder, "/", DV, "_", "dev", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Person-standardized outcome (zd)
      zd_var <- paste0(DV, ".zd")
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(zd_var), na.rm = TRUE),
                  se_value = sd(!!sym(zd_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p3 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
                  linetype = "solid", color = "forestgreen", size = 1, alpha = 0.9) +  # E2
        geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
                  linetype = "solid", color = "red", size = 1, alpha = 0.8) +  # P4
        ggtitle(paste("Person-standardized", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Person-standardized Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p3)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "zd", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Rolling deviations plot
      roll_dev_var <- paste0(DV, ".roll.d")
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(roll_dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(roll_dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p4 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Rolling Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Rolling Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p4)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "rolld", ".png"), plot = last_plot(), width = 8, height = 6)

    }
  }
}

# Call the function with the list of dependent variables (DVs)
DVs <- c("E2", "P4", "LH", "CSS_Inatt", "CSS_Inatt_Count", "CSS_HypImp", "CSS_HypImp_Count",
         "CSS_Fx_Total", "CSS_B2_Total", "UPPS_Total", "BDEFS_Total", "DEBQ_Total")

plot_DVs(DVs, dat)





```

# 2024-09-25 - PLOTS - FOLLICULAR then LUTEAL - (MENSES to MENSES)
## NOTE: These plots aren't looking right yet. Need to figure out if I'm losing observations somewhere. - taem, 20240925
```{r}

# Define the folder location for saving the plots
output_folder <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-09-25"

# Define the function to generate plots for a list of DVs
plot_DVs_M2M <- function(DV_list, dat) {
  
  # Create person-standardized (z-scored within each participant) versions of each DV
  for (DV in DV_list) {
    zd_var <- paste0(DV, ".zd")  # Name for the person-standardized version
    
    # Add the person-standardized columns for each DV
    dat <- dat %>%
      group_by(id) %>%
      mutate(!!zd_var := scale(!!sym(DV), center = TRUE, scale = TRUE)) %>%
      ungroup()
  }
  
  # Calculate person-rescaled E2 and P4 (scaled within each person, sd = 0.5)
  dat <- dat %>%
    group_by(id) %>%
    mutate(E2.rescale = scale(E2, center = TRUE, scale = sd(E2, na.rm=TRUE)/0.5), #changed here
           P4.rescale = scale(P4, center = TRUE, scale = sd(P4, na.rm=TRUE)/0.5)) %>% #changed here
    ungroup()
  
  # Indicators for menstrual bleeding
  bleeding_indicator <- data.frame(xmin = 0, xmax = 0.2, ymin = -Inf, ymax = Inf)
  
  for (DV in DV_list) {
    
    if (DV %in% c("E2", "P4", "LH")) {
      # Raw plot for E2, P4, LH
      dv <- dat %>%
        group_by(cycledayov_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p1 <- ggplot(dv, aes(x = cycledayov_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.1) +
        geom_point(size = 1) +
        geom_line(size = 1) +
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      ggsave(filename = paste0(output_folder, "/", DV, "_", "ov_", ".png"), plot = last_plot(), width = 8, height = 6)

      
    } else {
      # For DVs that are NOT E2, P4, LH
      
      # Raw data points and line for the dependent variable
      dv <- dat %>%
        group_by(cycledayov_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
    # Person-rescaled E2 and P4 lines (thin dotted)  <- Changed variable names here
      e2_std <- dat %>%
        group_by(cycledayov_10perc) %>%
        summarise(mean_value = mean(E2.rescale, na.rm = TRUE)) #changed here

      p4_std <- dat %>%
        group_by(cycledayov_10perc) %>%
        summarise(mean_value = mean(P4.rescale, na.rm = TRUE))  #changed here
      
      p1 <- ggplot(dv, aes(x = cycledayov_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # Thin dotted lines for E2 and P4
        # geom_line(data = e2_std, aes(x = cycledayov_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycledayov_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      # Deviations plot
      dev_var <- paste0(DV, ".d")
      dv <- dat %>%
        group_by(cycledayov_10perc) %>%
        summarise(mean_value = mean(!!sym(dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p2 <- ggplot(dv, aes(x = cycledayov_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = e2_std, aes(x = cycledayov_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycledayov_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p2)
      
            ggsave(filename = paste0(output_folder, "/", DV, "_", "ov_dev", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Person-standardized outcome (zd)
      zd_var <- paste0(DV, ".zd")
      dv <- dat %>%
        group_by(cycledayov_10perc) %>%
        summarise(mean_value = mean(!!sym(zd_var), na.rm = TRUE),
                  se_value = sd(!!sym(zd_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p3 <- ggplot(dv, aes(x = cycledayov_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        geom_line(data = e2_std, aes(x = cycledayov_10perc, y = mean_value), 
                  linetype = "solid", color = "forestgreen", size = 1, alpha = 0.9) +  # E2
        geom_line(data = p4_std, aes(x = cycledayov_10perc, y = mean_value), 
                  linetype = "solid", color = "red", size = 1, alpha = 0.8) +  # P4
        ggtitle(paste("Person-standardized", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Person-standardized Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p3)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "ov_zd", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Rolling deviations plot
      roll_dev_var <- paste0(DV, ".roll.d")
      dv <- dat %>%
        group_by(cycledayov_10perc) %>%
        summarise(mean_value = mean(!!sym(roll_dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(roll_dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p4 <- ggplot(dv, aes(x = cycledayov_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = e2_std, aes(x = cycledayov_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycledayov_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Rolling Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Rolling Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p4)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "ov_rolld", ".png"), plot = last_plot(), width = 8, height = 6)

    }
  }
}

# Call the function with the list of dependent variables (DVs)
DVs <- c("E2", "P4", "LH", "CSS_Inatt", "CSS_Inatt_Count", "CSS_HypImp", "CSS_HypImp_Count",
         "CSS_Fx_Total", "CSS_B2_Total", "UPPS_Total", "BDEFS_Total", "DEBQ_Total")

plot_DVs_M2M(DVs, dat)



```





# FITTING GAMMs 

```{r}
library(mgcv)
library(marginaleffects)

gam3ahsd2 <- gam(x3a_hsd2.w.log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re") + s(scaled_cycleday, k = 20), data = dat3ahsd2, method = "REML")

summary(gam3ahsd2)

plot.gam(gam3ahsd2, select = 3)

dat3ahsd2plot <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gam3ahsd2, newdata = dat3ahsd2plot, type = "response", transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 
dat3ahsd2plot$estimate = pred$estimate
dat3ahsd2plot$conf.low = pred$conf.low
dat3ahsd2plot$conf.high = pred$conf.high


# Plotting
x3ahsd2plot <- ggplot(dat3ahsd2plot, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "3a hsd2") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

x3ahsd2plot
```

# Fitting Scaled CycleDay GAMMs
```{r}
library(mgcv)
library(marginaleffects)

#dat$daysinstudy <- as.numeric(dat$TubeNumber)

```

# GAMM and initial plot - E2 - Ov to Ov
```{r}

hist(dat$E2)
dat$E2log <- log(dat$E2+1)
hist(dat$E2log)

gamm_e2 <- gam(E2log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re") + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_e2)

plot.gam(gamm_e2, select = 3)
```

# Model-Implied Plot - E2 - Ov to Ov
```{r}

e2dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_e2, newdata = e2dat, type = "response", transform = function(x) exp(x) - 1)

#don't need to include anything for 'transform' if your outcome is not log-transformed. This undoes the logtransform so model-implied values are not on the log scale 

e2dat$estimate = pred$estimate
e2dat$conf.low = pred$conf.low
e2dat$conf.high = pred$conf.high


# Plotting
e2plot <- ggplot(e2dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Salivary Estradiol") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

e2plot
```

# GAMM and initial plot - E2 - M2M
```{r}

hist(dat$E2)
dat$E2log <- log(dat$E2+1)
hist(dat$E2log)

gamm_e2_m2m <- gam(E2log ~ s(id, bs = "re") + s(scaled_cycleday_ov, id, bs = "re") + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_e2_m2m)

plot.gam(gamm_e2_m2m, select = 3)
```




# GAMM and initial plot - LH
```{r}
hist(dat$LH)
dat$LHlog <- log(dat$LH+1)
hist(dat$LHlog)
gamm_LH <- gam(LHlog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_LH)

plot.gam(gamm_LH, select = 3)

hist(dat$LH)
```


# Model-Implied Plot - LH
```{r}

LHdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_LH, newdata = LHdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

LHdat$estimate = pred$estimate
LHdat$conf.low = pred$conf.low
LHdat$conf.high = pred$conf.high

# Plotting
LHplot <- ggplot(LHdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "LH") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

LHplot
```


# GAMM and initial plot - P4
```{r}
hist(dat$P4)
dat$P4log <- log(dat$P4+1)
hist(dat$P4log)

gamm_p4 <- gam(P4log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 10), data = dat, method = "REML")

summary(gamm_p4)

plot.gam(gamm_p4, select = 3)

```

# Model-Implied Plot - P4
```{r}

P4dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_p4, newdata = P4dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

P4dat$estimate = pred$estimate
P4dat$conf.low = pred$conf.low
P4dat$conf.high = pred$conf.high


# Plotting
P4plot <- ggplot(P4dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Salivary P4") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

P4plot
```



# GAMM and initial plot - Inatt
```{r}

hist(dat$CSS_Inatt)
dat$CSS_Inattlog <- log(dat$CSS_Inatt+1)
hist(dat$CSS_Inattlog)

gamm_CSS_Inatt <- gam(CSS_Inattlog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re") + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_CSS_Inatt)

plot.gam(gamm_CSS_Inatt, select = 3)

```


# Model-Implied Plot - Inatt
```{r}

CSS_Inattdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_CSS_Inatt, newdata = CSS_Inattdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

CSS_Inattdat$estimate = pred$estimate
CSS_Inattdat$conf.low = pred$conf.low
CSS_Inattdat$conf.high = pred$conf.high


# Plotting
CSS_Inattplot <- ggplot(CSS_Inattdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "CSS Inattention Symptoms") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

CSS_Inattplot
```






# GAMM and initial plot - HypImp
```{r}


hist(dat$CSS_HypImp)
dat$CSS_HypImplog <- log(dat$CSS_HypImp+1)
hist(dat$CSS_HypImplog)

gamm_CSS_HypImp <- gam(CSS_HypImplog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re") + s(scaled_cycleday, k = 30), data = dat, method = "REML")

summary(gamm_CSS_HypImp)

plot.gam(gamm_CSS_HypImp, select = 3)

hist(dat$CSS_HypImp)
```

# Model-Implied Plot - HypImp
```{r}

CSS_HypImpdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_CSS_HypImp, newdata = CSS_HypImpdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

CSS_HypImpdat$estimate = pred$estimate
CSS_HypImpdat$conf.low = pred$conf.low
CSS_HypImpdat$conf.high = pred$conf.high


# Plotting
CSS_HypImpplot <- ggplot(CSS_HypImpdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "CSS Hyperactivity/Impulsivity") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

CSS_HypImpplot
```
  # Calculate Inattention Severity: 
    CSS_Inatt = rowSums(across(c(CSS_B_1, CSS_B_3, CSS_B_5, CSS_B_7, CSS_B_9, CSS_B_11, CSS_B_13, CSS_B_15, CSS_B_17)), na.rm = TRUE),
    
    # Calculate Hyperactivity/Impulsivity Severity: 
    CSS_HypImp = rowSums(across(c(CSS_B_2, CSS_B_4, CSS_B_6, CSS_B_8, CSS_B_10, CSS_B_12, CSS_B_14, CSS_B_16, CSS_B_18)), na.rm = TRUE),
    
    # Function items 1-10
    CSS_Fx_Total = rowSums(across(starts_with("CSS_Function_")), na.rm = TRUE),
    
    # Not sure what this is (todo)
    CSS_B2_Total = rowSums(across(starts_with("CSS_B2_")), na.rm = TRUE),
    
    # CSS Count Variables
    CSS_Inatt_Count = rowSums(across(c(CSS_1_Count, CSS_3_Count, CSS_5_Count, CSS_7_Count, CSS_9_Count, CSS_11_Count, CSS_13_Count, CSS_15_Count, CSS_17_Count)), na.rm = TRUE),
    
    CSS_HypImp_Count = rowSums(across(c(CSS_2_Count, CSS_4_Count, CSS_6_Count, CSS_8_Count, CSS_10_Count, CSS_12_Count, CSS_14_Count, CSS_16_Count, CSS_18_Count)), na.rm = TRUE),
    
    # Other Daily Scored Scales
    DEBQ_Total = rowSums(across(starts_with("DEBQ_")), na.rm = TRUE),
    BDEFS_Total = rowSums(across(starts_with("BDEFS_")), na.rm = TRUE),
    UPPS_Total = rowSums(across(starts_with("UPPS_")), na.rm = TRUE)


# GAMM and initial plot - Inatt Sx Count
```{r}
hist(dat$CSS_Inatt_Count)
dat$CSS_Inatt_Countlog <- log(dat$CSS_Inatt_Count+1)
hist(dat$CSS_Inatt_Countlog)

gamm_CSS_Inatt_Count <- gam(CSS_Inatt_Countlog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_CSS_Inatt_Count)

plot.gam(gamm_CSS_Inatt_Count, select = 3)

hist(dat$CSS_Inatt_Count)
```


# Model-Implied Plot - Inatt Sx Count
```{r}

CSS_Inatt_Countdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_CSS_Inatt_Count, newdata = CSS_Inatt_Countdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

CSS_Inatt_Countdat$estimate = pred$estimate
CSS_Inatt_Countdat$conf.low = pred$conf.low
CSS_Inatt_Countdat$conf.high = pred$conf.high

# Plotting
CSS_Inatt_Countplot <- ggplot(CSS_Inatt_Countdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "CSS Inattention Sx Count") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

CSS_Inatt_Countplot
```




# GAMM and initial plot - HypImp Count
```{r}
hist(dat$CSS_HypImp_Count)
dat$CSS_HypImp_Countlog <- log(dat$CSS_HypImp_Count+1)
hist(dat$CSS_HypImp_Countlog)
gamm_CSS_HypImp_Count <- gam(CSS_HypImp_Countlog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_CSS_HypImp_Count)

plot.gam(gamm_CSS_HypImp_Count, select = 3)

hist(dat$CSS_HypImp_Count)
```


# Model-Implied Plot - TEMPLATE
```{r}

CSS_HypImp_Countdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_CSS_HypImp_Count, newdata = CSS_HypImp_Countdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

CSS_HypImp_Countdat$estimate = pred$estimate
CSS_HypImp_Countdat$conf.low = pred$conf.low
CSS_HypImp_Countdat$conf.high = pred$conf.high

# Plotting
CSS_HypImp_Countplot <- ggplot(CSS_HypImp_Countdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "CSS_HypImp_Count") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

CSS_HypImp_Countplot
```



# GAMM and initial plot - CSS_Fx_Total
```{r}
hist(dat$CSS_Fx_Total)
dat$CSS_Fx_Totallog <- log(dat$CSS_Fx_Total+1)
hist(dat$CSS_Fx_Totallog)
gamm_CSS_Fx_Total <- gam(CSS_Fx_Totallog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_CSS_Fx_Total)

plot.gam(gamm_CSS_Fx_Total, select = 3)

hist(dat$CSS_Fx_Total)
```


# Model-Implied Plot - CSS_Fx_Total
```{r}

CSS_Fx_Totaldat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_CSS_Fx_Total, newdata = CSS_Fx_Totaldat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

CSS_Fx_Totaldat$estimate = pred$estimate
CSS_Fx_Totaldat$conf.low = pred$conf.low
CSS_Fx_Totaldat$conf.high = pred$conf.high

# Plotting
CSS_Fx_Totalplot <- ggplot(CSS_Fx_Totaldat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "CSS_Fx_Total") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

CSS_Fx_Totalplot
```
# GAMM and initial plot - CSS_B2_Total
```{r}
hist(dat$CSS_B2_Total)
dat$CSS_B2_Totallog <- log(dat$CSS_B2_Total+1)
hist(dat$CSS_B2_Totallog)
gamm_CSS_B2_Total <- gam(CSS_B2_Totallog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_CSS_B2_Total)

plot.gam(gamm_CSS_B2_Total, select = 3)

hist(dat$CSS_B2_Total)
```


# Model-Implied Plot - CSS_B2_Total
```{r}

CSS_B2_Totaldat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_CSS_B2_Total, newdata = CSS_B2_Totaldat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

CSS_B2_Totaldat$estimate = pred$estimate
CSS_B2_Totaldat$conf.low = pred$conf.low
CSS_B2_Totaldat$conf.high = pred$conf.high

# Plotting
CSS_B2_Totalplot <- ggplot(CSS_B2_Totaldat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "CSS_B2_Total") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

CSS_B2_Totalplot
```

# GAMM and initial plot - BDEFS_Total
```{r}
hist(dat$BDEFS_Total)
dat$BDEFS_Totallog <- log(dat$BDEFS_Total+1)
hist(dat$BDEFS_Totallog)
gamm_BDEFS_Total <- gam(BDEFS_Totallog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_BDEFS_Total)

plot.gam(gamm_BDEFS_Total, select = 3)

hist(dat$BDEFS_Total)
```


# Model-Implied Plot - BDEFS_Total
```{r}

BDEFS_Totaldat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_BDEFS_Total, newdata = BDEFS_Totaldat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

BDEFS_Totaldat$estimate = pred$estimate
BDEFS_Totaldat$conf.low = pred$conf.low
BDEFS_Totaldat$conf.high = pred$conf.high

# Plotting
BDEFS_Totalplot <- ggplot(BDEFS_Totaldat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "BDEFS_Total") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

BDEFS_Totalplot
```


# GAMM and initial plot - UPPS_Total
```{r}
hist(dat$UPPS_Total)
dat$UPPS_Totallog <- log(dat$UPPS_Total+1)
hist(dat$UPPS_Totallog)
gamm_UPPS_Total <- gam(UPPS_Totallog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_UPPS_Total)

plot.gam(gamm_UPPS_Total, select = 3)

hist(dat$UPPS_Total)
```


# Model-Implied Plot - UPPS_Total
```{r}

UPPS_Totaldat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_UPPS_Total, newdata = UPPS_Totaldat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

UPPS_Totaldat$estimate = pred$estimate
UPPS_Totaldat$conf.low = pred$conf.low
UPPS_Totaldat$conf.high = pred$conf.high

# Plotting
UPPS_Totalplot <- ggplot(UPPS_Totaldat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "UPPS_Total") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

UPPS_Totalplot
```


# GAMM and initial plot - DEBQ_Total
```{r}
hist(dat$DEBQ_Total)
dat$DEBQ_Totallog <- log(dat$DEBQ_Total+1)
hist(dat$DEBQ_Totallog)
gamm_DEBQ_Total <- gam(DEBQ_Totallog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DEBQ_Total)

plot.gam(gamm_DEBQ_Total, select = 3)

hist(dat$DEBQ_Total)
```


# Model-Implied Plot - DEBQ_Total
```{r}

DEBQ_Totaldat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DEBQ_Total, newdata = DEBQ_Totaldat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DEBQ_Totaldat$estimate = pred$estimate
DEBQ_Totaldat$conf.low = pred$conf.low
DEBQ_Totaldat$conf.high = pred$conf.high

# Plotting
DEBQ_Totalplot <- ggplot(DEBQ_Totaldat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "DEBQ_Total") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DEBQ_Totalplot
```

# GAMM and initial plot - longstring
```{r}
hist(dat$longstring)
dat$longstringlog <- log(dat$longstring+1)
hist(dat$longstringlog)
gamm_longstring <- gam(longstringlog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_longstring)

plot.gam(gamm_longstring, select = 3)

hist(dat$longstring)
```


# Model-Implied Plot - longstring
```{r}

longstringdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_longstring, newdata = longstringdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

longstringdat$estimate = pred$estimate
longstringdat$conf.low = pred$conf.low
longstringdat$conf.high = pred$conf.high

# Plotting
longstringplot <- ggplot(longstringdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "longstring") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

longstringplot
```

# GAMM and initial plot - BDEFS_WM_avg
```{r}
hist(dat$BDEFS_WM_avg)
dat$BDEFS_WM_avglog <- log(dat$BDEFS_WM_avg+1)
hist(dat$BDEFS_WM_avglog)
gamm_BDEFS_WM_avg <- gam(BDEFS_WM_avglog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_BDEFS_WM_avg)

plot.gam(gamm_BDEFS_WM_avg, select = 3)

hist(dat$BDEFS_WM_avg)
```


# Model-Implied Plot - BDEFS_WM_avg
```{r}

BDEFS_WM_avgdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_BDEFS_WM_avg, newdata = BDEFS_WM_avgdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

BDEFS_WM_avgdat$estimate = pred$estimate
BDEFS_WM_avgdat$conf.low = pred$conf.low
BDEFS_WM_avgdat$conf.high = pred$conf.high

# Plotting
BDEFS_WM_avgplot <- ggplot(BDEFS_WM_avgdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "BDEFS_WM_avg") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

BDEFS_WM_avgplot
```


# GAMM and initial plot - BDEFS_RI_avg
```{r}
hist(dat$BDEFS_RI_avg)
dat$BDEFS_RI_avglog <- log(dat$BDEFS_RI_avg+1)
hist(dat$BDEFS_RI_avglog)
gamm_BDEFS_RI_avg <- gam(BDEFS_RI_avglog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_BDEFS_RI_avg)

plot.gam(gamm_BDEFS_RI_avg, select = 3)

hist(dat$BDEFS_RI_avg)
```


# Model-Implied Plot - BDEFS_RI_avg
```{r}

BDEFS_RI_avgdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_BDEFS_RI_avg, newdata = BDEFS_RI_avgdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

BDEFS_RI_avgdat$estimate = pred$estimate
BDEFS_RI_avgdat$conf.low = pred$conf.low
BDEFS_RI_avgdat$conf.high = pred$conf.high

# Plotting
BDEFS_RI_avgplot <- ggplot(BDEFS_RI_avgdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "BDEFS_RI_avg") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

BDEFS_RI_avgplot
```


# GAMM and initial plot - UPPS_NU_avg
```{r}
hist(dat$UPPS_NU_avg)
dat$UPPS_NU_avglog <- log(dat$UPPS_NU_avg+1)
hist(dat$UPPS_NU_avglog)
gamm_UPPS_NU_avg <- gam(UPPS_NU_avglog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_UPPS_NU_avg)

plot.gam(gamm_UPPS_NU_avg, select = 3)

hist(dat$UPPS_NU_avg)
```


# Model-Implied Plot - UPPS_NU_avg
```{r}

UPPS_NU_avgdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_UPPS_NU_avg, newdata = UPPS_NU_avgdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

UPPS_NU_avgdat$estimate = pred$estimate
UPPS_NU_avgdat$conf.low = pred$conf.low
UPPS_NU_avgdat$conf.high = pred$conf.high

# Plotting
UPPS_NU_avgplot <- ggplot(UPPS_NU_avgdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "UPPS_NU_avg") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

UPPS_NU_avgplot
```


# GAMM and initial plot - UPPS_Persev_avg
```{r}
hist(dat$UPPS_Persev_avg)
dat$UPPS_Persev_avglog <- log(dat$UPPS_Persev_avg+1)
hist(dat$UPPS_Persev_avglog)
gamm_UPPS_Persev_avg <- gam(UPPS_Persev_avglog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_UPPS_Persev_avg)

plot.gam(gamm_UPPS_Persev_avg, select = 3)

hist(dat$UPPS_Persev_avg)
```


# Model-Implied Plot - TEMPLATE
```{r}

UPPS_Persev_avgdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_UPPS_Persev_avg, newdata = UPPS_Persev_avgdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

UPPS_Persev_avgdat$estimate = pred$estimate
UPPS_Persev_avgdat$conf.low = pred$conf.low
UPPS_Persev_avgdat$conf.high = pred$conf.high

# Plotting
UPPS_Persev_avgplot <- ggplot(UPPS_Persev_avgdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "UPPS_Persev_avg") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

UPPS_Persev_avgplot
```

# GAMM and initial plot - UPPS_Premed_avg
```{r}
hist(dat$UPPS_Premed_avg)
dat$UPPS_Premed_avglog <- log(dat$UPPS_Premed_avg+1)
hist(dat$UPPS_Premed_avglog)
gamm_UPPS_Premed_avg <- gam(UPPS_Premed_avglog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_UPPS_Premed_avg)

plot.gam(gamm_UPPS_Premed_avg, select = 3)

hist(dat$UPPS_Premed_avg)
```


# Model-Implied Plot - UPPS_Premed_avg
```{r}

UPPS_Premed_avgdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_UPPS_Premed_avg, newdata = UPPS_Premed_avgdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

UPPS_Premed_avgdat$estimate = pred$estimate
UPPS_Premed_avgdat$conf.low = pred$conf.low
UPPS_Premed_avgdat$conf.high = pred$conf.high

# Plotting
UPPS_Premed_avgplot <- ggplot(UPPS_Premed_avgdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "UPPS_Premed_avg") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

UPPS_Premed_avgplot
```

# GAMM and initial plot - UPPS_Sens_avg
```{r}
hist(dat$UPPS_Sens_avg)
dat$UPPS_Sens_avglog <- log(dat$UPPS_Sens_avg+1)
hist(dat$UPPS_Sens_avglog)
gamm_UPPS_Sens_avg <- gam(UPPS_Sens_avglog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_UPPS_Sens_avg)

plot.gam(gamm_UPPS_Sens_avg, select = 3)

hist(dat$UPPS_Sens_avg)
```


# Model-Implied Plot - UPPS_Sens_avg
```{r}

UPPS_Sens_avgdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_UPPS_Sens_avg, newdata = UPPS_Sens_avgdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

UPPS_Sens_avgdat$estimate = pred$estimate
UPPS_Sens_avgdat$conf.low = pred$conf.low
UPPS_Sens_avgdat$conf.high = pred$conf.high

# Plotting
UPPS_Sens_avgplot <- ggplot(UPPS_Sens_avgdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "UPPS_Sens_avg") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

UPPS_Sens_avgplot
```


# GAMM and initial plot - UPPS_PU_avg
```{r}
hist(dat$UPPS_PU_avg)
dat$UPPS_PU_avglog <- log(dat$UPPS_PU_avg+1)
hist(dat$UPPS_PU_avglog)
gamm_UPPS_PU_avg <- gam(UPPS_PU_avglog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_UPPS_PU_avg)

plot.gam(gamm_UPPS_PU_avg, select = 3)

hist(dat$UPPS_PU_avg)
```


# Model-Implied Plot - UPPS_PU_avg
```{r}

UPPS_PU_avgdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_UPPS_PU_avg, newdata = UPPS_PU_avgdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

UPPS_PU_avgdat$estimate = pred$estimate
UPPS_PU_avgdat$conf.low = pred$conf.low
UPPS_PU_avgdat$conf.high = pred$conf.high

# Plotting
UPPS_PU_avgplot <- ggplot(UPPS_PU_avgdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "UPPS_PU_avg") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

UPPS_PU_avgplot
```

# GAMM and initial plot - score_pinball
```{r}
hist(dat$score_pinball)
dat$score_pinballlog <- log(dat$score_pinball+1)
hist(dat$score_pinballlog)
gamm_score_pinball <- gam(score_pinballlog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_score_pinball)

plot.gam(gamm_score_pinball, select = 3)

hist(dat$score_pinball)
```


# Model-Implied Plot - score_pinball
```{r}

score_pinballdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_score_pinball, newdata = score_pinballdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

score_pinballdat$estimate = pred$estimate
score_pinballdat$conf.low = pred$conf.low
score_pinballdat$conf.high = pred$conf.high

# Plotting
score_pinballplot <- ggplot(score_pinballdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "score_pinball") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

score_pinballplot
```



# GAMM and initial plot - score_robot
```{r}
hist(dat$score_robot)
dat$score_robotlog <- log(dat$score_robot+1)
hist(dat$score_robotlog)
gamm_score_robot <- gam(score_robotlog ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_score_robot)

plot.gam(gamm_score_robot, select = 3)

hist(dat$score_robot)
```


# Model-Implied Plot - score_robot
```{r}

score_robotdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_score_robot, newdata = score_robotdat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

score_robotdat$estimate = pred$estimate
score_robotdat$conf.low = pred$conf.low
score_robotdat$conf.high = pred$conf.high

# Plotting
score_robotplot <- ggplot(score_robotdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "score_robot") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

score_robotplot
```



# GAMM and initial plot - DRSP_1
```{r}
hist(dat$DRSP_1)
dat$DRSP_1log <- log(dat$DRSP_1+1)
hist(dat$DRSP_1log)
gamm_DRSP_1 <- gam(DRSP_1log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_1)

plot.gam(gamm_DRSP_1, select = 3)

hist(dat$DRSP_1)
```


# Model-Implied Plot - DRSP_1
```{r}

DRSP_1dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_1, newdata = DRSP_1dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_1dat$estimate = pred$estimate
DRSP_1dat$conf.low = pred$conf.low
DRSP_1dat$conf.high = pred$conf.high

# Plotting
DRSP_1plot <- ggplot(DRSP_1dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Depressed Mood") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_1plot
```


# GAMM and initial plot - DRSP_2
```{r}
hist(dat$DRSP_2)
dat$DRSP_2log <- log(dat$DRSP_2+1)
hist(dat$DRSP_2log)
gamm_DRSP_2 <- gam(DRSP_2log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_2)

plot.gam(gamm_DRSP_2, select = 3)

hist(dat$DRSP_2)
```


# Model-Implied Plot - TEMPLATE
```{r}

DRSP_2dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_2, newdata = DRSP_2dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_2dat$estimate = pred$estimate
DRSP_2dat$conf.low = pred$conf.low
DRSP_2dat$conf.high = pred$conf.high

# Plotting
DRSP_2plot <- ggplot(DRSP_2dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Hopelessness") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_2plot
```

# GAMM and initial plot - DRSP_3
```{r}
hist(dat$DRSP_3)
dat$DRSP_3log <- log(dat$DRSP_3+1)
hist(dat$DRSP_3log)
gamm_DRSP_3 <- gam(DRSP_3log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_3)

plot.gam(gamm_DRSP_3, select = 3)

hist(dat$DRSP_3)
```


# Model-Implied Plot - DRSP_3
```{r}

DRSP_3dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_3, newdata = DRSP_3dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_3dat$estimate = pred$estimate
DRSP_3dat$conf.low = pred$conf.low
DRSP_3dat$conf.high = pred$conf.high

# Plotting
DRSP_3plot <- ggplot(DRSP_3dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Worthlessness & Guilt") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_3plot
```


# GAMM and initial plot - DRSP_4
```{r}
hist(dat$DRSP_4)
dat$DRSP_4log <- log(dat$DRSP_4+1)
hist(dat$DRSP_4log)
gamm_DRSP_4 <- gam(DRSP_4log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_4)

plot.gam(gamm_DRSP_4, select = 3)

hist(dat$DRSP_4)
```


# Model-Implied Plot - DRSP_4
```{r}

DRSP_4dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_4, newdata = DRSP_4dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_4dat$estimate = pred$estimate
DRSP_4dat$conf.low = pred$conf.low
DRSP_4dat$conf.high = pred$conf.high

# Plotting
DRSP_4plot <- ggplot(DRSP_4dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Anxiety & Tension") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_4plot
```


# GAMM and initial plot - DRSP_5
```{r}
hist(dat$DRSP_5)
dat$DRSP_5log <- log(dat$DRSP_5+1)
hist(dat$DRSP_5log)
gamm_DRSP_5 <- gam(DRSP_5log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_5)

plot.gam(gamm_DRSP_5, select = 3)

hist(dat$DRSP_5)
```


# Model-Implied Plot - DRSP_5
```{r}

DRSP_5dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_5, newdata = DRSP_5dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_5dat$estimate = pred$estimate
DRSP_5dat$conf.low = pred$conf.low
DRSP_5dat$conf.high = pred$conf.high

# Plotting
DRSP_5plot <- ggplot(DRSP_5dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Mood Swings") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_5plot
```


# GAMM and initial plot - DRSP_6
```{r}
hist(dat$DRSP_6)
dat$DRSP_6log <- log(dat$DRSP_6+1)
hist(dat$DRSP_6log)
gamm_DRSP_6 <- gam(DRSP_6log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_6)

plot.gam(gamm_DRSP_6, select = 3)

hist(dat$DRSP_6)
```


# Model-Implied Plot - DRSP_6
```{r}

DRSP_6dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_6, newdata = DRSP_6dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_6dat$estimate = pred$estimate
DRSP_6dat$conf.low = pred$conf.low
DRSP_6dat$conf.high = pred$conf.high

# Plotting
DRSP_6plot <- ggplot(DRSP_6dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Rejection Sensitivity") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_6plot
```



# GAMM and initial plot - DRSP_7
```{r}
hist(dat$DRSP_7)
dat$DRSP_7log <- log(dat$DRSP_7+1)
hist(dat$DRSP_7log)
gamm_DRSP_7 <- gam(DRSP_7log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_7)

plot.gam(gamm_DRSP_7, select = 3)

hist(dat$DRSP_7)
```


# Model-Implied Plot - DRSP_7
```{r}

DRSP_7dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_7, newdata = DRSP_7dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_7dat$estimate = pred$estimate
DRSP_7dat$conf.low = pred$conf.low
DRSP_7dat$conf.high = pred$conf.high

# Plotting
DRSP_7plot <- ggplot(DRSP_7dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Anger or Irritability") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_7plot
```


# GAMM and initial plot - DRSP_8
```{r}
hist(dat$DRSP_8)
dat$DRSP_8log <- log(dat$DRSP_8+1)
hist(dat$DRSP_8log)
gamm_DRSP_8 <- gam(DRSP_8log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_8)

plot.gam(gamm_DRSP_8, select = 3)

hist(dat$DRSP_8)
```


# Model-Implied Plot - DRSP_8
```{r}

DRSP_8dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_8, newdata = DRSP_8dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_8dat$estimate = pred$estimate
DRSP_8dat$conf.low = pred$conf.low
DRSP_8dat$conf.high = pred$conf.high

# Plotting
DRSP_8plot <- ggplot(DRSP_8dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Interpersonal Conflict") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_8plot
```

# GAMM and initial plot - DRSP_9
```{r}
hist(dat$DRSP_9)
dat$DRSP_9log <- log(dat$DRSP_9+1)
hist(dat$DRSP_9log)
gamm_DRSP_9 <- gam(DRSP_9log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_9)

plot.gam(gamm_DRSP_9, select = 3)

hist(dat$DRSP_9)
```


# Model-Implied Plot - DRSP_9
```{r}

DRSP_9dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_9, newdata = DRSP_9dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_9dat$estimate = pred$estimate
DRSP_9dat$conf.low = pred$conf.low
DRSP_9dat$conf.high = pred$conf.high

# Plotting
DRSP_9plot <- ggplot(DRSP_9dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Lack of Interest or Motivation") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_9plot
```

# GAMM and initial plot - DRSP_10
```{r}
hist(dat$DRSP_10)
dat$DRSP_10log <- log(dat$DRSP_10+1)
hist(dat$DRSP_10log)
gamm_DRSP_10 <- gam(DRSP_10log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_10)

plot.gam(gamm_DRSP_10, select = 3)

hist(dat$DRSP_10)
```


# Model-Implied Plot - DRSP_10
```{r}

DRSP_10dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_10, newdata = DRSP_10dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_10dat$estimate = pred$estimate
DRSP_10dat$conf.low = pred$conf.low
DRSP_10dat$conf.high = pred$conf.high

# Plotting
DRSP_10plot <- ggplot(DRSP_10dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Difficulty Concentrating") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_10plot
```

# GAMM and initial plot - DRSP_11
```{r}
hist(dat$DRSP_11)
dat$DRSP_11log <- log(dat$DRSP_11+1)
hist(dat$DRSP_11log)
gamm_DRSP_11 <- gam(DRSP_11log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_11)

plot.gam(gamm_DRSP_11, select = 3)

hist(dat$DRSP_11)
```


# Model-Implied Plot - DRSP_11
```{r}

DRSP_11dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_11, newdata = DRSP_11dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_11dat$estimate = pred$estimate
DRSP_11dat$conf.low = pred$conf.low
DRSP_11dat$conf.high = pred$conf.high

# Plotting
DRSP_11plot <- ggplot(DRSP_11dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Lethargy, Fatigue") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_11plot
```


# GAMM and initial plot - DRSP_12
```{r}
hist(dat$DRSP_12)
dat$DRSP_12log <- log(dat$DRSP_12+1)
hist(dat$DRSP_12log)
gamm_DRSP_12 <- gam(DRSP_12log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_12)

plot.gam(gamm_DRSP_12, select = 3)

hist(dat$DRSP_12)
```


# Model-Implied Plot - DRSP_12
```{r}

DRSP_12dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_12, newdata = DRSP_12dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_12dat$estimate = pred$estimate
DRSP_12dat$conf.low = pred$conf.low
DRSP_12dat$conf.high = pred$conf.high

# Plotting
DRSP_12plot <- ggplot(DRSP_12dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Increased Appetite, Overeating") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_12plot
```

# GAMM and initial plot - DRSP_13
```{r}
hist(dat$DRSP_13)
dat$DRSP_13log <- log(dat$DRSP_13+1)
hist(dat$DRSP_13log)
gamm_DRSP_13 <- gam(DRSP_13log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_13)

plot.gam(gamm_DRSP_13, select = 3)

hist(dat$DRSP_13)
```


# Model-Implied Plot - DRSP_13
```{r}

DRSP_13dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_13, newdata = DRSP_13dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_13dat$estimate = pred$estimate
DRSP_13dat$conf.low = pred$conf.low
DRSP_13dat$conf.high = pred$conf.high

# Plotting
DRSP_13plot <- ggplot(DRSP_13dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "DRSP_13") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_13plot
```

# GAMM and initial plot - DRSP_14
```{r}
hist(dat$DRSP_14)
dat$DRSP_14log <- log(dat$DRSP_14+1)
hist(dat$DRSP_14log)
gamm_DRSP_14 <- gam(DRSP_14log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_14)

plot.gam(gamm_DRSP_14, select = 3)

hist(dat$DRSP_14)
```


# Model-Implied Plot - DRSP_14
```{r}

DRSP_14dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_14, newdata = DRSP_14dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_14dat$estimate = pred$estimate
DRSP_14dat$conf.low = pred$conf.low
DRSP_14dat$conf.high = pred$conf.high

# Plotting
DRSP_14plot <- ggplot(DRSP_14dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Hypersomnia") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_14plot
```


# GAMM and initial plot - DRSP_15
```{r}
hist(dat$DRSP_15)
dat$DRSP_15log <- log(dat$DRSP_15+1)
hist(dat$DRSP_15log)
gamm_DRSP_15 <- gam(DRSP_15log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_15)

plot.gam(gamm_DRSP_15, select = 3)

hist(dat$DRSP_15)
```


# Model-Implied Plot - TEMPLATE
```{r}

DRSP_15dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_15, newdata = DRSP_15dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_15dat$estimate = pred$estimate
DRSP_15dat$conf.low = pred$conf.low
DRSP_15dat$conf.high = pred$conf.high

# Plotting
DRSP_15plot <- ggplot(DRSP_15dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Insomnia") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_15plot
```


# GAMM and initial plot - DRSP_16
```{r}
hist(dat$DRSP_16)
dat$DRSP_16log <- log(dat$DRSP_16+1)
hist(dat$DRSP_16log)
gamm_DRSP_16 <- gam(DRSP_16log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_16)

plot.gam(gamm_DRSP_16, select = 3)

hist(dat$DRSP_16)
```


# Model-Implied Plot - DRSP_16
```{r}

DRSP_16dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_16, newdata = DRSP_16dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_16dat$estimate = pred$estimate
DRSP_16dat$conf.low = pred$conf.low
DRSP_16dat$conf.high = pred$conf.high

# Plotting
DRSP_16plot <- ggplot(DRSP_16dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Overwhelmed") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_16plot
```


# GAMM and initial plot - DRSP_17
```{r}
hist(dat$DRSP_17)
dat$DRSP_17log <- log(dat$DRSP_17+1)
hist(dat$DRSP_17log)
gamm_DRSP_17 <- gam(DRSP_17log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_17)

plot.gam(gamm_DRSP_17, select = 3)

hist(dat$DRSP_17)
```


# Model-Implied Plot - TEMPLATE
```{r}

DRSP_17dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_17, newdata = DRSP_17dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_17dat$estimate = pred$estimate
DRSP_17dat$conf.low = pred$conf.low
DRSP_17dat$conf.high = pred$conf.high

# Plotting
DRSP_17plot <- ggplot(DRSP_17dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Out of Control") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_17plot
```



# GAMM and initial plot - DRSP_18
```{r}
hist(dat$DRSP_18)
dat$DRSP_18log <- log(dat$DRSP_18+1)
hist(dat$DRSP_18log)
gamm_DRSP_18 <- gam(DRSP_18log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_18)

plot.gam(gamm_DRSP_18, select = 3)

hist(dat$DRSP_18)
```


# Model-Implied Plot - DRSP_18
```{r}

DRSP_18dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_18, newdata = DRSP_18dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_18dat$estimate = pred$estimate
DRSP_18dat$conf.low = pred$conf.low
DRSP_18dat$conf.high = pred$conf.high

# Plotting
DRSP_18plot <- ggplot(DRSP_18dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Breast Tenderness") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_18plot
```


# GAMM and initial plot - DRSP_19
```{r}
hist(dat$DRSP_19)
dat$DRSP_19log <- log(dat$DRSP_19+1)
hist(dat$DRSP_19log)
gamm_DRSP_19 <- gam(DRSP_19log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_19)

plot.gam(gamm_DRSP_19, select = 3)

hist(dat$DRSP_19)
```


# Model-Implied Plot - DRSP_19
```{r}

DRSP_19dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_19, newdata = DRSP_19dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_19dat$estimate = pred$estimate
DRSP_19dat$conf.low = pred$conf.low
DRSP_19dat$conf.high = pred$conf.high

# Plotting
DRSP_19plot <- ggplot(DRSP_19dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Swelling, Bloating, or Weight Gain") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_19plot
```


# GAMM and initial plot - DSRP_20
```{r}
hist(dat$DRSP_20)
dat$DRSP_20log <- log(dat$DRSP_20+1)
hist(dat$DRSP_20log)
gamm_DRSP_20 <- gam(DRSP_20log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_20)

plot.gam(gamm_DRSP_20, select = 3)

hist(dat$DRSP_20)
```


# Model-Implied Plot - DSRP_20
```{r}

DRSP_20dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_20, newdata = DRSP_20dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_20dat$estimate = pred$estimate
DRSP_20dat$conf.low = pred$conf.low
DRSP_20dat$conf.high = pred$conf.high

# Plotting
DRSP_20plot <- ggplot(DRSP_20dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Headache") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_20plot
```




# GAMM and initial plot - DRSP_21
```{r}
hist(dat$DRSP_21)
dat$DRSP_21log <- log(dat$DRSP_21+1)
hist(dat$DRSP_21log)
gamm_DRSP_21 <- gam(DRSP_21log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_21)

plot.gam(gamm_DRSP_21, select = 3)

hist(dat$DRSP_21)
```


# Model-Implied Plot - DRSP_21
```{r}

DRSP_21dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_21, newdata = DRSP_21dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_21dat$estimate = pred$estimate
DRSP_21dat$conf.low = pred$conf.low
DRSP_21dat$conf.high = pred$conf.high

# Plotting
DRSP_21plot <- ggplot(DRSP_21dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Joint or Muscle Pain") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_21plot
```

# GAMM and initial plot - DRSP_22
```{r}
hist(dat$DRSP_22)
dat$DRSP_22log <- log(dat$DRSP_22+1)
hist(dat$DRSP_22log)
gamm_DRSP_22 <- gam(DRSP_22log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_22)

plot.gam(gamm_DRSP_22, select = 3)

hist(dat$DRSP_22)
```


# Model-Implied Plot - DRSP_22
```{r}

DRSP_22dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_22, newdata = DRSP_22dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_22dat$estimate = pred$estimate
DRSP_22dat$conf.low = pred$conf.low
DRSP_22dat$conf.high = pred$conf.high

# Plotting
DRSP_22plot <- ggplot(DRSP_22dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "School or Work Impairment") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_22plot
```



# GAMM and initial plot - DRSP_23
```{r}
hist(dat$DRSP_23)
dat$DRSP_23log <- log(dat$DRSP_23+1)
hist(dat$DRSP_23log)
gamm_DRSP_23 <- gam(DRSP_23log ~ s(id, bs = "re") + s(scaled_cycleday, id, bs = "re")  + s(scaled_cycleday, k = 20), data = dat, method = "REML")

summary(gamm_DRSP_23)

plot.gam(gamm_DRSP_23, select = 3)

hist(dat$DRSP_23)
```


# Model-Implied Plot - DRSP_23
```{r}

DRSP_23dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_DRSP_23, newdata = DRSP_23dat, type = "response", transform = function(x) exp(x) - 1)

#, transform = function(x) exp(x) - 1) #don't need to include anything for 'transform' if your outcome is not log-transformed. This undo's the logtransform so model-implied values are not on the log scale 

DRSP_23dat$estimate = pred$estimate
DRSP_23dat$conf.low = pred$conf.low
DRSP_23dat$conf.high = pred$conf.high

# Plotting
DRSP_23plot <- ggplot(DRSP_23dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Relationship Interference") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

DRSP_23plot
```


