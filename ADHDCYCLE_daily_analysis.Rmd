---
title: "ADHDCYCLE_daily_analysis"
author: "Tory Eisenlohr-Moul"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: true
    number_sections: true
---

# ---- Setup ----
- Turns of Scientific Notation
- Saves 'current_date' as a string in YYYYMMDD format
- Sets the number of digits (3) to display in output
- Saves Current Date as a string in YYYYMMDD format
- Sets the 'output_folder' as path to the output folder for saving files
```{r setup}

knitr::opts_chunk$set(echo = TRUE) # Setting options for knitr to display R code in output
options(scipen = 999) # Turn off scientific notation
options(digits = 3) # Set number of digits to display

current_date <- format(Sys.Date(), "%Y%m%d")  # Produces date as YYYYMMDD

output_folder <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-10-20"

if (!dir.exists(output_folder)) {
  dir.create(output_folder, recursive = TRUE)
}

```



# ---- Load Packages (no cache) ----
```{r packages, warning=FALSE}

# ---- Global Chunk Options and Settings ----

# Setting options for knitr to display R code in output
knitr::opts_chunk$set(echo = TRUE)

# Prevent scientific notation in outputs
options(scipen = 999)

# ---- Data Manipulation and Cleaning ----

# Core tidyverse libraries for data manipulation and visualization
library(dplyr)       # Data manipulation (part of tidyverse)
library(tidyr)       # Data tidying (part of tidyverse)
library(tidyverse)   # Meta-package, includes dplyr, tidyr, ggplot2, and others
library(janitor)     # For cleaning data, e.g., renaming columns, removing empty rows
library(skimr)       # Summarize and inspect data quickly


# ---- Reading and Working with Files ----

# Libraries for reading various file formats
library(haven)       # For reading SPSS, Stata, and SAS files
library(readxl)      # For reading Excel files
library(readr)       # For reading CSV and other text files


# ---- Plotting and Visualization ----

# Core and extended libraries for data visualization
library(ggplot2)     # Core plotting library
library(ggdist)      # Visualizing distributions and uncertainty
library(ggforce)     # Extending ggplot2 functionality with advanced features
library(ggrepel)     # For adding non-overlapping text labels to ggplot2
library(visdat)      # Visualizing missing data and data structure
library(sjPlot)      # Plotting for statistical models (e.g., mixed models)
library(corrplot)    # For creating correlation matrix visualizations
library(grid)        # Base R graphics system for visual layout
library(gridExtra)   # Arranging multiple plots in a grid
library(see)         # Visualizing model checks and diagnostics
library(DescTools)  # Descriptive statistics and plotting tools
library(cowplot)    # For creating complex plots with multiple panels


# ---- Time Series and Rolling Averages ----

# Libraries for time series data and handling dates
library(zoo)         # Working with rolling means/averages and time series
library(lubridate)   # Date and time manipulation


# ---- Mixed-Effects Models and Analysis ----

# Libraries for mixed-effects models and related analysis
library(lme4)        # Fitting mixed-effects models (linear and generalized)
library(lmerTest)    # Adds p-values for lme4 models
library(nlme)        # Linear and nonlinear mixed-effects models
library(emmeans)     # Compute estimated marginal means (EMMs) for model outputs
library(broom.mixed) # Tidying mixed model results into tidy data frames
library(performance) # Model performance metrics (e.g., R-squared for mixed models)
library(pbkrtest)    # Parametric bootstrap and Kenward-Roger methods for mixed models

# Generalized additive models and marginal effects
library(mgcv)        # Fitting generalized additive models (GAMs)
library(marginaleffects) # Tools for calculating marginal effects from regression models


# ---- Statistical Tools ----

# Libraries for specific statistical methods
#library(psych)       # Descriptive statistics and psychometrics
#library(GPArotation) # Factor analysis rotations (e.g., Varimax)
library(rmcorr)      # Repeated measures correlations
#library(MASS)        # Functions for statistical methods, e.g., Mahalanobis distance
library(careless)    # Detecting careless responses in surveys
library(responsePatterns) # Analyzing response patterns in data


# ---- GitHub, Project Management, and Reproducibility ----

# Libraries for project and version control management
library(usethis)     # Simplifies setting up GitHub repositories and managing projects
library(gitcreds)    # Managing Git credentials for GitHub interactions
#library(renv)        # Manages dependencies for reproducible environments
#library(targets)     # Workflow management for reproducible research pipelines
```

# ---- Check for Package Conflicts and Declare Preferences (no cache) ----
```{r package conflicts, warning=FALSE}
library(conflicted) # Managing conflicts between package namespaces

conflict_scout() # Check for conflicts between package namespaces

conflicts_prefer(dplyr::filter)
conflicts_prefer(tidyr::complete)
conflicts_prefer(dplyr::lag)
```

# ---- Store Global Lists of final variable names and labels ----
- Create Lists of Variables for Analysis
-   @dv_list: List of dependent variables for analysis
-   @hormlist: List of hormone variables for analysis
-   @alldailyvars: dv_list and hormlist combined

```{r make lists, cache=TRUE}

dv_list <- c(
  "CSS_Inatt",
  "CSS_HypImp",
  "score_pinball",
  "score_robot",
  "BDEFS_Total",
  "BDEFS_WM_avg",
  "BDEFS_RI_avg",
  "UPPS_NU_avg",
  "UPPS_PU_avg",
  "UPPS_Premed_avg",
  "UPPS_Persev_avg",
  "UPPS_Sens_avg",
  "DEBQ_Total",
  "CSS_Inatt_Count",
  "CSS_Hyp_Count",
  "CSS_Imp_Count",
  "CSS_HypImp_Count",
  "DRSP_1",
  "DRSP_2",
  "DRSP_3",
  "DRSP_4",
  "DRSP_5",
  "DRSP_6",
  "DRSP_7",
  "DRSP_8",
  "DRSP_9",
  "DRSP_10",
  "DRSP_11",
  "DRSP_12",
  "DRSP_13",
  "DRSP_14",
  "DRSP_15",
  "DRSP_16",
  "DRSP_17",
  "DRSP_18",
  "DRSP_19",
  "DRSP_20",
  "DRSP_21",
  "DRSP_22",
  "DRSP_23"
) %>% noquote()



# Rename the variables based on DRSP items
# This creates a named vector to assign meaningful labels to each variable for better interpretation in the plots
names(dv_list) <- c(
  "Inattention Sx", 
  "Hyperactivity/Imp Sx", 
  "Pinball Score",
  "Robot Score",
  "BDEFS Total",
  "BDEFS Working Memory",
  "BDEFS Resp Inhibition",
  "Negative Urgency",
  "Positive Urgency",
  "Lack of Premeditation",
  "Lack of Perseverance",
  "Sensation Seeking",
  "DEBQ Total",
  "Inattention Sx Count",
  "Hyperactivity Sx Count",
  "Impulsivity Sx Count",
  "Hyp/Imp Sx Count",
  "Depressed Mood", # DRSP_1
  "Hopelessness", # DRSP_2
  "Worthlessness/Guilt", # DRSP_3
  "Anxiety/Tension", # DRSP_4
  "Mood Swings", # DRSP_5
  "Rejection Sensitivity", # DRSP_6
  "Anger/Irritability", # DRSP_7
  "Interpersonal Conflict", # DRSP_8
  "Less Interest", # DRSP_9
  "Difficulty Concentrating", # DRSP_10
  "Lethargy/Fatigue", # DRSP_11
  "Incr Appetite/Overate", # DRSP_12
  "Food Cravings", # DRSP_13
  "Hypersomnia", # DRSP_14
  "Insomnia", # DRSP_15
  "Overwhelm/Can't Cope", # DRSP_16
  "Out of Control", # DRSP_17
  "Breast Tenderness", # DRSP_18
  "Swelling/Bloat/Wt Gain", # DRSP_19
  "Joint/Muscle Pain", # DRSP_20
  "Headache", # DRSP_21
  "Work/School Imp", 
  "Relational Imp"
)

# Rename the variables based on DRSP items
names(dv_list) <- c(
  "Depressed Mood", # DRSP_1
  "hopelessness", # DRSP_2
  "Worthlessness/Guilt", # DRSP_3
  "Anxiety/Tension", # DRSP_4
  "Mood Swings", # DRSP_5
  "Rejection Sensitivity", # DRSP_6
  "Anger/Irritability", # DRSP_7
  "Interpersonal Conflict", # DRSP_8
  "Less Interest", # DRSP_9
  "Difficulty Concentrating", # DRSP_10
  "Lethargy/Fatigue", # DRSP_11
  "Increased Appetite/Overate", # DRSP_12
  "Food Cravings", # DRSP_13
  "Hypersomnia", # DRSP_14
  "Insomnia", # DRSP_15
  "Overwhelm/Can't Cope", # DRSP_16
  "Out of Control", # DRSP_17
  "Breast Tenderness", # DRSP_18
  "Swelling/Bloating/Weight Gain", # DRSP_19
  "Joint/Muscle Pain", # DRSP_20
  "Headache", # DRSP_21
  "Work/School Impairment", 
  "Relational Impairment",
  "Inattention Symptoms", 
  "Hyperactivity/Impulsivity Symptoms", 
  "Pinball Score",
  "Robot Score",
  "BDEFS Total",
  "BDEFS Working Memory",
  "BDEFS Response Inhibition",
  "Negative Urgency",
  "Positive Urgency",
  "Lack of Premeditation",
  "Lack of Perseverance",
  "Sensation Seeking",
  "DEBQ Total",
  "Inattention Sx Count",
  "Hyperactivity Sx Count",
  "Impulsivity Sx Count",
  "Hyperactivity/Impulsivity Sx Count"
)

hormlist <- c(
  "E2",
  "P4",
  "LH"
) %>% noquote()

#Create another list that combines both dv_list and hormlist above
alldailyvars <- c(dv_list, hormlist) %>% noquote()
```

# Input dataset - CLEAN AS OF 2024-10-20

```{r}
# Load your CSV file (adjust the path to your actual file location)
df <- read_csv("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/adhd_daily_df_20241020.csv")

print.variable.names(df)
```

# ---- Setting Variable Formats  ----
- Convert daterated to Date format using lubridate if necessary (ensure date format matches)
```{r updating formats, include=TRUE}

convert_date_if_needed <- function(df, date_column) {
  # Check if the date column is in Date format
  if (!inherits(df[[date_column]], "Date")) {
    df <- df %>%
      mutate({{ date_column }} := lubridate::mdy(!!sym(date_column))) # Convert to mm/dd/yyyy format if not already in Date format
  }
  return(df)
}

# Call
df <- convert_date_if_needed(df, "daterated")

```

# ---- Sort df by id and daterated ----
```{r sort df}
df <- df %>%
  arrange(id, daterated)

count_rows_ids(df)
```


# Cristina Pinheiro EF Analyses

```{r sort df}
# Count nonmissing values of pinball and robot scores
df %>%
  count(!is.na(score_pinball))

# How many unique ids have at least 10 nonmissing pinball observations? 

df %>%
  group_by(id) %>%
  summarise(n_pinball = sum(!is.na(score_pinball))) %>%
  filter(n_pinball >= 10) %>%
  nrow()

# How many unique ids have at least 10 nonmissing robot observations?
df %>%
  group_by(id) %>%
  summarise(n_robot = sum(!is.na(score_robot))) %>%
  filter(n_robot >= 10) %>%
  nrow()


# ---- Histograms ----

hist(df$score_pinball)
hist(df$score_robot)
hist(df$BDEFS_WM_avg)
hist(df$BDEFS_RI_avg)

# Example list of variables
variable_list <- c("score_pinball", "score_robot", "BDEFS_WM_avg", "BDEFS_RI_avg")

# ---- Repeated Measures Correlations ----

# Set all measures in a list to numeric
df[variable_list] <- lapply(df[variable_list], as.numeric)

# Initialize an empty matrix to store correlations
n <- length(variable_list)

# Compute repeated measures correlations for all pairs of variables
within_matrix <- matrix(NA, nrow = n, ncol = n, dimnames = list(variable_list, variable_list))

# Loop through unique pairs of variables
for (i in 1:(n - 1)) {
  for (j in (i + 1):n) {
    var1 <- variable_list[i]
    var2 <- variable_list[j]
    
    # Compute repeated measures correlation
    result <- rmcorr(participant = id, 
                     measure1 = df[[var1]], 
                     measure2 = df[[var2]], 
                     dataset = df)
    
    # Store the correlation coefficient in the matrix
    within_matrix[i, j] <- result$r
    within_matrix[j, i] <- result$r  # Fill symmetric position
  }
}

# Display the repeated measures correlation matrix
print(within_matrix)


# Save to output_folder as text file
write.table(within_matrix, file = paste0(output_folder, "/rmcorr_correlations.txt"), sep = "\t", quote = FALSE)


# ---- Person Mean Correlations ----

# Create a new dataset keeping only the first observation per id
df_first <- df %>%
  group_by(id) %>%
  filter(row_number() == 1) %>%
  ungroup()

variable_list.m <- c("score_pinball.m", "score_robot.m", "BDEFS_WM_avg.m", "BDEFS_RI_avg.m")


# Calculate correlation matrix of score_pinball.m, score_robot.m, BDEFS_WM_avg.m, and BDEFS_RI_avg.m
between_matrix <- cor(df_first[variable_list.m], use = "complete.obs")

between_matrix

# Save to output_folder as text file
write.table(between_matrix, file = paste0(output_folder, "/person_mean_correlations.txt"), sep = "\t", quote = FALSE)

```


# ---- END SETUP AND PREP  ----

# ---- START ANALYSES   ----

# Check Association between cycleday variable and days since starting

```{r, cache=TRUE}

df$TubeNumber <- as.numeric(df$TubeNumber) # Convert TubeNumber to numeric

df_first <- df %>%
  group_by(id) %>%
  filter(TubeNumber == 1) %>%
  ungroup()

hist(df_first$scaled_cycleday, breaks = 30)


#cor(x=as.numeric(df$TubeNumber), y=df$scaled_cycleday, use="complete.obs")

#plot(x=as.numeric(df$TubeNumber), y=df$scaled_cycleday, use="complete.obs")

```

# 2024-10-20 - PLOTS - LUTEAL then FOLLICULAR - (OVULATION to OVULATION)
# Saved in 20241020 folder
```{r plot-ov-ov-means, eval=FALSE, cache=TRUE}

# Define the function to generate plots for a list of DVs
plot_DVs <- function(dv_list, df) {
  
  # Create person-standardized (z-scored within each participant) versions of each DV
  for (DV in dv_list) {
    zd_var <- paste0(DV, ".zd")  # Name for the person-standardized version
    
    # Add the person-standardized columns for each DV
    df <- df %>%
      group_by(id) %>%
      mutate(!!zd_var := scale(!!sym(DV), center = TRUE, scale = TRUE)) %>%
      ungroup()
  }
  
  # Calculate person-rescaled E2 and P4 (scaled within each person, sd = 0.5)
  df <- df %>%
    group_by(id) %>%
    mutate(E2.rescale = scale(E2, center = TRUE, scale = sd(E2, na.rm=TRUE)/0.5), #changed here
           P4.rescale = scale(P4, center = TRUE, scale = sd(P4, na.rm=TRUE)/0.5)) %>% #changed here
    ungroup()
  
  # Indicators for menstrual bleeding
  bleeding_indicator <- data.frame(xmin = .5, xmax = 0.7, ymin = -Inf, ymax = Inf)
  
  for (DV in dv_list) {
    
    if (DV %in% c("E2", "P4", "LH")) {
      # Raw plot for E2, P4, LH
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p1 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.1) +
        geom_point(size = 1) +
        geom_line(size = 1) +
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      ggsave(filename = paste0(output_folder, "/", DV, "_", "raw", ".png"), plot = last_plot(), width = 8, height = 6)

      
    } else {
      # For DVs that are NOT E2, P4, LH
      
      # Raw data points and line for the dependent variable
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
    # Person-rescaled E2 and P4 lines (thin dotted)  <- Changed variable names here
      E2_std <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(E2.rescale, na.rm = TRUE)) #changed here

      p4_std <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(P4.rescale, na.rm = TRUE))  #changed here
      
      p1 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # Thin dotted lines for E2 and P4
        # geom_line(data = E2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      # Deviations plot
      dev_var <- paste0(DV, ".d")
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p2 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = E2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p2)
      
            ggsave(filename = paste0(output_folder, "/", DV, "_", "dev", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Person-standardized outcome (zd)
      zd_var <- paste0(DV, ".zd")
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(zd_var), na.rm = TRUE),
                  se_value = sd(!!sym(zd_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p3 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        geom_line(data = E2_std, aes(x = cycleday_10perc, y = mean_value), 
                  linetype = "solid", color = "forestgreen", size = 1, alpha = 0.9) +  # E2
        geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
                  linetype = "solid", color = "red", size = 1, alpha = 0.8) +  # P4
        ggtitle(paste("Person-standardized", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Person-standardized Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p3)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "zd", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Rolling deviations plot
      roll_dev_var <- paste0(DV, ".d.5roll")
      dv <- df %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(roll_dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(roll_dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p4 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = E2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Rolling Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Rolling Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p4)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "rolld", ".png"), plot = last_plot(), width = 8, height = 6)

    }
  }
}

plot_DVs(dv_list, df)

```

# 2024-10-20 - PLOTS - FOLLICULAR then LUTEAL - (MENSES to MENSES)
# Saved in 20241020 folder
```{r plot-mens-mens-means, eval=FALSE, cache=TRUE}


# Define the function to generate plots for a list of DVs
# Args:
#   dv_list: A named vector of dependent variables (DVs) to be plotted.
#   df: A data frame containing the data for analysis and plotting.
#   output_folder: The folder path where the generated plots should be saved.
plot_DVs_M2M <- function(dv_list, df, output_folder) {
  
  # Create person-standardized (z-scored within each participant) versions of each DV
  for (DV in dv_list) {
    zd_var <- paste0(DV, ".zd")  # Name for the person-standardized version
    
    # Add the person-standardized columns for each DV
    df <- df %>%
      group_by(id) %>%
      mutate(!!zd_var := scale(!!sym(DV), center = TRUE, scale = TRUE)) %>%
      ungroup()
  }
  
  # Calculate person-rescaled E2 and P4 (scaled within each person, sd = 0.5)
  # This transformation helps in visual comparison by keeping the SD consistent across participants
  df <- df %>%
    group_by(id) %>%
    mutate(E2.rescale = scale(E2, center = TRUE, scale = (sd(E2, na.rm = TRUE)*1.75)),
           P4.rescale = scale(P4, center = TRUE, scale = (sd(P4, na.rm = TRUE)*1.75))) %>%
    ungroup()
  
  # Indicators for menstrual bleeding (static values for highlighting cycle day range)
  bleeding_indicator <- data.frame(xmin = 0, xmax = 0.2, ymin = -Inf, ymax = Inf)
  
  # Loop through each DV to generate plots
  for (DV in dv_list) {
    # Get the label for the DV from dv_list
    DV_label <- names(dv_list)[which(dv_list == DV)]
    
    # Calculate mean and standard error for the raw dependent variable
    dv <- df %>%
      group_by(cycledayov_10perc) %>%
      summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
    
    # Calculate mean and standard error for the person-z-scored outcome (zd)
    zd_var <- paste0(DV, ".zd")
    dv_zd <- df %>%
      group_by(cycledayov_10perc) %>%
      summarise(mean_value = mean(!!sym(zd_var), na.rm = TRUE),
                se_value = sd(!!sym(zd_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
    
    # Generate plot for the person-standardized outcome (zd)
p3 <- ggplot(dv_zd, aes(x = cycledayov_10perc, y = mean_value)) +
  # Plotting the mean values for the person-standardized outcome with LOESS smoothing
  geom_smooth(method = "loess", span = .7, size = 1.5, se = FALSE, color = "black") +  # Use geom_smooth for the main DV with CI
  # Plotting the rescaled E2 and P4 values with LOESS smoothing
  geom_smooth(data = df, aes(x = cycledayov_10perc, y = E2.rescale, color = "E2"), method = "loess", span = 0.5, 
              linetype = "dashed", size = 1, alpha = 0.9, se = FALSE) +
  geom_smooth(data = df, aes(x = cycledayov_10perc, y = P4.rescale, color = "P4"), method = "loess", span = 0.5, 
              linetype = "dashed", size = 1, alpha = 0.8, se = FALSE) +
  # Manual color settings for different lines in the plot
  scale_color_manual(values = c("E2" = "forestgreen", "P4" = "red")) +
  # Set axis labels and plot title
  xlab("Cycle Day (10% bins)") + ylab(paste("Smoothed Person-Z-Scored", DV_label)) +
  # Apply minimal theme for cleaner look
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.margin = margin(15, 5, 50, 5),
        legend.title = element_blank(),
        legend.position = "right") +
  coord_cartesian(clip = "off") +
  ggtitle(label=DV_label)+
  # Highlight menstrual bleeding days with a red rectangle
  geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), 
            fill = "red", alpha = 0.2, inherit.aes = FALSE)

# Print the plot to the graphics device
print(p3)
    
    # Save the plot to the specified output folder
    ggsave(filename = file.path(output_folder, paste0(DV, "_", "ov_zd_noSE", ".png")), plot = p3, width = 8, height = 6)
  }
}

# Call the function with the dataframe and output folder
plot_DVs_M2M(dv_list, df, output_folder)

```


# 2024-10-20 - FITTING GAMMs for E2, P4, LH - Have to do this first because otherwise the function below breaks
# Saved in 20241020 Folder
```{r scaledcyc-horm-gamms-plots, eval=FALSE, cache=TRUE}

# E2


hist(df$E2)
df$E2log <- log(df$E2+1)
hist(df$E2log)

# Set id as factor
df$id <- as.factor(df$id)

gamm_E2 <- gam(E2log ~ s(id, bs = "re") + 
                 s(id, scaled_cycleday, bs = "fs") + 
                 s(scaled_cycleday), data = df, method = "REML")

summary(gamm_E2)


# Save the model summary as a text file
summary_output <- capture.output(summary(gamm_E2))

var.part = gam.hp::gam.hp(gamm_E2)
var.part$hierarchical.partitioning

E2dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_E2, newdata = E2dat, type = "response", transform = function(x) exp(x) - 1)

#don't need to include anything for 'transform' if your outcome is not log-transformed. This undoes the logtransform so model-implied values are not on the log scale 

E2dat$estimate = pred$estimate
E2dat$conf.low = pred$conf.low
E2dat$conf.high = pred$conf.high

# Plotting
E2plot <- ggplot(E2dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Salivary Estradiol") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

E2plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/20241020/E2_gamm_plot.png",
       plot = last_plot(), 
       width = 8, 
       height = 6)

# P4

hist(df$P4)
df$P4log <- log(df$P4+1)
hist(df$P4log)

gamm_P4 <- gam(P4log ~ s(id, bs = "re") + 
                 s(scaled_cycleday, id, bs = "re") + 
                 s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_P4)


# Save the model summary as a text file
summary_output <- capture.output(summary(gamm_P4))

var.part = gam.hp::gam.hp(gamm_P4)
var.part$hierarchical.partitioning

P4dat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_P4, newdata = P4dat, type = "response", transform = function(x) exp(x) - 1)

#don't need to include anything for 'transform' if your outcome is not log-transformed. This undoes the logtransform so model-implied values are not on the log scale 

P4dat$estimate = pred$estimate
P4dat$conf.low = pred$conf.low
P4dat$conf.high = pred$conf.high

# Plotting
P4plot <- ggplot(P4dat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Salivary Progesterone") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

P4plot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/20241020/P4_gamm_plot.png",
       plot = last_plot(), 
       width = 8, 
       height = 6)


# LH

hist(df$LH)
df$LHlog <- log(df$LH+1)
hist(df$LHlog)

gamm_LH <- gam(LHlog ~ s(id, bs = "re") + 
                 s(scaled_cycleday, id, bs = "re") + 
                 s(scaled_cycleday, k = 20), data = df, method = "REML")

summary(gamm_LH)


# Save the model summary as a text file
summary_output <- capture.output(summary(gamm_LH))

var.part = gam.hp::gam.hp(gamm_LH)
var.part$hierarchical.partitioning

LHdat <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1),
                      id = 0) 

# Predict using the model for each dataset and add predictions
pred <- predictions(gamm_LH, newdata = LHdat, type = "response", transform = function(x) exp(x) - 1)

#don't need to include anything for 'transform' if your outcome is not log-transformed. This undoes the logtransform so model-implied values are not on the log scale 

LHdat$estimate = pred$estimate
LHdat$conf.low = pred$conf.low
LHdat$conf.high = pred$conf.high

# Plotting
LHplot <- ggplot(LHdat, aes(x = scaled_cycleday, y = estimate)) +
  scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
  labs(x = "", y = "Salivary Progesterone") +
  geom_rect(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf,
            fill = "grey70", alpha = 0.2, color = "white") +
  geom_rect(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf,
            fill = "grey87", alpha = 0.2, color = "white") +
  #geom_point(size = 3) +
  geom_line(size = 1, show.legend = TRUE) +
  theme_minimal()

LHplot

ggsave(filename = "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/20241020/LH_gamm_plot.png",
       plot = last_plot(), 
       width = 8, 
       height = 6)

```

# ---- Scaled Cycle Day GAMMs Predicting all outcomes on dv_list
- For each variable in @dv_list, 
- Runs GAMM and Hierarchical Variance partitioning hp.gamm()
- Saves it to a .txt file in @current_date's @output_folder in the project's Box Folder for 03_code_dataedits_output. 
- Creates two plots for each variable in @dv_list:
  - Plot 1: Predicted values and confidence intervals for the variable
  - Plot 2: Z-Scored predicted values and confidence intervals for the variable with E2 and P4 curves overlaid
```{r gamm_models_plots, cache=TRUE, eval=FALSE, include=TRUE}

gamm_models_plots <- function(dv, df, output_folder, plot_path) {
  
  # Step 1: Create a histogram for the dv variable to check its distribution
  hist(df[[dv]], main = paste0("Histogram of", dv), xlab = dv)
  
  # Step 2: Log-transform the dv variable to deal with skewness
  log_dv <- paste0(dv, "log")  
  df[[log_dv]] <- log(df[[dv]] + 1)  
  hist(df[[log_dv]], main = paste("Histogram of Log-Transformed", dv), xlab = log_dv)
  
  # Step 3: Fit a GAMM
  gamm_model <- gam(as.formula(paste0(log_dv, " ~ s(id, bs = 're') + s(scaled_cycleday, id, bs = 're') + s(scaled_cycleday, k = 30)")), data = df, method = "REML")
  
  # Step 4: Summary of GAMM
  model_summary <- summary(gamm_model)
  
  # Step 4a: Extract p-value and edf for scaled_cycleday from model_summary
  scaled_cycleday_row <- which(rownames(model_summary$s.table) == "s(scaled_cycleday)")
  p_value <- model_summary$s.table[scaled_cycleday_row, "p-value"]
  edf <- model_summary$s.table[scaled_cycleday_row, "edf"]

  # Determine significance symbol
  significance <- ""
  if (p_value < 0.001) {
    significance <- "***"
  } else if (p_value < 0.01) {
    significance <- "**"
  } else if (p_value < 0.05) {
    significance <- "*"
  } else if (p_value < 0.15) {
    significance <- "†"
  }
  
  # Step 5: Perform hierarchical partitioning
  var_part <- gam.hp::gam.hp(gamm_model)
  print(model_summary)
  print(var_part$hierarchical.partitioning)

  # Step 6: Capture the output for both model summary and hierarchical partitioning
  summary_output <- capture.output(model_summary)
  partitioning_output <- capture.output(var_part$hierarchical.partitioning)

  # Step 7: Combine the model summary and hierarchical partitioning results
  combined_output <- c(summary_output, "", "Hierarchical Partitioning:", partitioning_output)

  # Step 8: Write to file
  summary_file_path <- file.path(output_folder, paste0("gamm_hp_", dv, ".txt"))
  writeLines(combined_output, summary_file_path)

  # Step 9: Create a dataset for predictions from the model
  pred_data <- expand.grid(scaled_cycleday = seq(-1, 1, by = 0.1), id = 0)
pred <- predictions(gamm_model, newdata = pred_data, type = "response", transform = function(x) exp(x) - 1)

  # Calculate confidence intervals
  pred_data$estimate <- scale(pred$estimate)
  pred_data$conf.low <- scale(pred$conf.low)
  pred_data$conf.high <- scale(pred$conf.high)

  # Step 10: Plot predicted values and confidence intervals for the dv and add E2 curve
  dv_plot <- ggplot(pred_data, aes(x = scaled_cycleday)) +
    scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), 
                       labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
    labs(x = "Cycle Day (Scaled)", y = paste0(dv, " (Z, Pred)")) +
    geom_rect(aes(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf),
              fill = "grey70", alpha = 0.2, color = "white") +
    geom_rect(aes(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf),
              fill = "grey87", alpha = 0.2, color = "white") +
    
    # Confidence ribbons for the dv estimates
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "black", alpha = 0.1) +
    
    # Line plot for dv
    geom_line(aes(y = estimate, color = "dv"), size = 1, show.legend = TRUE) +
    
    # Add E2 and P4 curves on top (using E2dat and P4dat)
    geom_line(data = E2dat, aes(x = scaled_cycleday, y = scale(estimate), color = "E2"), size = 1, linetype = "dashed") +
    geom_line(data = P4dat, aes(x = scaled_cycleday, y = scale(estimate), color = "P4"), size = 1, linetype = "dashed") +
    
    # Customize legend with desired order
    scale_color_manual(name = "Key", 
                       values = c("dv" = "black", "E2" = "forestgreen", "P4" = "red"),
                       labels = c("dv" = dv, "E2" = "E2", "P4" = "P4"),
                       breaks = c("dv", "E2", "P4")) +
    theme_minimal() +
    theme(legend.position = "right")

  # Create a label for EDF and p-value, and add it below the legend
  annotation_text <- paste("EDF:", round(edf, 2), significance)
  annotated_plot <- ggdraw(dv_plot) +
    draw_label(annotation_text, x = 0.85, y = 0.2, hjust = 0, size = 10, fontface = "bold")

  # Display the plot with annotation
  print(annotated_plot)

  # Step 11: Save the plot to a file
  plot_file_path <- file.path(plot_path, paste0(dv, "_scaled_with_horm.png"))
  ggsave(filename = plot_file_path, plot = annotated_plot, width = 8, height = 6)
  cat("Plot with Hormone overlays saved to:", plot_file_path, "\n")
  
  # Calculate confidence intervals
  pred_data$estimate <- pred$estimate
  pred_data$conf.low <- pred$conf.low
  pred_data$conf.high <- pred$conf.high

  # Step 10: Plot predicted values and confidence intervals for the dv and add E2 curve
  dv_plot <- ggplot(pred_data, aes(x = scaled_cycleday)) +
    scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, by = 0.50), 
                       labels = c("0%L", "50%L", "Menses Onset", "50%F", "Ovulation")) +
    labs(x = "Cycle Day (Scaled)", y = paste0(dv, " (Orig Scale)")) +
    geom_rect(aes(xmin = -0.04, xmax = 0.04, ymin = -Inf, ymax = Inf),
              fill = "grey70", alpha = 0.2, color = "white") +
    geom_rect(aes(xmin = 0.92, xmax = 1, ymin = -Inf, ymax = Inf),
              fill = "grey87", alpha = 0.2, color = "white") +
    
    # Confidence ribbons for the dv estimates
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "black", alpha = 0.1) +
    
    # Line plot for dv
geom_line(aes(y = estimate), color = "black", size = 1, show.legend = FALSE) +
    
    theme_minimal() 

  # Create a label for EDF and p-value, and add it below the legend
  annotation_text <- paste("EDF:", round(edf, 2), significance)
  annotated_plot <- ggdraw(dv_plot) +
    draw_label(annotation_text, x = 0.85, y = 0.2, hjust = 0, size = 10, fontface = "bold")

  # Display the plot with annotation
  print(annotated_plot)

  # Step 11: Save the plot to a file
  plot_file_path <- file.path(plot_path, paste0(dv, "_origscale.png"))
  ggsave(filename = plot_file_path, plot = annotated_plot, width = 8, height = 6)
  cat("Original Scale Plot saved to:", plot_file_path, "\n")

}

# Example usage
plot_path <- file.path(output_folder, "GAMM_Plots")

# Loop through each dv and apply the GAMM function
for (dv in dv_list) {
  gamm_models_plots(dv, df, output_folder, plot_path)
}

```

## Prepare Hormones

```{r}

#df$logE2 = log(df$E2 + 1)
#df$logP4 = log(df$P4 + 1)

df <- df %>%
  group_by(id) %>%
  mutate(
    E2zd = scale(E2),
    P4zd = scale(P4),
    
    # Calculate 5th and 95th percentiles for E2 and P4 within each id
    E2_lower = quantile(E2zd, 0.05, na.rm = TRUE),
    E2_upper = quantile(E2zd, 0.95, na.rm = TRUE),
    P4_lower = quantile(P4zd, 0.05, na.rm = TRUE),
    P4_upper = quantile(P4zd, 0.95, na.rm = TRUE),
    
    # Manually Winsorize by clamping values to the 5th and 95th percentiles
    E2zd = pmin(pmax(E2zd, E2_lower), E2_upper),
    P4zd = pmin(pmax(P4zd, P4_lower), P4_upper),
    
    # Daily derivatives for E2 and P4
    E2zch = c(NA, diff(E2zd)),  # Winsorized E2 derivative
    P4zch = c(NA, diff(P4zd))   # Winsorized P4 derivative
  ) %>%
  filter(
    !is.na(E2zd) & !is.nan(E2zd) & !is.infinite(E2zd) &
      !is.na(P4zd) & !is.nan(P4zd) & !is.infinite(P4zd) &
      !is.na(E2zch) & !is.nan(E2zch) & !is.infinite(E2zch) &
      !is.na(P4zch) & !is.nan(P4zch) & !is.infinite(P4zch)
  ) %>%
  ungroup()


```

# ---- E2 and P4 GAMMs Predicting all outcomes on dv_list
- Several Variables were created in the dailyprep file: 
- E2.m, E2.sd, E2.d, E2.zd, E2.zd.3roll, E2.zd.5roll (for E2, P4, and LH, as well as everything in @alldailyvars)
-TODO: We need to add lags and consider derivatives and using rolling averages 
-TODO:  HOWEVER, I need the winsorization below. We will need to add the winsorization to the dailyprep file and re-run it.

# Looping through hormone effects - FIXED: E2zd, P4zd, E2zd*P4zd, E2zch, P4zch

```{r}

# Function to Loop Through Outcomes and Generate GAMM Models
create_gamm_models <- function(dv_list, df, save_dir) {
  for (outcome in dv_list) {
    # Prepare variables dynamically
    outcome_log <- paste0(outcome, "log")
    df[[outcome_log]] <- log(df[[outcome]] + 1)

    # Plot histogram for transformed outcome
    hist(df[[outcome]], main = paste("Histogram of", outcome))
    hist(df[[outcome_log]], main = paste("Histogram of Log-transformed", outcome))

    # GAMM model with hormone z-scores and derivatives
    gamm_formula <- as.formula(paste0(
      outcome_log, " ~ s(id, bs = \"re\") + s(E2zd) +",
      " s(P4zd)  + ti(E2zd, P4zd) +",
      " s(E2zch) + s(P4zch)"
    ))

    gamm_model <- gam(
      gamm_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Summary and plot of the model
    model_summary <- summary(gamm_model)
    print(model_summary)

    # Save the model summary as a text file
    summary_output <- capture.output(model_summary)
    summary_file_path <- file.path(save_dir, paste0(outcome, "_fixed__wzch_85_model_EP_summary.txt"))
    writeLines(summary_output, summary_file_path)
    cat("Model summary saved to:", summary_file_path, "\n")

    # Plot the GAMM effects
    plot.gam(gamm_model, select = 2, main = paste("Estrogen Effect on", outcome))
    plot.gam(gamm_model, select = 3, main = paste("Progesterone Effect on", outcome))
   plot.gam(gamm_model, select = 5, main = paste("Estrogen Change Effect on", outcome))
   plot.gam(gamm_model, select = 6, main = paste("Progesterone Change Effect on", outcome))

    # Simpler model without random effects for visualization
    gamm_simple_formula <- as.formula(paste0(
      outcome_log, " ~ s(E2zd) + s(P4zd) + ti(E2zd, P4zd)"
    ))

    gamm_model_simple <- gam(
      gamm_simple_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Create the grid for contour plot
    grid <- expand.grid(
      E2zd = seq(
        min(df$E2zd, na.rm = TRUE),
        max(df$E2zd, na.rm = TRUE),
        length.out = 100
      ),
      P4zd = seq(
        min(df$P4zd, na.rm = TRUE),
        max(df$P4zd, na.rm = TRUE),
        length.out = 100
      )
    )

    # Predict values
    grid$predicted <- predict(gamm_model_simple,
                              newdata = grid,
                              type = "response",
                              transform = function(x) exp(x) - 1)

    # Contour plot
    plot_title <- paste("Predicting", outcome, "from E2 and P4 (Person Standardized)")
    contour_plot <- ggplot() +
      geom_tile(data = grid, aes(x = E2zd, y = P4zd, fill = predicted)) +
      geom_contour(data = grid, aes(x = E2zd, y = P4zd, z = predicted), color = "black") +
      geom_point(data = df, aes(x = E2zd, y = P4zd), color = "black", alpha = 0.25) +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(grid$predicted)) +
      labs(x = "E2zd", y = "P4zd", fill = "Outcome") +
      theme_minimal() +
      ggtitle(plot_title)

    print(contour_plot)

    # Save the contour plot
    plot_file_path <- file.path(save_dir, paste0(outcome, "_85_wzch_fixed.png"))
    ggsave(filename = plot_file_path, plot = contour_plot, width = 8, height = 6)
    cat("Contour plot saved to:", plot_file_path, "\n")
  }
}

# CALL THE LOOP


create_gamm_models(dv_list, df, output_folder)

```

# Looping through hormone effects - FIXED E2zd*P4zd TENSOR PRODUCT SMOOTH
#TODO - need to figure out how to add the intercept back to the 3dplot because the estimates are wrong due to that

```{r}
library(plotly)
library(htmlwidgets)

# Function to Loop Through Outcomes and Generate GAMM Models
create_gamm_models <- function(dv_list, df, save_dir) {
  for (outcome in dv_list) {
    # Prepare variables dynamically
    outcome_log <- paste0(outcome, "log")
    df[[outcome_log]] <- log(df[[outcome]] + 1)

    # Plot histogram for transformed outcome
    hist(df[[outcome]], main = paste("Histogram of", outcome))
    hist(df[[outcome_log]], main = paste("Histogram of Log-transformed", outcome))

    # GAMM model with hormone z-scores and derivatives
    gamm_formula <- as.formula(paste0(
      outcome_log, " ~ s(id, bs = \"re\") + te(E2zd, P4zd)"
    ))

    gamm_model <- gam(
      gamm_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Summary and plot of the model
    model_summary <- summary(gamm_model)
    print(model_summary)
    
    # Step 5: Perform hierarchical partitioning
  var_part <- gam.hp::gam.hp(gamm_model)
  print(model_summary)
  print(var_part$hierarchical.partitioning)

  # Step 6: Capture the output for both model summary and hierarchical partitioning
  summary_output <- capture.output(model_summary)
  partitioning_output <- capture.output(var_part$hierarchical.partitioning)

  # Step 7: Combine the model summary and hierarchical partitioning results
  combined_output <- c(summary_output, "", "Hierarchical Partitioning:", partitioning_output)

  # Step 8: Write to file
  summary_file_path <- file.path(output_folder, paste0("gamm_HORMS_hp_", dv, ".txt"))
  writeLines(combined_output, summary_file_path)
    cat("Model summary saved to:", summary_file_path, "\n")

    # Plot the GAMM effects
   # plot.gam(gamm_model, select = 2, main = paste("Estrogen Effect on", outcome))
   # plot.gam(gamm_model, select = 3, main = paste("Progesterone Effect on", outcome))
  # plot.gam(gamm_model, select = 5, main = paste("Estrogen Change Effect on", outcome))
  # plot.gam(gamm_model, select = 6, main = paste("Progesterone Change Effect on", outcome))

    # Simpler model without random effects for visualization
    gamm_simple_formula <- as.formula(paste0(
      outcome_log, " ~ te(E2zd, P4zd)"
    ))

    gamm_model_simple <- gam(
      gamm_simple_formula,
      data = df,
      family = gaussian,
      method = "REML"
    )

    # Create the grid for contour plot
    grid <- expand.grid(
      E2zd = seq(
        min(df$E2zd, na.rm = TRUE),
        max(df$E2zd, na.rm = TRUE),
        length.out = 100
      ),
      P4zd = seq(
        min(df$P4zd, na.rm = TRUE),
        max(df$P4zd, na.rm = TRUE),
        length.out = 100
      )
    )

    # Predict values
    grid$predicted <- predict(gamm_model_simple,
                              newdata = grid,
                              type = "response",
                              transform = function(x) exp(x) - 1)

    # Contour plot
    plot_title <- paste("Predicting", outcome, "from E2 and P4 (Person Standardized)")
    contour_plot <- ggplot() +
      geom_tile(data = grid, aes(x = E2zd, y = P4zd, fill = predicted)) +
      geom_contour(data = grid, aes(x = E2zd, y = P4zd, z = predicted), color = "black") +
      geom_point(data = df, aes(x = E2zd, y = P4zd), color = "black", alpha = 0.25) +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(grid$predicted)) +
      labs(x = "E2zd", y = "P4zd", fill = "Outcome") +
      theme_minimal() +
      ggtitle(plot_title)

    print(contour_plot)

    # Save the contour plot
    plot_file_path <- file.path(save_dir, paste0(outcome, "_te_zd_fixed.png"))
    ggsave(filename = plot_file_path, plot = contour_plot, width = 8, height = 6)
    cat("Contour plot saved to:", plot_file_path, "\n")
    
     # Create the 3D surface plot using Plotly
    grid_matrix <- matrix(grid$predicted, nrow = 100, byrow = TRUE)
    surface_plot <- plot_ly(
      x = seq(min(df$E2zd, na.rm = TRUE), max(df$E2zd, na.rm = TRUE), length.out = 100),
      y = seq(min(df$P4zd, na.rm = TRUE), max(df$P4zd, na.rm = TRUE), length.out = 100),
      z = ~grid_matrix
    ) %>%
      add_surface() %>%
      layout(
        title = paste("3D Surface Plot of E2zd and P4zd Interaction for", outcome),
        scene = list(
          xaxis = list(title = "E2zd"),
          yaxis = list(title = "P4zd"),
          zaxis = list(title = "Predicted Outcome")
        )
      )

    # Save the interactive surface plot as an HTML file
    surface_plot_file_path <- file.path(save_dir, paste0(outcome, "_zd_3D_surface.html"))
    saveWidget(surface_plot, surface_plot_file_path)
    cat("3D surface plot saved to:", surface_plot_file_path, "\n")
  }
}


# CALL THE LOOP

create_gamm_models(dv_list, df=df, save_dir=output_folder)

```

