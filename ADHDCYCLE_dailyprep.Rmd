---
title: "ADHDCYCLE_dailyprep"
output: 
  html_document: 
    toc: true
    fig_caption: true
    number_sections: true
    df_print: default
date: "Last compiled on `r format(Sys.time(), '%B %d, %Y')`"
---

# Setup

```{r Packages}

knitr::opts_chunk$set(echo = TRUE)

library(dplyr) # Data manipulation
library(tidyr) # Tidying data
library(haven) # Reading files (SPSS, stata, SAS)
library(ggplot2) # Plotting
library(tidyverse) # Data management and manipulation
library(zoo) # Rolling averages
library(readxl) # Reading Excel files
library(lme4) # Mixed-effects models
library(lmerTest) # Mixed-effects models with p-values
library(emmeans) # Estimated marginal means
library(psych) # Descriptive statistics
library(lubridate) # Date and time manipulation
library(visdat) # Visualizing missing data
library(janitor) # Cleaning data
library(skimr) # Skimming data for summary statistics
library(ggdist) # Visualizing distributions and uncertainty
library(ggforce) # Extending ggplot2
library(sjPlot) # Plotting for statistical models
library(grid) # Base graphics
library(gridExtra) # Arranging grid-based graphics
library(usethis) # Setting up GitHub and other project tools
library(nlme) # Linear and nonlinear mixed-effects models
library(performance) # Model performance metrics
library(rmcorr) # Repeated measures correlations
library(gitcreds) # Managing Git credentials
library(see) # Visualizing model checking functions
library(corrplot) # Visualizing correlations
library(GPArotation) # Factor analysis rotations
library(broom.mixed) # Tidying mixed models
library(pbkrtest) # Parametric bootstrap and Kenward-Roger methods
library(ggrepel) # Adding text labels to ggplot2
library(zoo)
library(careless)
library(responsePatterns)
library(dplyr)
library(tidyverse)
library(readxl)
library(tidyverse)
library(readxl)
library(ggplot2)
library(dplyr)
library(tidyr)
library(haven)

```

```{r Load Data}

## Raw daily data, merged to include surveys and hormones 

df <- read.csv("~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/02_datasets/CYCADHD_DAILY/01_raw_data/2024.04.24. Daily Master.csv")

```


```{r}
 # Convert date_rated to Date type
  df$date_rated <- as.Date(mdy(df$date_rated))

```

# Remove NA rows
```{r}
#remove rows where all data is NA
df <- df[rowSums(is.na(df)) != ncol(df), ]

#remove NA ID's from dataset
df <- df %>% filter(!is.na(id))

#remove NA daterated from dataset 
df <- df %>% filter(!is.na(date_rated))

# NUMBER OF ROWS

print(nrow(df))

```

# Sort by id and date_rated and save
```{r}
df <- df %>% arrange(id, date_rated, .na.last = FALSE)

##View(df)
```


#Hard-code changes to issues found later 
```{r}

#Add 208 Menses start date 
df$StartPeriod[df$id == 208 & df$TubeNumber == 27] <- 1
#df %>% filter(id==208) %>% View()

df$date_rated[df$id == 210 & df$date_rated == 11/20/2021] <- 11/20/2020
df$date_rated[df$id == 210 & df$date_rated == 11/21/2021] <- 11/21/2020
#df %>% filter(id==210) %>% View()

##View(df)

#Template Code to look at one pt's data

#df %>% filter(id==307) %>% View()

#ADDITIONAL DATA REVIEW NEEDED FOR HORMONES: 

# Filtering template: df <- df %>% filter(!is.na(id))

#Note that 307's ovulation might be a little off with their hormones
#Consider excluding participant 235
#Review participant 273's progesterone data
#Review participant 278's progesterone data
#Review participant 317's estrogen data
#Review participant 221's hormone data
#Review participant 243's hormone data
#Review participant 267's hormone data
#Review participant 272's hormone data
#Review participant 283's hormone data
#Review participant 305's hormone data
#Review participant 312's hormone data

badhorm_ids <- c(221, 235, 243, 267, 272, 273, 278, 283, 305, 307, 312, 317)

```


# Add row placeholders for missing survey/date_rated's
```{r}

df <- df %>% group_by(id) %>%
  complete(date_rated = seq.Date(min(date_rated), max(date_rated), by = "day"))

##View(df)

# NUMBER OF ROWS
print(nrow(df))

```

# Rename Hormones
```{r RENAME}
# Rename the columns
colnames(df)[colnames(df) == "Estradiol"] <- "E2"
colnames(df)[colnames(df) == "Progesterone"] <- "P4"
```

## Calculate BAARS ADHD Current Symptom Scale CSS Scores, UPPS, BDEFS, DEBQ
```{r calc CSS UPPS BDEFS DEBQ}

#CSS_Total - Overall total score on the current symptoms scale
#CSS_TotalSymp - Total ADHD symptom score (inattention + hyperactivity-impulsivity)
#CSS_B_TotalIASymp - Total inattention symptoms score 
#CSS_B_TotalHISymp - Total hyperactivity-impulsivity symptoms score 

#CSS_TotalCount - Total count of all ADHD symptoms (inattention + hyperactivity-impulsivity)
#CSS_Inatt_Count - Count of inattention symptoms
#CSS_Imp_Count - Count of impulsivity symptoms
#CSS_Hyp_Count - Count of hyperactivity symptoms

#CSS_Fx_Total - ???????
#CSS_B2_Total - ???????

# Reverse UPPS Items 7 and 8
df <- df %>%
  mutate(UPPS_7r=recode(UPPS_7, '1' = 4, '2' = 3, '3' = 2, '4' = 1), UPPS_8r=recode(UPPS_8, '1' = 4, '2' = 3, '3' = 2, '4' = 1))

# Drop original items UPPS_7 and UPPS_8

df <- df %>% select(-UPPS_7)
df <- df %>% select(-UPPS_8)


df <- df %>%
  group_by(id) %>%
  mutate(
    # CSS Symptom severity Scores
    
    # Calculate Inattention Severity: 
    CSS_Inatt = rowSums(across(c(CSS_B_1, CSS_B_3, CSS_B_5, CSS_B_7, CSS_B_9, CSS_B_11, CSS_B_13, CSS_B_15, CSS_B_17)), na.rm = TRUE),
    
    # Calculate Hyperactivity/Impulsivity Severity: 
    CSS_HypImp = rowSums(across(c(CSS_B_2, CSS_B_4, CSS_B_6, CSS_B_8, CSS_B_10, CSS_B_12, CSS_B_14, CSS_B_16, CSS_B_18)), na.rm = TRUE),
    
    # Function items 1-10
    CSS_Fx_Total = rowSums(across(starts_with("CSS_Function_")), na.rm = TRUE),
    
    # Not sure what this is (todo)
    CSS_B2_Total = rowSums(across(starts_with("CSS_B2_")), na.rm = TRUE),
    
    # CSS Count Variables
    CSS_Inatt_Count = rowSums(across(c(CSS_1_Count, CSS_3_Count, CSS_5_Count, CSS_7_Count, CSS_9_Count, CSS_11_Count, CSS_13_Count, CSS_15_Count, CSS_17_Count)), na.rm = TRUE),
    
    CSS_HypImp_Count = rowSums(across(c(CSS_2_Count, CSS_4_Count, CSS_6_Count, CSS_8_Count, CSS_10_Count, CSS_12_Count, CSS_14_Count, CSS_16_Count, CSS_18_Count)), na.rm = TRUE),
    
    # Other Daily Scored Scales
    DEBQ_Total = rowSums(across(starts_with("DEBQ_")), na.rm = TRUE),
    BDEFS_Total = rowSums(across(starts_with("BDEFS_")), na.rm = TRUE),
    UPPS_Total = rowSums(across(starts_with("UPPS_")), na.rm = TRUE)
  ) %>%
  ungroup()

```

# SCREENING FOR CARELESS RESPONDING OR RESPONSE SETS
```{r}

# The Longstring Index:

df <- df %>% mutate(longstring = longstring(df))
df <- df %>% mutate(avgstring = (longstring(df, avg = T)))


#df %>% arrange(desc(longstring)) %>% select(id, date_rated, longstring, avgstring) %>% View()


careless_long <- longstring(df)
boxplot(careless_long, main = "Boxplot of Longstring index")

#careless_long <- longstring(df, avg = T)
#boxplot(careless_long$avg, main = "Boxplot of Averagestring index")

# The IRV: The intra-individual response variability (IRV) is similiar in spirit to the Longstring index. It is defined as the “standard deviation of responses across a set of consecutive item responses for an individual” (Dunn et al. 2018).

#careless_irv <- irv(df, split = TRUE, num.split = 4)
#head(careless_irv)

```

### Create functions to create person means and person deviations
```{r echo=T}

#function to create person means
create.person.mean <- function(df, var, ...) {
  df %>%
    group_by(...) %>%
    mutate("{{var}}.m" := mean({{var}}, na.rm=T))
}
#function to create person deviations (note, must have person means already made)
create.deviation <- function(df, var, var.m) {
  df <- df %>%
    rowwise() %>%
    mutate("{{var}}.d" := {{var}} - {{var.m}})
}

create.3day.rolling.avg <- function(df, var, num) {
  df %>%
    group_by(id) %>%
    mutate("{{var}}.roll" := rollapply({{var}}, 3,  mean, align="center", fill=NA))
}

```


## create outcome lists to loop through functions
```{r echo=T}

#person-centered deviations
outcomelist <- c("E2",
           "P4",
           "LH",
           "CSS_Fx_Total",
           "CSS_B2_Total",
           "CSS_Inatt",
           "CSS_HypImp",
           "CSS_Inatt_Count",
           "CSS_HypImp_Count",
           "BDEFS_Total", 
           "UPPS_Total",
          "longstring",
           "DEBQ_Total") %>% noquote()

#person-centered deviations
outcomelist.d <- c("E2.d",
           "P4.d",
           "LH.d",
           "CSS_Fx_Total.d",
           "CSS_B2_Total.d",
           "CSS_Inatt.d",
          "CSS_Inatt_Count.d",
           "CSS_HypImp.d",
           "CSS_HypImp_Count.d",
           "BDEFS_Total.d", 
           "UPPS_Total.d",
          "longstring.d",
           "DEBQ_Total.d"
           ) %>% noquote()

#rolling averages
outcomelist.roll <- c("E2.roll",
"P4.roll",
"LH.roll",
"CSS_Fx_Total.roll",
"CSS_B2_Total.roll",
"CSS_Inatt.roll",
"CSS_HypImp.roll",
"CSS_Inatt_Count.roll",
"CSS_HypImp_Count.roll",
"BDEFS_Total.roll", 
           "UPPS_Total.roll",
"longstring.roll",
           "DEBQ_Total.roll"
) %>% noquote()

#View(df)


```

```{r}

#ROLLING AVGS

#create rolling averages on RAW variables
for (i in outcomelist) {
  df <- create.3day.rolling.avg(df, !!sym({{i}}), 3)
}

#MEANS

#execute for loop: run create.person.mean() on everything in "outcomelist.roll"
for (i in outcomelist.roll) {
  df <- create.person.mean(df, !!sym({{i}}), id)
}

#execute for loop: run create.person.mean() on everything in "outcomelist"
for (i in outcomelist) {
  df <- create.person.mean(df, !!sym({{i}}), id)
}

#PERSON-DEVIATIONS

#for raw deviations
#execute for loop: run create.deviation() on everything in list
for (i in outcomelist) {
  df <- create.deviation(df, !!sym({{i}}), !!sym(paste0({{i}}, ".m")))
}

#for rolling avgs deviations
#execute for loop: run create.deviation() on everything in list
for (i in outcomelist.roll) {
  df <- create.deviation(df, !!sym({{i}}), !!sym(paste0({{i}}, ".m")))
}


#Check 
df %>% select(id, E2, E2.m, E2.d, E2.roll, E2.roll.d) %>% View()

```

# Print Variable Names
```{r printvars}
variable_names <- names(df)
formatted_list <- paste(variable_names, collapse = ", ")
cat(formatted_list)
```

# Create dichotomous mensdayone/mensdayonefirst to indicate first day of period
```{r }


str(df$id) #check id format
str(df$date_rated) #check date_rated format

df <- df %>%
  filter(!is.na(id))

df <- df %>%
  arrange(id, date_rated)


df$StartPeriod <- as.numeric(df$StartPeriod)

df <- df %>%
  mutate(mensdayone = case_when(
    is.na(StartPeriod) ~ NA_real_,
    StartPeriod == 1 ~ 1,
    TRUE ~ 0
  ))


# Eliminate all but the first menses onset day in a new variable called "mensdayonefirst"

# Process the data
df <- df %>%
  arrange(id, date_rated) %>%  # Arrange the data by id and date_rated
  group_by(id) %>%  # Group the data by id
  mutate(
    mensdayonefirst = case_when(
      is.na(mensdayone) ~ NA,
      mensdayone == 1 & (lag(mensdayone, order_by = date_rated) != 1 | is.na(lag(mensdayone, order_by = date_rated))) ~ 1,
      row_number() == 1 & mensdayone == 1 ~ 1,
      TRUE ~ 0
    )
  ) %>% 
  ungroup() # Remove the grouping

#Check

#df %>% select(id, date_rated, mensdayone, mensdayonefirst, PosLHTest) %>% View()


```

# Create "LHposday" (0/1/NA) that represents the positive LH day.
```{r }

###View(df)
  
  df$PosLHTest <- as.numeric(df$PosLHTest)

df <- df %>%
  mutate(LHposday = case_when(
    is.na(PosLHTest) ~ NA_real_,
    PosLHTest == 1 ~ 1,
    TRUE ~ 0
  ))

###View(df)

# Eliminate all but the first pos Ov day in a new variable called "LHposdayfirst"
df <- df %>%
  arrange(id, date_rated) %>%  # Arrange the data by id and date_rated
  group_by(id) %>%  # Group the data by id
  mutate(
    LHposdayfirst = case_when(
      is.na(LHposday) ~ NA_real_,
      LHposday == 1 & lag(LHposday, order_by = date_rated) != 1 ~ 1,
      TRUE ~ 0
    )
  ) %>% 
  ungroup()  # Remove the grouping

#Check vars
#df %>% select(id, date_rated, mensdayonefirst, LHposdayfirst) %>% View()

```

# Remove people who never had a positive LH test
```{r}

# Create a person-level variable
idlhpos <- df %>%
  group_by(id) %>% 
  summarise(LHeverpos = ifelse(sum(LHposdayfirst, na.rm = TRUE) > 0, 1, 0)) %>% 
  ungroup()

# Merge it back into df
df <- df %>%
  left_join(idlhpos, by = "id")

# Filter out people with LHids = 0
df <- df %>%
  filter(LHeverpos == 1)

#Check vars
df %>% select(id, LHeverpos, date_rated, mensdayonefirst, LHposdayfirst) %>% head()

```

# Code Cycle Day Forward + Backward count from menses onset
```{r cycleday}

#make A as a variable copy of mensdayonefirst
df$A <- df$mensdayonefirst

cycleCount <- function(x) {
  #Get the index of 1
  inds <- which(x == 1)
  if(!length(inds)) return(0) 
  #Create a sequence with that index as 0
  num <- lapply(inds, function(i) {
    num <- seq_along(x) - i
    #Add 1 to values greater than equal to 0
    num[num >= 0] <- num[num >= 0] + 1
    num[num < -15 | num > 11] <- NA 
    num
  })
  #Select the first non-NA values from the sequence
  do.call(coalesce, num)
}

df <- df %>% group_by(id) %>% 
  mutate(cycleday = cycleCount(A))

#df <- df %>% select(!A)

###View(df)

#Check vars
#df %>% select(id, LHeverpos, date_rated, mensdayonefirst, LHposdayfirst, cycleday) %>% View()

```

# Review Data, looking for cycleday=0 and removing those who never had any menses onsets
```{r}

#View in a separate window and manually scroll through
df %>% select(id, date_rated, mensdayonefirst, cycleday, LHposdayfirst, cycleday) %>% View()

#how many observations do you have for each cycle day?
nobs <- df %>% group_by(cycleday) %>% summarize(n=n())

##View(nobs)

#do you have any observations that got assigned a cycle day of 0? this is wrong, and you should check who that happened for
df %>% filter(cycleday==0) %>% pull(id)

# NOTE 2024-07-09: There are 2 people with lots of zeroes (see Jordan's note above in chunk) and it looks to me like they did not report a menses in the daily dataset: 331, 332. They have no menses onset dates

#View in a separate window and manually scroll through
#df %>% select(id, date_rated, mensdayonefirst, cycleday, LHposdayfirst, cycleday) %>% View()

# List of IDs to remove
ids_to_remove <- c(331, 332)

# Remove rows with specified IDs
df <- df %>% filter(!(id %in% ids_to_remove))


```

# Make daycountLH, based on positive LH test (LH test day = 0)
```{r daycountLH}
#make A a new temp column where pt received pos ov test
df$L <- df$LHposdayfirst

#FUNCTION for calculating the sequence
LHCount <- function(x) {
  #Get the index of 1
  inds <- which(x == 1)
  if(!length(inds)) return(0) 
  #Create a sequence with that index as 0
  num <- lapply(inds, function(i) {
    num <- seq_along(x) - i
    num[num < -7 | num > 15] <- NA 
    num
  })
  #Select the first non-NA values from the sequence
  do.call(coalesce, num)
}

#run the LHCount function and save it as as a new column called daycountLH
df<- df %>% group_by(id) %>% 
  mutate(daycountLH = LHCount(L))
#remove the temp column L
df <- df %>% select(!L)

#Check vars
#df %>% select(id, LHeverpos, date_rated, mensdayonefirst, LHposdayfirst, daycountLH) %>% View()
```

# View the number of observations for each cycleday
```{r daycountLH checking}

#how many daily ratings got assigned each cycle day?
nobs2 <- df %>% group_by(daycountLH) %>% summarize(n=n())

#View(nobs2)

```

# Cycle Phase Coding - MENSES COUNT PART
reminder: dummy code comes from Schmalenberger 2021 appendix
```{r cyclephase_count}

df <- df %>% 
  mutate(midluteal_count = ifelse(cycleday >= -9 & cycleday <= -5, 1, 0),
         perimenstrual_count = ifelse(cycleday >=-3 & cycleday <=2, 1, 0),
         midfol_count = ifelse(cycleday >=4 & cycleday <=7, 1, 0),
         periov_count = ifelse(cycleday >= -15 & cycleday <= -12, 1, 0))

#add a non-dummy coded variable with all of cycle phase info above, which will be useful for future visualizations and summaries
df <- df %>% mutate(cyclephase_count = case_when(periov_count==1 ~ 1,
                                                     midluteal_count==1 ~ 2,
                                                     perimenstrual_count==1 ~ 3,
                                                     midfol_count==1 ~ 4,
                                                     TRUE ~ as.numeric(NA)))

#Check vars
#df %>% select(id, mensdayonefirst, LHposdayfirst, cycleday, daycountLH, ends_with("_count")) %>% View()

```

# Cycle Phase Coding - LH COUNT PART
```{r cyclephase_LH}

#note: the perimenstrual phase is still coded based on menses count variable, but for the purpose of keeping the dummy code labeling clear, we name it *perimenstrual_LH* to indicate that this variable gets included in the dummy code set of LH-based phasing; again, all of this information is from Schmalenberger 2021 appendix

df <- df %>% 
  mutate(midluteal_LH = ifelse(daycountLH >= 6 & daycountLH <= 11, 1, 0),
         perimenstrual_LH = ifelse(cycleday >=-3 & cycleday <=2, 1, 0), #note perimenstrual is based on cycleday
         midfol_LH = ifelse(daycountLH >=-7 & daycountLH <=-3, 1, 0),
         periov_LH = ifelse(daycountLH >= -2 & daycountLH <= 1, 1, 0),
         earlylut_LH = ifelse(daycountLH >= 2 & daycountLH <= 5, 1, 0))

#fill out the dummy code, so that if any phase is 1, all others should be 0 (not NA)
df <- df %>%
  rowwise() %>%
  mutate(sumdummy = sum(midfol_LH,
                        periov_LH,
                        earlylut_LH,
                        perimenstrual_LH,
                        midluteal_LH, na.rm = T)) %>% 
  #if all phases=0, make the midluteal_LH variable NA instead of 0,
  #if perimenstrual by menses count = 1, change midluteal_LH to 0 instead of NA to fill out structural set,
  #otherwise, keep as is
  mutate(midluteal_LH = case_when(sumdummy==0 ~ as.numeric(NA),
                                  sumdummy==1 & perimenstrual_LH==1 ~ 0,
                                  TRUE ~ midluteal_LH), 
         #same for midfol
         midfol_LH = case_when(sumdummy==0 ~ as.numeric(NA),
                               sumdummy==1 & perimenstrual_LH==1 ~ 0,
                               TRUE ~ midfol_LH), 
          #same for periov
         periov_LH = case_when(sumdummy==0 ~ as.numeric(NA),
                               sumdummy==1 & perimenstrual_LH==1 ~ 0,
                               TRUE ~ periov_LH),
         earlylut_LH = case_when(sumdummy==0 ~ as.numeric(NA),
                                  sumdummy==1 & perimenstrual_LH==1 ~ 0,
                                  TRUE ~ earlylut_LH), 
         #if any other phase is 1, fill out perimenstrual to be 0
         perimenstrual_LH = case_when(sumdummy==0 ~ as.numeric(NA), 
                                        sumdummy==1 & midfol_LH==1 ~ 0,
                                        sumdummy==1 & periov_LH==1 ~ 0,
                                      sumdummy==1 & earlylut_LH==1 ~ 0,
                                        sumdummy==1 & midluteal_LH==1 ~ 0,
                                        TRUE ~ perimenstrual_LH))

#add cyclephase_LH, a new categorical variable made from all of the new hybrid cycle phases above, which will be useful for future visualizations and summaries
df <- df %>% mutate(cyclephase_LH = case_when(periov_LH==1 ~ 1,
                                                                        earlylut_LH==1 ~ 2,
                                                     midluteal_LH==1 ~ 3,
                                                     perimenstrual_LH==1 ~ 4,
                                                     midfol_LH==1 ~ 5,
                                                     TRUE ~ as.numeric(NA)))

df <- df %>% mutate(cyclephase_LH_graph = case_when(midfol_LH==1 ~ 1,
                                                    periov_LH==1 ~ 2,
                                                    earlylut_LH==1 ~ 3,
                                                     midluteal_LH==1 ~ 4,
                                                     perimenstrual_LH==1 ~ 5,
                                                     TRUE ~ as.numeric(NA)))

#Check vars
#df %>% select(id, mensdayonefirst, LHposdayfirst, cycleday, daycountLH, ends_with("_LH")) %>% View()



#Coding additional binary variables for use in random effects that contrast each phase with all other phases for simplicity

#nonperi (1) vs. peri (0)
df <- df %>%
  mutate(NONPERI = case_when(cyclephase_LH=="1" ~ "1", #periov
                                    cyclephase_LH=="2" ~ "1", #earlylut
                                    cyclephase_LH=="3" ~ "1", #midlut
                                    cyclephase_LH=="4" ~ "0", #perimens
                                    cyclephase_LH=="5" ~ "1")) #midfol

#nonmid (1) vs. mid (0)
df <- df %>%
  mutate(NONMid = case_when(cyclephase_LH=="1" ~ "1", #periov
                                    cyclephase_LH=="2" ~ "1", #earlylut
                                    cyclephase_LH=="3" ~ "0", #midlut
                                    cyclephase_LH=="4" ~ "1", #perimens
                                    cyclephase_LH=="5" ~ "1")) #midfol

#nonel (1) vs. el (0)
df <- df %>%
  mutate(NONEL = case_when(cyclephase_LH=="1" ~ "1", #periov
                                    cyclephase_LH=="2" ~ "0", #earlylut
                                    cyclephase_LH=="3" ~ "1", #midlut
                                    cyclephase_LH=="4" ~ "1", #perimens
                                    cyclephase_LH=="5" ~ "1")) #midfol

#nonperiov (1) vs. periov (0)
df <- df %>%
  mutate(NONPERIOV = case_when(cyclephase_LH=="1" ~ "0", #periov
                                    cyclephase_LH=="2" ~ "1", #earlylut
                                    cyclephase_LH=="3" ~ "1", #midlut
                                    cyclephase_LH=="4" ~ "1", #perimens
                                    cyclephase_LH=="5" ~ "1")) #midfol

#nonmidfol (1) vs. midfol (0)
df <- df %>%
  mutate(NONMidFOL = case_when(cyclephase_LH=="1" ~ "1", #periov
                                    cyclephase_LH=="2" ~ "1", #earlylut
                                    cyclephase_LH=="3" ~ "1", #midlut
                                    cyclephase_LH=="4" ~ "1", #perimens
                                    cyclephase_LH=="5" ~ "0")) #midfol


# New vars = NONPERI, NONMid, NONEL, NONPERIOV, NONMidFOL

```

# REVIEW FOR OVERLAPPING CYCLE PHASE CODING
-when using LH-based phasing for all 4 phases, the most likely possibility for overlap is a day that got labeled midfollicular by LH-count and perimenstrual by menses count. *Perimenstrual_count trumps midfollicular by LH count* in this instance. any other overlaps within the dummy code are likely miscoded or an abnormal cycle.
```{r}

#check overlaps: goal is to only have 6 possible group combinations here (1 row per dummy coded phase, then a row where ALL are NA)

df %>%
  group_by(periov_LH, earlylut_LH, midluteal_LH, perimenstrual_LH, midfol_LH) %>%
  summarize(n=n())

#make note of errors - Tory 7/9/24
# peri and midfol = 9
# midlut and peri- 87
# earlylut and peri = 3
# periov and perimens = 64

#example code to review midfol_LH and perimenstrual_LH overlaps, if they exist

df %>%
  filter(midfol_LH==1) %>%
  filter(perimenstrual_LH==1) %>%
  select(id, date_rated, LHposdayfirst, daycountLH,
         mensdayonefirst, cycleday,
         midfol_LH, periov_LH, earlylut_LH,
         midluteal_LH, perimenstrual_LH) %>% View()

#in CLEAR studies, we are looking to see if the day in question is at the early end of the follicular phase as estimated by counting the days prior to ovulation
#example: if the day in question is -7 by LH count and +2 by menses count, this was a short follicular phase, and is probably OK to be included, but needs to be recoded as "perimenstrual" (see below)



```

# N=1 - MIFOL AND PERI --> REVIEWING AND FIXING OVERLAPS
```{r}
#View overlapping DAYS Dataset (N=9: )

df %>% filter(midfol_LH==1 & perimenstrual_LH==1) %>% 
  select(id, date_rated, daycountLH, cycleday, midfol_LH, perimenstrual_LH) %>% View()

# Output a list of IDs with overlap
midfol_peri_overlaps <- df %>% filter(midfol_LH==1 & perimenstrual_LH==1) %>% 
  distinct(id) %>% 
  pull(id)

print(midfol_peri_overlaps)

# 7/9/24: 216, 222, 241, 251, 324

# I will replace all of these such that peri wins

df  <- df  %>%
  mutate(midfol_LH = case_when(perimenstrual_LH==1 ~ 0,
                                        TRUE ~ midfol_LH)) 


# Filter the dataframe to check for leftover overlaps
filtered_df <- df %>% 
  filter(midfol_LH == 1 & perimenstrual_LH == 1)

# Output a list of ids that still overlap
id_list <- filtered_df %>% pull(id)
id_list

```

# NONE - MIDLUTEAL AND PERI --> REVIEWING AND FIXING OVERLAPS
```{r}
#review midlut and perimens overlaps - can override midluteal with perimens IF luteal phase is short but still seems normal (such as 9-11 days)

## make notes of any SUPER short luteal phases (like 4-5 days) that you might want to flag for anovulation

#df %>% filter(midluteal_LH==1 & perimenstrual_LH==1) %>% select(id, date_rated, daycountLH, cycleday, midluteal_LH, perimenstrual_LH) %>% View()

#OVERRIDE MIDLUTEALS WITH PERIs:

df  <- df  %>%
  #if perimenstrual by firstdayofperiod and midlut by count after LH test are both 1, perimen wins, make midlut=0
  mutate(midluteal_LH = case_when(perimenstrual_LH==1 ~ 0,
                                        TRUE ~ midluteal_LH)) 

# Filter the dataframe to check for leftover overlaps
filtered_df <- df %>% 
  filter(midfol_LH == 1 & perimenstrual_LH == 1)

# Output a list of ids that still overlap
id_list <- filtered_df %>% pull(id)
id_list

```

# NONE - EARLY-LUTEAL AND PERI --> REVIEWING AND FIXING OVERLAPS
```{r}

df %>% filter(earlylut_LH==1 & perimenstrual_LH==1) %>% 
  select(id, date_rated, mensdayonefirst, LHposdayfirst, daycountLH, cycleday, earlylut_LH, perimenstrual_LH) %>% View()

#df %>% filter(id==222) %>% View()

#good practice to review again and ensure that dummy code is fixed

df %>%
  group_by(periov_LH, earlylut_LH, midluteal_LH, perimenstrual_LH, midfol_LH) %>%
  summarize(n=n())
```

# Identify participants who still have overlapping cycle phases
```{r eval=FALSE, include=FALSE}

participants_with_multiple_LH <- df %>%
  rowwise() %>%
  mutate(sum_LH = sum(c(midfol_LH, periov_LH, earlylut_LH, midluteal_LH, perimenstrual_LH) == 1)) %>%
  filter(sum_LH > 1) %>%
  ungroup() %>%
  distinct(id)

# Filter the original dataset to include all observations of the identified participants so you can view their cycle and count data to see where the errors are

review_these <- df %>%
  filter(id %in% participants_with_multiple_LH$id)

review_these %>% select(id, mensdayonefirst, LHposdayfirst, cycleday, daycountLH, midfol_LH, periov_LH, earlylut_LH, midluteal_LH, perimenstrual_LH) %>% View()

# NONE

# Extract the list of IDs with overlaps
id_list <- participants_with_multiple_LH$id

# Print the list of IDs as a comma-separated string
id_list_string <- paste(id_list, collapse = ", ")
cat(id_list_string)

```
 
# Count participants and rows
```{r CountIDs}

# Count how many remaining ids I have in the dataset
unique_id_count <- length(unique(df$id))
# Print the number of unique IDs
print(unique_id_count)

# NUMBER OF ROWS
print(nrow(df))
```

# Calculate "Hybrid" CycleDay 
```{r}
#create hybrid version of cycle day:
df <- df %>%
  mutate(hybridcycleday = case_when((daycountLH >= -7 & daycountLH <= 5) ~ 
                                      paste(as.character(daycountLH), "L", sep = ""),
                                 (cycleday >= -9 & cycleday <= 7) ~ 
                                   paste(as.character(cycleday), "M",  sep = ""),
                                 TRUE ~ NA_character_))

df <- df %>%
  filter(!is.na(hybridcycleday)) %>%
  arrange(id, date_rated)

hybridcycleday_order <- c("-7L",
                       "-6L",
                       "-5L",
                       "-4L",
                       "-3L",
                       "-2L",
                       "-1L",
                       "0L",
                       "1L",
                       "2L",
                       "3L",
                       "4L",
                       "5L",
                       "-9M",
                       "-8M",
                       "-7M",
                       "-6M",
                       "-5M",
                       "-4M",
                       "-3M",
                       "-2M",
                       "-1M",
                       "1M",
                       "2M",
                       "3M",
                       "4M",
                       "5M",
                       "6M",
                       "7M")
```






#FUNCTION TO PLOT EACH PERSON AS A GRAPH WITH SX AND HORMONES
```{r PERSON-PLOT, warning=FALSE}

plot_participant_data <- function(data, participant_id, outcome_var, outcome_label, output_dir) {
  data <- ungroup(data)
  if (!is.null(data$id)) {
    data$id <- as.numeric(as.character(data$id))
  } else {
    stop("Column 'id' not found in the dataset")
  }
  participant_id <- as.numeric(participant_id)
  participant_data <- data %>% filter(id == participant_id)
  if (nrow(participant_data) == 0) {
    stop(paste("No data available for participant ID:", participant_id))
  }
  participant_data$date_rated <- as.Date(participant_data$date_rated, format = "%m/%d/%Y")
  if (all(is.na(participant_data$date_rated))) {
    stop("Error: date_rated column could not be converted to Date type")
  }
  participant_data$date_numeric <- as.numeric(participant_data$date_rated - min(participant_data$date_rated, na.rm = TRUE))
  non_na_counts <- participant_data %>%
    summarise(across(c(E2, P4, LH, !!sym(outcome_var)), ~sum(!is.na(.))), total_days = n())
  safe_scale <- function(x) {
    if (all(is.na(x)) || length(unique(x)) == 1) return(rep(0, length(x)))
    as.vector(scale(x))
  }
  participant_data <- participant_data %>%
    mutate(across(c(E2, P4, LH, !!sym(outcome_var)), 
                  list(z = ~safe_scale(.), z_roll = ~rollapply(safe_scale(.), 3, mean, fill = NA, align = "center")),
                  .names = "{.col}_{.fn}")) %>%
    mutate(across(ends_with("_z_roll"), list(d = ~c(NA, diff(.))), .names = "{.col}_{.fn}"))
  safe_cor <- function(x, y) {
    if (all(is.na(x)) || all(is.na(y)) || length(unique(x)) == 1 || length(unique(y)) == 1) return(NA)
    cor(x, y, use = "pairwise.complete.obs")
  }
  corr_E2 <- safe_cor(participant_data$E2_z_roll, participant_data[[paste0(outcome_var, "_z_roll")]])
  corr_P4 <- safe_cor(participant_data$P4_z_roll, participant_data[[paste0(outcome_var, "_z_roll")]])
  corr_LH <- safe_cor(participant_data$LH_z_roll, participant_data[[paste0(outcome_var, "_z_roll")]])
  corr_dE2 <- safe_cor(participant_data$E2_z_roll_d, participant_data[[paste0(outcome_var, "_z_roll_d")]])
  corr_dP4 <- safe_cor(participant_data$P4_z_roll_d, participant_data[[paste0(outcome_var, "_z_roll_d")]])
  corr_dLH <- safe_cor(participant_data$LH_z_roll_d, participant_data[[paste0(outcome_var, "_z_roll_d")]])
  mondays <- participant_data$date_numeric[wday(participant_data$date_rated) == 2]
  all_y_values <- c(participant_data$P4_z_roll, participant_data$E2_z_roll, 
                    participant_data$LH_z_roll, participant_data[[paste0(outcome_var, "_z_roll")]])
  min_date <- min(participant_data$date_numeric[!is.na(participant_data$date_numeric)])
  max_date <- max(participant_data$date_numeric[!is.na(participant_data$date_numeric)])
  if (is.infinite(min_date) || is.infinite(max_date) || is.na(min_date) || is.na(max_date)) {
    stop("Error: 'min_date' or 'max_date' is invalid")
  }

  p <- ggplot(participant_data, aes(x = date_numeric)) +
    geom_line(aes(y = P4_z_roll, color = "P4"), linewidth = 1) +
    geom_point(aes(y = P4_z_roll), color = "#D62728", size = 3) +
    geom_line(aes(y = E2_z_roll, color = "E2"), linewidth = 1) +
    geom_point(aes(y = E2_z_roll), color = "#1F77B4", size = 3) +
    geom_line(aes(y = LH_z_roll, color = "LH"), linewidth = 1) +
    geom_point(aes(y = LH_z_roll), color = "#2CA02C", size = 3) +
    geom_line(aes(y = .data[[paste0(outcome_var, "_z_roll")]], color = "Clinical Outcome"), linewidth = 2) +
    geom_vline(xintercept = mondays, color = "gray", linetype = "dashed", alpha = 0.5) +
    geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
    scale_color_manual(values = c("P4" = "#D62728", "E2" = "#1F77B4", "LH" = "#2CA02C", "Clinical Outcome" = "black")) +
    labs(title = paste("Menstrual Cycle Hormones and", outcome_label,"for Participant", participant_id),
         x = "Date", y = paste(outcome_label, "\nZ-scored, 3d Rolling Avg"), color = "Legend") +
    theme_minimal() +
    theme(plot.title = element_text(size = 14, face = "bold"), axis.title = element_text(size = 12),
          axis.text = element_text(size = 10), legend.title = element_blank(), legend.text = element_text(size = 10),
          legend.position = "right", legend.box = "horizontal", legend.margin = margin(0, 0, 10, 0),
          plot.margin = margin(10, 10, 30, 10)) +
    scale_x_continuous(breaks = seq(min_date, max_date, by = 3),
                       labels = format(min(participant_data$date_rated) + seq(min_date, max_date, by = 3), "%b %d"),
                       limits = c(min_date, max_date), expand = c(0.02, 0)) +
    scale_y_continuous(limits = c(min(all_y_values[is.finite(all_y_values)], na.rm = TRUE) - 1,
                                  max(all_y_values[is.finite(all_y_values)], na.rm = TRUE) + 1), expand = c(0.1, 0.1))

  mens_dates <- participant_data$date_numeric[participant_data$mensdayonefirst == 1]
  LH_dates <- participant_data$date_numeric[participant_data$LHposdayfirst == 1]

  for (date in mens_dates) {
    p <- p + annotate("rect", xmin = date, xmax = date + 4, ymin = -Inf, ymax = Inf, fill = "pink", alpha = 0.3)
  }
  for (date in LH_dates) {
    p <- p + annotate("rect", xmin = date, xmax = date + 1, ymin = -Inf, ymax = Inf, fill = "#2CA02C", alpha = 0.3)
  }

  min_y <- min(all_y_values[is.finite(all_y_values)], na.rm = TRUE)
  if (is.infinite(min_y) || is.na(min_y)) min_y <- -1
  min_y <- min_y - 0.5

  p <- p +
    geom_point(data = data.frame(x = mens_dates, y = rep(min_y, length(mens_dates))),
               aes(x = x, y = y), color = "#D62728", shape = 17, size = 4) +
    geom_point(data = data.frame(x = LH_dates, y = rep(min_y, length(LH_dates))),
               aes(x = x, y = y), color = "#2CA02C", shape = 17, size = 4)

  format_corr <- function(corr) {
    if (is.na(corr)) return("N/A")
    return(sprintf("%.2f", corr))
  }

  correlation_text <- sprintf(
    "Bivariate Correlations with %s:\nlevP4: r=%s, derP4: r=%s, levE2: r=%s, derE2: r=%s, levLH: r=%s, derLH: r=%s.",
    outcome_label, format_corr(corr_P4), format_corr(corr_dP4), format_corr(corr_E2),
    format_corr(corr_dE2), format_corr(corr_LH), format_corr(corr_dLH)
  )

  nonmissing_text <- sprintf(
    "Available Data for this Participant:\nP4=%d, E2=%d, LH=%d, %s=%d out of %d days.",
    non_na_counts$P4, non_na_counts$E2, non_na_counts$LH, outcome_label, 
    non_na_counts[[outcome_var]], non_na_counts$total_days
  )

  predictors <- c("P4_z_roll", "P4_z_roll_d", "E2_z_roll", "E2_z_roll_d")
  valid_predictors <- predictors[sapply(predictors, function(var) {
    sum(!is.na(participant_data[[var]])) > 1 && sd(participant_data[[var]], na.rm = TRUE) > 0
  })]

  predictor_labels <- c("P4_z_roll" = "levP4", "P4_z_roll_d" = "derP4",
                        "E2_z_roll" = "levE2", "E2_z_roll_d" = "derE2")

  reg_text <- "Regression results: Not enough valid data for regression."
  if (length(valid_predictors) > 0) {
    formula_str <- paste(outcome_var, "~", paste(valid_predictors, collapse = " + "))
    model <- lm(as.formula(formula_str), data = participant_data)
    model_summary <- summary(model)
    if (!is.null(model_summary$coefficients) && nrow(model_summary$coefficients) > 0) {
      coef_info <- model_summary$coefficients
      format_coef <- function(coef, p_val) {
        if (is.na(p_val)) return(sprintf("%.2f (NA)", coef))
        if (p_val < 0.001) return(sprintf("%.2f***", coef))
        if (p_val < 0.01) return(sprintf("%.2f**", coef))
        if (p_val < 0.05) return(sprintf("%.2f*", coef))
        if (p_val < 0.15) return(sprintf("%.2f+", coef))
        return(sprintf("%.2f", coef))
      }
      reg_text <- paste(
        "Regression results:",
        paste(sapply(valid_predictors, function(var) {
          label <- predictor_labels[[var]]
          if (var %in% rownames(coef_info)) {
            sprintf("%s: %s", label, format_coef(coef_info[var, "Estimate"], coef_info[var, "Pr(>|t|)"]))
          } else {
            sprintf("%s: N/A", label)
          }
        }), collapse = ", "),
        sep = "\n"
      )
    }
  }

  combined_text <- paste(nonmissing_text, correlation_text, reg_text, sep = "\n")
  print(combined_text)
  text_grob <- textGrob(combined_text, x = 0.05, y = 0.5, just = "left", gp = gpar(fontsize = 9))
  final_plot <- arrangeGrob(p, text_grob, ncol = 1, heights = c(4, 1))
  grid.newpage()
  grid.draw(final_plot)
  ggsave(filename = file.path(output_dir, paste0("participant_", participant_id, "_", outcome_var, "_hormplot.png")),
         plot = final_plot, width = 12, height = 8, units = "in")
  grid.draw(final_plot)
}

#TEST

#dailydir <- '/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024_07_09'

#plot_participant_data(df, 208, 'CSS_Fx_Total', "CSS Functional Impact", dailydir)


```






# Create "id_list": list of all remaining participant IDs to loop through
```{r}

# Assuming df is your dataframe
# Count how many remaining ids you have in the dataset
unique_id_count <- length(unique(df$id))

# Get a list of unique IDs in the dataset
id_list <- unique(df$id)

# Print the number of unique IDs and the list of unique IDs in a sentence
cat("There are", unique_id_count, "unique IDs in the dataset. The IDs are:", paste(id_list, collapse = ", "), ".\n")


#There are 66 unique IDs in the dataset. The IDs are: 203, 205, 206, 208, 209, 213, 214, 218, 221, 223, 224, 225, 227, 228, 230, 232, 233, 235, 237, 239, 241, 242, 243, 245, 246, 248, 249, 251, 252, 254, 256, 258, 259, 260, 261, 262, 263, 265, 266, 267, 268, 270, 271, 272, 273, 275, 277, 278, 279, 281, 283, 284, 286, 287, 289, 290, 293, 305, 307, 310, 312, 314, 317, 318, 321, 324.
```

```{r}

# There are 12 people whose hormones should probably be removed for sensitivity analysis
badhorm_ids <- c(221, 235, 243, 267, 272, 273, 278, 283, 305, 307, 312, 317)
#Filtering for sensitivity analyses: 
# Remove rows with specified IDs
df_sens <- df %>% filter(!(id %in% badhorm_ids))

```

# Count participants and rows - FULL DATASET

```{r}
# Count how many remaining ids I have in the dataset
unique_id_count <- length(unique(df$id))
# Print the number of unique IDs
print(unique_id_count)

# NUMBER OF ROWS
print(nrow(df))
```

# Count participants and rows - SENSITIVITY SMALLER DATASET

```{r}
# Count how many remaining ids I have in the dataset
unique_id_count <- length(unique(df_sens$id))
# Print the number of unique IDs
print(unique_id_count)

# NUMBER OF ROWS
print(nrow(df_sens))
```

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

##### END OF DATA PREP 


# Save out Prepped Dataset for Easier Use Later On

## DATASET (L2N=66, L1N=2122)


```{r}

write.csv(df, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-09-25/adhd_daily_df.csv", row.names = FALSE)

variable_names <- names(df)
formatted_list <- paste(variable_names, collapse = ", ")
cat(formatted_list)

```
## CLEANER SENSITIVITY DATASET (L2N=54, L1N=1730)


```{r}
write.csv(df_sens, "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-09-25/adhd_daily_df_sens.csv", row.names = FALSE)

variable_names <- names(df_sens)
formatted_list <- paste(variable_names, collapse = ", ")
cat(formatted_list)
```




############################################################################# CYCLE SCALING


## Using CYCLEDAY SCALING TEMPLATE - from Anisha updated September 14, 2024



```{r}

# Renaming Datasets
dat <- df

# Renaming Variables
dat$ID <-dat$id
dat$id <-dat$id
dat$daterated <-dat$date_rated


#df$LHposdayfirst
#df$mensdayonefirst
```

## Functions 

```{r}
calculate_mcyclength <- function(data) {
  # Calculate m2mcount: This counts from 1 menses onset to the next to give the length of a menses-to-menses cycle
  data <- data %>%
    group_by(id) %>%
    arrange(daterated, .by_group = TRUE) %>%
    mutate(
      m2mcount = NA,
      mcyclength = NA,
      cycle_incomplete = 0
    )
  
  for (i in seq_len(nrow(data))) {
    if (!is.na(data$A[i]) && data$A[i] == 1) {
      data$m2mcount[i] <- 1
      j <- i + 1
      
      while (j <= nrow(data) &&
             data$id[j] == data$id[i] && (is.na(data$A[j]) || data$A[j] != 1)) {
        data$m2mcount[j] <- data$m2mcount[j - 1] + 1
        j <- j + 1
      }
      
      if (j <= nrow(data) &&
          data$id[j] == data$id[i] && !is.na(data$A[j]) && data$A[j] == 1) {
        data$m2mcount[j] <- data$m2mcount[j - 1] + 1
      }
    }
  }
  
  # Identify incomplete cycles: This identifies instances where a complete menses-to-menses cycle was not captured
  data <- data %>%
    mutate(cycle_incomplete = ifelse(!is.na(m2mcount) &
                                       (is.na(lead(m2mcount)) & id != lead(id)), 1, 0))
  
  # New condition: Set cycle_incomplete = 1 if m2mcount restarts when id changes
  data <- data %>%
    group_by(id) %>%
    mutate(
      cycle_incomplete = ifelse(
        id != lag(id, default = first(id)) & m2mcount == 1, 1, cycle_incomplete
      )
    ) %>%
    ungroup()
  
  # Propagate cycle_incomplete within each group of m2mcount
  data <- data %>%
    group_by(id) %>%
    mutate(cycle_group = cumsum(!is.na(m2mcount) & m2mcount == 1)) %>%
    group_by(id, cycle_group) %>%
    mutate(
      cycle_incomplete = ifelse(any(cycle_incomplete == 1), 1, 0),
      # Fix: handle cases where all values in m2mcount are NA
      mcyclength = ifelse(all(is.na(m2mcount)), NA, max(m2mcount, na.rm = TRUE))
    ) %>%
    ungroup() %>%
    select(-cycle_group)
  
  data$cycle_incomplete = ifelse(is.na(data$cycle_incomplete), 1, 0)
  data$cycle_incomplete = ifelse(is.na(data$m2mcount), NA, data$cycle_incomplete)
  
  # Calculate cyclenum: calculates number of menses-to-menses cycles within a person
  data <- data %>%
    group_by(id) %>%
    mutate(cyclenum = cumsum(!is.na(m2mcount) & m2mcount == 1 & cycle_incomplete == 0)) %>%
    ungroup()
  
  data <- data %>%
    group_by(id) %>%
    mutate(cyclenum = ifelse(
      cycle_incomplete == 1,
      NA,
      cumsum(!is.na(m2mcount) & m2mcount == 1 & cycle_incomplete == 0)
    )) %>%
    ungroup()
  
  return(data)
}



#calculate_lutdaycount: counts length of luteal phase 

calculate_lutdaycount <- function(data, ovtoday) {
  last_id <- NULL
  lutdaycount1 <- rep(NA, nrow(data))
  lut_incomplete1 <- rep(NA, nrow(data))  # Initialize lut_incomplete
  count_started_row <- NA  # Track the starting row of a lutdaycount1 stretch
  active_count <- FALSE  # Track if lutdaycount1 is currently counting

  for (i in 1:nrow(data)) {
    # If id changes, reset lutdaycount1 and lut_incomplete
    if (is.null(last_id) || last_id != data$id[i]) {
      if (active_count) {
        # Mark the whole stretch as incomplete if stopped by id change
        lut_incomplete1[count_started_row:(i - 1)] <- 1
      }
      lutdaycount1[i] <- ifelse(ovtoday[i] == 1, 0, NA)
      active_count <- !is.na(lutdaycount1[i])  # Start counting if lutdaycount1 is initialized
      count_started_row <- ifelse(!is.na(lutdaycount1[i]), i, NA)  # Record start row
    } else if (!is.na(lutdaycount1[i - 1])) {
      lutdaycount1[i] <- lutdaycount1[i - 1] + 1
    }

    # If lutdaycount1 is active and stops because of A == 1, set lut_incomplete = 0 for the entire stretch
    if (!is.na(lutdaycount1[i]) && !is.na(data$A[i]) && data$A[i] == 1) {
      lutdaycount1[i] <- NA
      lut_incomplete1[count_started_row:(i - 1)] <- 0  # Mark stretch as complete due to A == 1
      active_count <- FALSE  # Stop counting due to A == 1
    } else if (ovtoday[i] == 1) {
      lutdaycount1[i] <- 0
      active_count <- TRUE  # Start counting at ovtoday == 1
      count_started_row <- i  # Record start row of the count
    }

    # Assign the current row to last_id for the next iteration
    last_id <- data$id[i]
  }

  # Update the dataset with lutdaycount1 and lut_incomplete
  data$lutdaycount1 <- lutdaycount1
  data$lut_incomplete1 <- lut_incomplete1
  
  return(data)
}

#calculate_foldaycount: counts length of follicular phase 

calculate_foldaycount <- function(data, ovtoday) {
  foldaycount <- NA
  fol_incomplete <- NA
  last_id <- NULL
  active_count <- FALSE  # Track if foldaycount is currently active
  count_started_row <- NULL  # Track the starting row of a foldaycount stretch
  
  for (i in 1:nrow(data)) {
    # If id changes, reset foldaycount and fol_incomplete
    if (is.null(last_id) || is.na(data$id[i]) || last_id != data$id[i]) {
      if (active_count) {
        # Mark the whole stretch as incomplete if stopped by id change
        data$fol_incomplete[count_started_row:i-1] <- 1
      }
      foldaycount <- ifelse(data$A[i] == 1, 0, NA)
      active_count <- !is.na(foldaycount)  # Start counting if foldaycount is initialized
      fol_incomplete <- NA  # Reset fol_incomplete when id changes
      count_started_row <- ifelse(!is.na(foldaycount), i, NA)  # Record start row
    } else if (!is.na(foldaycount)) {
      foldaycount <- foldaycount + 1
    }

    # If foldaycount is active and stopped because of ovtoday == 1, set fol_incomplete = 0 for the whole stretch
    if (!is.na(foldaycount) && i >= 2 && !is.na(ovtoday[i]) && ovtoday[i - 1] == 1) {
      foldaycount <- NA
      data$fol_incomplete[count_started_row:i-1] <- 0  # Mark stretch as complete due to ovulation
      active_count <- FALSE  # Stop counting due to ovulation
      fol_incomplete <- 0
    }

    # If A == 1, start or reset the count
    if (data$A[i] == 1) {
      foldaycount <- 0
      active_count <- TRUE  # Start counting
      count_started_row <- i  # Record start row of the count
    }

    # If foldaycount is actively counting and stops because of id change
    if (!is.na(last_id) && !is.na(data$id[i]) && last_id != data$id[i] && active_count) {
      data$fol_incomplete[count_started_row:i-1] <- 1  # Mark as incomplete because the count stopped due to id change
      active_count <- FALSE  # Stop counting as the id changed
    }

    # Assign foldaycount and fol_incomplete to the current row
    data$foldaycount[i] <- foldaycount
    if (is.na(fol_incomplete)) {
      data$fol_incomplete[i] <- NA
    }

    # Update last_id for the next iteration
    last_id <- data$id[i]
  }

  return(data)
}

```


<!-- ```{r} -->
<!-- #subset to only include baseline, washout, and PBO  -->
<!-- dat = dat %>% filter(cleartrialphase == 0| cleartrialphase == 1| cleartrialphase == 4| cleartrialphase == 5| cleartrialphase == 8|cleartrialphase == 9|cleartrialphase == 12) -->


```{r}

dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax = NA)

#create the variable 'A' which will represent menses onset
dat$A <- ifelse(dat$cycleday == 1, 1, 0)
dat$A <- ifelse(is.na(dat$A), 0, dat$A)
#ovtoday = LH + 1
dat$ovtoday = lag(dat$LHposdayfirst) #changed this from "posovtest"
#check data
dat %>% select(daterated, ovtoday, LHposdayfirst)
```






## Functions 

```{r}



calculate_mcyclength <- function(data) {
  # Calculate m2mcount: This counts from 1 menses onset to the next to give the length of a menses-to-menses cycle
  data <- data %>%
    group_by(id) %>%
    arrange(daterated, .by_group = TRUE) %>%
    mutate(
      m2mcount = NA,
      mcyclength = NA,
      cycle_incomplete = 0
    )
  
  for (i in seq_len(nrow(data))) {
    if (!is.na(data$A[i]) && data$A[i] == 1) {
      data$m2mcount[i] <- 1
      j <- i + 1
      
      while (j <= nrow(data) &&
             data$id[j] == data$id[i] && (is.na(data$A[j]) || data$A[j] != 1)) {
        data$m2mcount[j] <- data$m2mcount[j - 1] + 1
        j <- j + 1
      }
      
      if (j <= nrow(data) &&
          data$id[j] == data$id[i] && !is.na(data$A[j]) && data$A[j] == 1) {
        data$m2mcount[j] <- data$m2mcount[j - 1] + 1
      }
    }
  }
  
  # Identify incomplete cycles: This identifies instances where a complete menses-to-menses cycle was not captured
  data <- data %>%
    mutate(cycle_incomplete = ifelse(!is.na(m2mcount) &
                                       (is.na(lead(m2mcount)) & id != lead(id)), 1, 0))
  
  # New condition: Set cycle_incomplete = 1 if m2mcount restarts when id changes
  data <- data %>%
    group_by(id) %>%
    mutate(
      cycle_incomplete = ifelse(
        id != lag(id, default = first(id)) & m2mcount == 1, 1, cycle_incomplete
      )
    ) %>%
    ungroup()
  
  # Propagate cycle_incomplete within each group of m2mcount
  data <- data %>%
    group_by(id) %>%
    mutate(cycle_group = cumsum(!is.na(m2mcount) & m2mcount == 1)) %>%
    group_by(id, cycle_group) %>%
    mutate(
      cycle_incomplete = ifelse(any(cycle_incomplete == 1), 1, 0),
      # Fix: handle cases where all values in m2mcount are NA or max is missing
      mcyclength = ifelse(sum(!is.na(m2mcount)) > 0, max(m2mcount, na.rm = TRUE), NA)
    ) %>%
    ungroup() %>%
    select(-cycle_group)
  
  data$cycle_incomplete = ifelse(is.na(data$cycle_incomplete), 1, 0)
  data$cycle_incomplete = ifelse(is.na(data$m2mcount), NA, data$cycle_incomplete)
  
  # Calculate cyclenum: calculates number of menses-to-menses cycles within a person
  data <- data %>%
    group_by(id) %>%
    mutate(cyclenum = cumsum(!is.na(m2mcount) & m2mcount == 1 & cycle_incomplete == 0)) %>%
    ungroup()
  
  data <- data %>%
    group_by(id) %>%
    mutate(cyclenum = ifelse(
      cycle_incomplete == 1,
      NA,
      cumsum(!is.na(m2mcount) & m2mcount == 1 & cycle_incomplete == 0)
    )) %>%
    ungroup()
  
  return(data)
}


#calculate_lutdaycount: counts length of luteal phase 

calculate_lutdaycount <- function(data, ovtoday) {
  last_id <- NULL
  lutdaycount1 <- rep(NA, nrow(data))
  lut_incomplete1 <- rep(NA, nrow(data))  # Initialize lut_incomplete
  count_started_row <- NA  # Track the starting row of a lutdaycount1 stretch
  active_count <- FALSE  # Track if lutdaycount1 is currently counting

  for (i in 1:nrow(data)) {
    # If id changes, reset lutdaycount1 and lut_incomplete
    if (is.null(last_id) || last_id != data$id[i]) {
      if (active_count) {
        # Mark the whole stretch as incomplete if stopped by id change
        lut_incomplete1[count_started_row:(i - 1)] <- 1
      }
      lutdaycount1[i] <- ifelse(ovtoday[i] == 1, 0, NA)
      active_count <- !is.na(lutdaycount1[i])  # Start counting if lutdaycount1 is initialized
      count_started_row <- ifelse(!is.na(lutdaycount1[i]), i, NA)  # Record start row
    } else if (!is.na(lutdaycount1[i - 1])) {
      lutdaycount1[i] <- lutdaycount1[i - 1] + 1
    }

    # If lutdaycount1 is active and stops because of A == 1, set lut_incomplete = 0 for the entire stretch
    if (!is.na(lutdaycount1[i]) && !is.na(data$A[i]) && data$A[i] == 1) {
      lutdaycount1[i] <- NA
      lut_incomplete1[count_started_row:(i - 1)] <- 0  # Mark stretch as complete due to A == 1
      active_count <- FALSE  # Stop counting due to A == 1
    } else if (ovtoday[i] == 1) {
      lutdaycount1[i] <- 0
      active_count <- TRUE  # Start counting at ovtoday == 1
      count_started_row <- i  # Record start row of the count
    }

    # Assign the current row to last_id for the next iteration
    last_id <- data$id[i]
  }

  # Update the dataset with lutdaycount1 and lut_incomplete
  data$lutdaycount1 <- lutdaycount1
  data$lut_incomplete1 <- lut_incomplete1
  
  return(data)
}

calculate_foldaycount <- function(data, ovtoday) {
  # Initialize the foldaycount and fol_incomplete columns
  data$foldaycount <- NA
  data$fol_incomplete <- NA
  
  foldaycount <- NA
  fol_incomplete <- NA
  last_id <- NULL
  active_count <- FALSE  # Track if foldaycount is currently active
  count_started_row <- NA  # Track the starting row of a foldaycount stretch
  
  for (i in 1:nrow(data)) {
    
    # If id changes or this is the first row, reset foldaycount and fol_incomplete
    if (is.null(last_id) || is.na(data$id[i]) || (!is.na(last_id) && last_id != data$id[i])) {
      if (active_count) {
        # Mark the whole stretch as incomplete if stopped by id change
        data$fol_incomplete[count_started_row:(i-1)] <- 1
      }
      foldaycount <- ifelse(data$A[i] == 1, 0, NA)
      active_count <- !is.na(foldaycount)  # Start counting if foldaycount is initialized
      fol_incomplete <- NA  # Reset fol_incomplete when id changes
      count_started_row <- ifelse(!is.na(foldaycount), i, NA)  # Record start row
    } else if (!is.na(foldaycount)) {
      foldaycount <- foldaycount + 1
    }

    # If foldaycount is active and stopped because ovtoday == 1 (indicating ovulation)
    if (active_count && i > 1 && !is.na(ovtoday[i]) && ovtoday[i] == 1) {
      foldaycount <- NA
      data$fol_incomplete[count_started_row:(i-1)] <- 0  # Mark stretch as complete due to ovulation
      active_count <- FALSE  # Stop counting due to ovulation
      fol_incomplete <- 0
    }

    # If A == 1, start or reset the count
    if (!is.na(data$A[i]) && data$A[i] == 1) {
      foldaycount <- 0
      active_count <- TRUE  # Start counting
      count_started_row <- i  # Record start row of the count
    }

    # Assign foldaycount and fol_incomplete to the current row
    data$foldaycount[i] <- foldaycount
    data$fol_incomplete[i] <- ifelse(is.na(fol_incomplete), NA, fol_incomplete)

    # Update last_id for the next iteration, but only if it's not missing
    if (!is.na(data$id[i])) {
      last_id <- data$id[i]
    }
  }

  return(data)
}


```


# Removed the cleartrialphase piece here

# Calculate Menses-to-menses cycle lengths 

## m2mcount and cyclelength 

```{r}

#the mcyclength function, this will do forward count to give cycle lengths for menses-to-menses cycles, and count the number of complete cycles within a person 
dat <- calculate_mcyclength(dat)

#-Inf will occur if the cycle is incomplete (no bookend menses onset date) so we will change to NA
dat$mcyclength = ifelse(dat$mcyclength == -Inf , NA, dat$mcyclength)

#if cyclenum is NA, set cycle_incomplete to 1 
dat$cycle_incomplete = ifelse(is.na(dat$cyclenum), 1, dat$cycle_incomplete)

#check data
dat %>% select(id, daterated, A, m2mcount, ovtoday, cyclenum, mcyclength, cycle_incomplete) 

```



Here, I am doing scaling for baseline, washout, and PBO condition

# calculating ovtoday_impute
 
```{r}
# this is based on NC dataset 
dat <- dat %>% 
  mutate(lutlength_impute = case_when(mcyclength == 20 ~ (mcyclength* 0.46),
                                      mcyclength == 21 ~ (mcyclength*.476),
                                      mcyclength == 22 ~ (mcyclength*.491),
                                      mcyclength == 23 ~ (mcyclength*.491),
                                      mcyclength == 24 ~ (mcyclength*.492),
                                      mcyclength == 25 ~ (mcyclength*.484),
                                      mcyclength == 26 ~ (mcyclength*.481),
                                      mcyclength == 27 ~ (mcyclength*.470),
                                      mcyclength == 28 ~ (mcyclength*.461),
                                      mcyclength == 29 ~ (mcyclength*.448),
                                      mcyclength == 30 ~ (mcyclength*.437),
                                      mcyclength == 31 ~ (mcyclength*.426),
                                      mcyclength == 32 ~ (mcyclength*.416),
                                      mcyclength == 33 ~ (mcyclength*.40),
                                      mcyclength == 34 ~ (mcyclength*.391),
                                      mcyclength == 35 ~ (mcyclength*.377),
                                      mcyclength == 36 ~ (mcyclength*.369),
                                      mcyclength == 37 ~ (mcyclength*.359),
                                      TRUE ~ NA))

dat <- dat %>% 
  mutate(follength_impute = case_when(mcyclength == 20 ~ (mcyclength*.54),
                                      mcyclength == 21 ~ (mcyclength*.524),
                                      mcyclength == 22 ~ (mcyclength*.509),
                                      mcyclength == 23 ~ (mcyclength*.509),
                                      mcyclength == 24 ~ (mcyclength*.508),
                                      mcyclength == 25 ~ (mcyclength*.516),
                                      mcyclength == 26 ~ (mcyclength*.519),
                                      mcyclength == 27 ~ (mcyclength*.530),
                                      mcyclength == 28 ~ (mcyclength*.539),
                                      mcyclength == 29 ~ (mcyclength*.552),
                                      mcyclength == 30 ~ (mcyclength*.563),
                                      mcyclength == 31 ~ (mcyclength*.574),
                                      mcyclength == 32 ~ (mcyclength*.584),
                                      mcyclength == 33 ~ (mcyclength*.60),
                                      mcyclength == 34 ~ (mcyclength*.609),
                                      mcyclength == 35 ~ (mcyclength*.623),
                                      mcyclength == 36 ~ (mcyclength*.631),
                                      mcyclength == 37 ~ (mcyclength*.641),
                                      TRUE ~ NA))
#check data
dat %>% select(id, daterated, A, m2mcount, mcyclength, follength_impute)
#group by id, and make sure dates are in order 
dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) 
#initialize new variable- follcount1
dat$follcount1 <- NA
for (i in 1:nrow(dat)) {
  if (dat$A[i] == 1 & !is.na(dat$follength_impute[i])) {
    follcount1 <- seq_len(round(dat$follength_impute[i]))
    dat$follcount1[i:(i + length(follcount1) - 1)] <- follcount1
  }
}
#follcount1 forward counts from menses onset based on imputed follength from NC data 

dat %>% select(id, A, follength_impute, follcount1)

#identify ovtoday_impute based on forward count from follcount1
dat <- dat %>% 
  mutate(ovtoday_impute = case_when(round(follength_impute) == follcount1 ~ 1,
                               TRUE ~ NA))

#if ovtoday is NA, change to 0 
dat$ovtoday <- ifelse(is.na(dat$ovtoday), 0, dat$ovtoday) 

#if ovtoday_impute is NA, change to 0 
dat$ovtoday_impute <- ifelse(is.na(dat$ovtoday_impute), 0, dat$ovtoday_impute) 

#check data 
dat %>% select(id, daterated, ovtoday, ovtoday_impute) # Removed cleartrialphase
```


# percentage of luteal phase using ovtoday (LH + 1) 

 - variable is called perclut for menses-centered
 - variable is called perclut_ov for ovulation-centered 
 

```{r}
#group by id, make sure daterated is in order, initialize the variable lutmax 
dat <- dat  %>% 
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(lutmax = NA)
#apply the calculate_lutdaycount function. which spits out the variable lutdaycount1. lutdaycount1 forward counts from ovtoday = 1 to the next menses onset, indexed at 0 
dat <- calculate_lutdaycount(dat, dat$ovtoday)
#check data 
dat %>% select(id, daterated, ovtoday, A, lutdaycount1)
#the below code creates lutdaycount which shifts lutdaycount1, and forward counts starting the day after ovtoday = 1, still indexed at 0 
dat <- dat %>%
  group_by(id) %>%
  mutate(
    lutdaycount = lag(lutdaycount1),
    lutdaycount = case_when(
      is.na(lutdaycount) | id != lag(id) ~ NA, 
      TRUE ~ lutdaycount
    )
  )

dat <- dat %>%
  group_by(id) %>%
  mutate(
    lut_incomplete = lag(lut_incomplete1),
    lut_incomplete = case_when(
      is.na(lut_incomplete) | id != lag(id) ~ NA, 
      TRUE ~ lut_incomplete
    )
  )


#check data 
dat %>% select(id, daterated, ovtoday, A, lutdaycount, lut_incomplete)
#lutmax corresponds to the length of the luteal phase in a complete menses-to-menses cycle (it is the max value of lutdaycount in a cycle)
for (i in 1:(nrow(dat)-1)) {
  if (is.na(dat$lutdaycount[i + 1] && !is.na(dat$lutdaycount[i]))) {
    dat$lutmax[(i-(dat$lutdaycount[i])):i] = as.numeric(dat$lutdaycount[i])
  }
}

dat$lut_incomplete = ifelse(dat$lutmax > 30, 1, dat$lut_incomplete)
#check data 
dat %>% select(id, daterated, ovtoday, A, lutdaycount, lutmax, lut_incomplete)

#calculates lutperc which is luteal phase scaled from 0 to 1, using ovtoday 
dat <- dat %>%
  mutate(lutperc = ifelse(lut_incomplete == 0, (lutdaycount / lutmax), NA))

#calculates perclut_base which is luteal phase scaled from -1 to 0, using ovtoday. This is the variable that will be used in the menses-centered scaled_cycleday 
dat$perclut = dat$lutperc -1 

# dat <- dat %>%
#   mutate(perclut = ifelse(A == 1, 0, perclut))

#check data
dat %>% select(id, daterated, ovtoday, A, lutmax, perclut, lut_incomplete)

#calculate lutdaycount_ov, which is lutdaycount but ovulation-centered 
dat <- dat %>%
  group_by(id) %>%
  mutate(
    lutdaycount_ov = lead(lutdaycount),
    lutdaycount_ov = case_when(is.na(lutdaycount_ov) |
                                 id != lead(id) ~ NA, TRUE ~ lutdaycount_ov)
  )

dat <- dat %>%
  mutate(perclut_ov = ifelse(lut_incomplete == 0, lutdaycount_ov / lutmax, NA))

# dat <- dat %>%
#   mutate(perclut_ov = ifelse(lutdaycount_ov == 0, 0, perclut_ov))


dat %>% select(id,
               daterated,
               ovtoday,
               A,
               lutdaycount,
               lutdaycount_ov,
               lutmax,
               perclut_ov, perclut)

#remove 'helper' variables
dat <- dat %>% select(-c(lutdaycount1, lutperc, lut_incomplete1))

```

# percentage of luteal phase using ovtoday_impute (based on NC norms)


```{r}
#make sure dates are in order for each id, initialize new variable called lutmax_impute
dat <- dat  %>% 
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(lutmax_impute = NA)
#if A is NA, make it 0 (A is menses onset)
dat$A <- ifelse(is.na(dat$A), 0, dat$A)
#apply calculate_lutdaycount fxn which spits out the variable lutdaycount1. lutdaycount1 forward counts from ovtoday_impute = 1 to the next menses onset, indexed at 0 
dat <- calculate_lutdaycount(dat, dat$ovtoday_impute)
#check data
dat %>% select(id, daterated, ovtoday_impute, A, lutdaycount1)
#the below code creates lutdaycount_impute which shifts lutdaycount1, and forward counts starting the day after ovtoday_impute = 1, still indexed at 0 
dat <- dat %>%
  group_by(id) %>%
  mutate(
    lutdaycount_impute = lag(lutdaycount1),
    lutdaycount_impute = case_when(
      is.na(lutdaycount_impute) | id != lag(id) ~ NA, 
      TRUE ~ lutdaycount_impute
    )
  )
#check data 
dat %>% select(id, daterated, ovtoday_impute, A, lutdaycount_impute)

#lutmax_impute corresponds to the length of the luteal phase in a complete menses-to-menses cycle, using ovtoday_impute (it is the max value of lutdaycount_impute in a cycle)
for (i in 1:(nrow(dat)-1)) {
  if (is.na(dat$lutdaycount_impute[i + 1] && !is.na(dat$lutdaycount_impute[i]))) {
    dat$lutmax_impute[(i-(dat$lutdaycount_impute[i])):i] = as.numeric(dat$lutdaycount_impute[i])
  }
}
#lutlength1_impute is the imputed value of luteal phase based on NC norms, but lagged one day so it does align with any dates in the follicuar phase 
dat$lutlength1_impute = lag(dat$lutlength_impute)

#check data
dat %>% select(id, daterated, ovtoday_impute, A, lutdaycount_impute, lutmax_impute, lutlength_impute, lutlength1_impute)

#calculate lutperc_impute
dat <- dat %>%
  mutate(lutperc_impute = if_else(
    is.na(lutlength1_impute),
    NA,
    if_else(
      is.na(lutlength1_impute) &
        !is.na(lutmax_impute) & cycle_incomplete == 0,
      lutdaycount_impute / lutmax_impute,
      lutdaycount_impute / round(lutlength1_impute)
    )
  ))

#lutperc is scaled from 0 to 1, so substracting 1 so that it is scaled from -1 to 0 for menses-centered scaled_cycleday 
dat$perclut_impute = dat$lutperc_impute -1 

#check data
dat %>% select(id, daterated, ovtoday_impute, A, mcyclength, perclut_impute, perclut) 

#calculate lutdaycount_imp_ov, which is imputed lutdaycount but ovulation-centered 
dat <- dat %>%
  group_by(id) %>%
  mutate(
    lutdaycount_imp_ov = lead(lutdaycount_impute),
    lutdaycount_imp_ov = case_when(
      is.na(lutdaycount_imp_ov) | id != lead(id) ~ NA, 
      TRUE ~ lutdaycount_imp_ov
    )
  )

#calculate lutperc_imp_ov which is the variable that will go into ovulation-centered scaled cycleday 
dat <- dat %>%
  mutate(perclut_imp_ov = if_else(
    is.na(lutlength1_impute) ,
    NA,
    if_else(
      is.na(lutlength1_impute) & !is.na(lutmax) & cycle_incomplete == 0,
      lutdaycount1 / lutmax_impute,
      lutdaycount1 / round(lutlength1_impute)
    )
  ))


#if ovtoday_impute == 1, set lutperc_imp_ov to 0
# dat <- dat %>%
#   mutate(perclut_imp_ov = ifelse(ovtoday_impute == 1, 0, perclut_imp_ov))

#check data 
dat %>% select(id, daterated, ovtoday_impute, A, lutdaycount, lutlength1_impute, lutdaycount1, lutmax_impute, perclut_impute, perclut_imp_ov)

#remove helper variables
dat <- dat %>% select (-c(lutperc_impute, lutdaycount1))
```

# percentage of follicular phase using ovtoday (LH+1)

```{r}
# Check for missing values
table(dat$id)
table(dat$ovtoday)

#remove obs with missing id or ovtoday
dat <- dat %>%
  filter(!is.na(id) & !is.na(ovtoday))

# Ensure daterated is in order by id and initialize folmax variable
dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax = NA)

#make sure daterated is in order by id, and initialize folmax variable 
dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax = NA)

#apply calculate foldaycount function using ovtoday 
dat <- calculate_foldaycount(dat, dat$ovtoday)

#foldaycount forward counts starting at menses onset and ends at ovtoday 
dat %>% select(id, daterated, A, ovtoday, foldaycount)

#assigns folmax as the max value of foldaycount within a cycle 
for (i in 1:(nrow(dat)-1)) {
  if (is.na(dat$foldaycount[i + 1] && !is.na(dat$foldaycount[i]))) {
    dat$folmax[(i-(dat$foldaycount[i])):i] = as.numeric(dat$foldaycount[i])
  }
}

#follength is the length of the follicular phase that cycle (since folmax is indexed at 0)
dat$follength = dat$folmax + 1 

#check data
dat %>% select(id, daterated, ovtoday, A, foldaycount, folmax, follength, fol_incomplete)

dat <- dat %>%
  mutate(percfol = ifelse(fol_incomplete != 1, foldaycount / (folmax), NA))

dat$percfol_ov = dat$percfol - 1

dat %>% select(id, daterated, ovtoday, A, foldaycount, folmax, percfol, percfol_ov)

#renaming foldaycount based on ovtoday to be called foldaycount_ov. the variable name 'foldaycount' get overwritten in the code chunk below when the calculate_foldaycount() function is run 
dat <- dat %>% rename(foldaycount_ov = foldaycount)

```

# percentage of follicular phase using ovtoday_impute (based on NC norms)

```{r}

#yes, I'm constantly arranging by daterated because I'm paranoid. Initialize the variable folmax_impute 
dat <- dat %>%
  group_by(id) %>%
  arrange(daterated, .by_group = TRUE) %>%
  mutate(folmax_impute = NA)
#see comment on line 512
dat <- calculate_foldaycount(dat, dat$ovtoday_impute)
dat <- dat %>% rename(foldaycount_impute = foldaycount)
dat %>% select(id, daterated, ovtoday_impute, A, foldaycount_impute)

#create folmax_impute which is the max value of foldaycount_impute and matches the imputed follicular length in complete cycles 
for (i in 1:(nrow(dat)-1)) {
  if (is.na(dat$foldaycount_impute[i + 1] && !is.na(dat$foldaycount_impute[i]))) {
    dat$folmax_impute[(i-(dat$foldaycount_impute[i])):i] = as.numeric(dat$foldaycount_impute[i])
  }
}

dat <- dat %>%
  mutate(percfol_impute = ifelse(cycle_incomplete == 0, foldaycount_impute / (folmax_impute), NA))

# ovulation-centered percfol based on ovtoday_impute 
dat$percfol_imp_ov = dat$percfol_impute - 1


dat %>% select(id, daterated, ovtoday_impute, A, percfol_impute, percfol_imp_ov)
```




# prioritize LH test-based scaled values over imputed values 

```{r}

#functions to prioritize perc_base over perc

create_percent <- function(dat, percentvar, percvar, percvar_impute) {
  percentvar <- ensym(percentvar)
  percvar <- ensym(percvar)
  percvar_impute <- ensym(percvar_impute)
  
  dat %>%
    group_by(id, cyclenum) %>%
    mutate(
      !!percentvar := if (all(is.na(!!percvar) | !!percvar == 0)) {
        # if percvar contains only NA or 0, use percvar_impute
        !!percvar_impute
      } else {
        # otherwise, use percvar
        !!percvar
      }
    ) %>%
    ungroup()
}


dat = create_percent(dat, percentlut, perclut, perclut_impute)
dat = create_percent(dat, percentfol, percfol, percfol_impute)
dat = create_percent(dat, percentlut_ov, perclut_ov, perclut_imp_ov)
dat = create_percent(dat, percentfol_ov, percfol_ov, percfol_imp_ov)

dat %>% select(id, daterated, A, ovtoday, ovtoday_impute, cyclenum, mcyclength, percfol, percfol_impute, percentlut_ov)
```


# creating scaled_cycleday 

```{r}

dat <- dat %>%
  mutate(scaled_cycleday = ifelse(is.na(percentlut), percentfol, percentlut))
dat %>% select(id, daterated, percentlut, percentfol, scaled_cycleday)
dat <- dat %>%
  mutate(scaled_cycleday_ov = ifelse(is.na(percentlut_ov), percentfol_ov, percentlut_ov))
dat %>% select(id, daterated, percentlut_ov, percentfol_ov, scaled_cycleday_ov)

```


# Example usage



# how many non-missing: 1386

```{r}
dat %>%
  summarise(complete_cases = sum(!is.na(scaled_cycleday) & (!is.na("CSS_Inatt"))))
```


# plotting 

CSS_Inatt
CSS_Inatt_Count
CSS_HypImp
CSS_HypImp_Count
CSS_Fx_Total
CSS_B2_Total
UPPS_Total
BDEFS_Total
DEBQ_Total

## Rounding Percents

```{r}

dat <- dat %>%
  mutate(cycleday_perc = (scaled_cycleday + 1) / 2) %>%
  mutate(cycleday_perc_round = round(cycleday_perc, 1)) %>%
  mutate(cycleday_10perc = round(cycleday_perc / 0.10) * 0.10) %>%
  mutate(cycleday_2perc = round(cycleday_perc / 0.02) * 0.02)


```

#RE-CALCULATE DEVATIONS AND STD AND ROLLING AVGS


```{r}


#create rolling averages on RAW variables
for (i in outcomelist) {
  dat <- create.3day.rolling.avg(dat, !!sym({{i}}), 3)
}

#MEANS

#execute for loop: run create.person.mean() on everything in "outcomelist.roll"
for (i in outcomelist.roll) {
  dat <- create.person.mean(dat, !!sym({{i}}), id)
}

#execute for loop: run create.person.mean() on everything in "outcomelist"
for (i in outcomelist) {
  dat <- create.person.mean(dat, !!sym({{i}}), id)
}

#PERSON-DEVIATIONS

#for raw deviations
#execute for loop: run create.deviation() on everything in list
for (i in outcomelist) {
  dat <- create.deviation(dat, !!sym({{i}}), !!sym(paste0({{i}}, ".m")))
}

#for rolling avgs deviations
#execute for loop: run create.deviation() on everything in list
for (i in outcomelist.roll) {
  dat <- create.deviation(dat, !!sym({{i}}), !!sym(paste0({{i}}, ".m")))
}


#Check 
#dat %>% select(id, E2, E2.m, E2.d, E2.roll, E2.roll.d) %>% View()

```

## Plot All

### TURNED OFF WARNINGS AND MESSAGES

```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(rlang)

# Define the function to generate plots for a list of DVs
plot_DVs <- function(DV_list, dat, bleeding_start = 0.5, bleeding_end = 0.7) {
  
  # Indicators for menstrual bleeding using provided start/end
  bleeding_indicator <- data.frame(xmin = bleeding_start, xmax = bleeding_end, ymin = -Inf, ymax = Inf)
  
  for (DV in DV_list) {
    
    plot_types <- c("Raw", "Deviations", "Rolling Deviations")
    suffixes <- c("", ".d", ".roll.d")
    y_labels <- c(DV, paste(DV, "Deviation"), paste(DV, "Rolling Deviation"))
    
    for (i in 1:3) {
      plot_type <- plot_types[i]
      suffix <- suffixes[i]
      y_label <- y_labels[i]
      
      var_name <- paste0(DV, suffix)
      
      # Check if the variable exists in the data
      if (var_name %in% names(dat)) {
        dv <- dat %>%
          group_by(cycleday_10perc) %>%
          summarise(mean_value = mean(!!sym(var_name), na.rm = TRUE),
                    se_value = sd(!!sym(var_name), na.rm = TRUE) / sqrt(n()),
                    .groups = "drop") # Explicitly drop grouping
        
        p <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
          geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                      fill = "blue", alpha = 0.1) +
          geom_point(size = 1) +
          geom_line(size = 1) +
          ggtitle(paste(plot_type, DV, "Plot")) +
          xlab("Cycle Day (10% bins)") + ylab(paste(y_label, "Mean")) +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5, size = 14),
                plot.margin = margin(15, 5, 50, 5)) +
          coord_cartesian(clip = "off") +
          geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                    fill = "red", alpha = 0.2, inherit.aes = FALSE)
        
        print(p)        
      } else {
          warning(paste("Variable", var_name, "not found in dataset."))
      }
    }
  }
}



DVs <- c("E2", "P4", "LH", "CSS_Inatt")


# Example with custom bleeding window:
plot_DVs(DVs, dat)





```

## ORIGINAL PLOT EXAMPLE

```{r}

dv <- df %>% 
  group_by(cycleday_10perc) %>% 
  summarise(mean_dev = mean(P4, na.rm = T))

 ggplot(dv, aes(x = cycleday_10perc, y = mean_dev)) +
  geom_point(size = .2) +
  geom_line(size=.2) +
  geom_smooth(se=T, size = 0.3) 

dv <- df %>% 
  group_by(cycleday_10perc) %>% 
  summarise(mean_dev = mean(P4.d, na.rm = T))

 ggplot(dv, aes(x = cycleday_10perc, y = mean_dev)) +
  geom_point(size = .2) +
  geom_line(size=.2) +
  geom_smooth(se=T, size = 0.3) 
```




## New Plot with E2 and P4 in the background and person-standardized outcomes

```{r}

# Define the folder location for saving the plots
output_folder <- "/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-09-25"

# Define the function to generate plots for a list of DVs
plot_DVs <- function(DV_list, dat) {
  
  # Create person-standardized (z-scored within each participant) versions of each DV
  for (DV in DV_list) {
    zd_var <- paste0(DV, ".zd")  # Name for the person-standardized version
    
    # Add the person-standardized columns for each DV
    dat <- dat %>%
      group_by(id) %>%
      mutate(!!zd_var := scale(!!sym(DV), center = TRUE, scale = TRUE)) %>%
      ungroup()
  }
  
  # Calculate person-rescaled E2 and P4 (scaled within each person, sd = 0.5)
  dat <- dat %>%
    group_by(id) %>%
    mutate(E2.rescale = scale(E2, center = TRUE, scale = sd(E2, na.rm=TRUE)/0.5), #changed here
           P4.rescale = scale(P4, center = TRUE, scale = sd(P4, na.rm=TRUE)/0.5)) %>% #changed here
    ungroup()
  
  # Indicators for menstrual bleeding
  bleeding_indicator <- data.frame(xmin = 0.5, xmax = 0.7, ymin = -Inf, ymax = Inf)
  
  for (DV in DV_list) {
    
    if (DV %in% c("E2", "P4", "LH")) {
      # Raw plot for E2, P4, LH
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p1 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.1) +
        geom_point(size = 1) +
        geom_line(size = 1) +
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      ggsave(filename = paste0(output_folder, "/", DV, "_", "raw", ".png"), plot = last_plot(), width = 8, height = 6)

      
    } else {
      # For DVs that are NOT E2, P4, LH
      
      # Raw data points and line for the dependent variable
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(DV), na.rm = TRUE),
                  se_value = sd(!!sym(DV), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
    # Person-rescaled E2 and P4 lines (thin dotted)  <- Changed variable names here
      e2_std <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(E2.rescale, na.rm = TRUE)) #changed here

      p4_std <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(P4.rescale, na.rm = TRUE))  #changed here
      
      p1 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # Thin dotted lines for E2 and P4
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Raw", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p1)
      
      # Deviations plot
      dev_var <- paste0(DV, ".d")
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p2 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p2)
      
            ggsave(filename = paste0(output_folder, "/", DV, "_", "dev", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Person-standardized outcome (zd)
      zd_var <- paste0(DV, ".zd")
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(zd_var), na.rm = TRUE),
                  se_value = sd(!!sym(zd_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p3 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
                  linetype = "solid", color = "forestgreen", size = 1, alpha = 0.9) +  # E2
        geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
                  linetype = "solid", color = "red", size = 1, alpha = 0.8) +  # P4
        ggtitle(paste("Person-standardized", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Person-standardized Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      print(p3)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "zd", ".png"), plot = last_plot(), width = 8, height = 6)

      
      # Rolling deviations plot
      roll_dev_var <- paste0(DV, ".roll.d")
      dv <- dat %>%
        group_by(cycleday_10perc) %>%
        summarise(mean_value = mean(!!sym(roll_dev_var), na.rm = TRUE),
                  se_value = sd(!!sym(roll_dev_var), na.rm = TRUE) / sqrt(n()))  # SE calculation
      
      p4 <- ggplot(dv, aes(x = cycleday_10perc, y = mean_value)) +
        geom_ribbon(aes(ymin = mean_value - se_value, ymax = mean_value + se_value), 
                    fill = "black", alpha = 0.3) +
        geom_point(size = 1) +
        geom_line(size = 2) +
        # geom_line(data = e2_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "blue", size = 1, alpha = 0.6) +  # E2
        # geom_line(data = p4_std, aes(x = cycleday_10perc, y = mean_value), 
        #           linetype = "dotted", color = "forestgreen", size = 1, alpha = 0.6) +  # P4
        ggtitle(paste("Rolling Deviations", DV, "Plot")) +
        xlab("Cycle Day (10% bins)") + ylab(paste(DV, "Rolling Deviation Mean")) +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5, size = 14),
              plot.margin = margin(15, 5, 50, 5)) +
        coord_cartesian(clip = "off") +
        geom_rect(data = bleeding_indicator, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), 
                  fill = "red", alpha = 0.2, inherit.aes = FALSE)
      
      # Plot the data
      print(p4)
                  ggsave(filename = paste0(output_folder, "/", DV, "_", "rolld", ".png"), plot = last_plot(), width = 8, height = 6)

    }
  }
}

# Call the function with the list of dependent variables (DVs)
DVs <- c("E2", "P4", "LH", "CSS_Inatt", "CSS_Inatt_Count", "CSS_HypImp", "CSS_HypImp_Count",
         "CSS_Fx_Total", "CSS_B2_Total", "UPPS_Total", "BDEFS_Total", "DEBQ_Total")

plot_DVs(DVs, dat)

```













########## PRIOR ANALYSES/ CODE BEFORE CYCLE SCALING





# Changes in careless responding across the menstrual cycle - BY ID

```{r}
# Define the output directory - DO THIS FOR EACH DAY YOU RUN IT

dailydir <- '~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-16'

# Loop through each participant ID and call the function - CSS_Fx_Total
for (participant_id in id_list) {
  plot_participant_data(df, participant_id, 'longstring', "Length of Identical Responding", dailydir)
}
```



# CALLING PERSON GRAPHING FUNCTIONS
## 1 - MAKE ALL CSS_Fx_Total + Hormone GRAPHS - Loop through each participant ID and call the function - CSS_Fx_Total
```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}

# Define the output directory - DO THIS FOR EACH DAY YOU RUN IT

dailydir <- '~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024_07_09'

# Loop through each participant ID and call the function - CSS_Fx_Total
for (participant_id in id_list) {
  plot_participant_data(df, participant_id, 'CSS_Fx_Total', "CSS Functional Impact", dailydir)
}


```

## 2 - MAKE ALL HYPIMP + Hormone GRAPHS - Loop through each participant ID and call the function - CSS_HypImp
```{r warning=FALSE}
# Define the output directory - DO THIS FOR EACH DAY YOU RUN IT

dailydir <- '/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024_07_09'


# Loop through each participant ID and call the function - CSS_HypImp
for (participant_id in id_list) {
  plot_participant_data(df, participant_id, 'CSS_HypImp', "CSS Hyperactivity/Impulsivity", dailydir)
}

```

## 3 - MAKE ALL INATT + Hormone GRAPHS - Loop through each participant ID and call the function - CSS_Inatt
```{r warning=FALSE}

# Define the output directory - DO THIS FOR EACH DAY YOU RUN IT

dailydir <- '/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024_07_09'

# Loop through each participant ID and call the function - CSS_Inatt
for (participant_id in id_list) {
  plot_participant_data(df, participant_id, 'CSS_Inatt', "CSS Inattentiveness", dailydir)
}
```

## 4 - MAKE ALL INATT COUNT + Hormone GRAPHS - Loop through each participant ID and call the function
```{r warning=FALSE}

# Define the output directory - DO THIS FOR EACH DAY YOU RUN IT

dailydir <- '/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024_07_09'

# Loop through each participant ID and call the function - CSS_Inatt
for (participant_id in id_list) {
  plot_participant_data(df, participant_id, 'CSS_Inatt_Count', "CSS Inattentive Criteria (Count)", dailydir)
}
```

## 5 - MAKE ALL HYPIMP COUNT + Hormone GRAPHS - Loop through each participant ID and call the function
```{r warning=FALSE}

# Define the output directory - DO THIS FOR EACH DAY YOU RUN IT

dailydir <- '/Users/taem-macbook-air/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024_07_09'

# Loop through each participant ID and call the function
for (participant_id in id_list) {
  plot_participant_data(df, participant_id, 'CSS_HypImp_Count', "CSS Hyperactive/Impulsive Criteria (Count)", dailydir)
}
```




# Create plot_interaction function
```{r}

# Define the function
plot_interaction <- function(data, outcome, dailydir) {
  # Check for problematic values in the specified variables
  data_clean <- data %>%
    filter(!is.na(.data[[outcome]]) & !is.nan(.data[[outcome]]) & !is.infinite(.data[[outcome]]) &
           !is.na(E2) & !is.nan(E2) & !is.infinite(E2) &
           !is.na(P4) & !is.nan(P4) & !is.infinite(P4))
  
  # Scale predictors by random effect and calculate daily derivatives
  data_clean <- data_clean %>%
    group_by(id) %>%
    mutate(
      E2zd = scale(E2),
      P4zd = scale(P4),
      E2ch = c(NA, diff(E2)),  # Daily derivative for E2
      P4ch = c(NA, diff(P4))   # Daily derivative for P4
    ) %>%
    filter(!is.na(E2zd) & !is.nan(E2zd) & !is.infinite(E2zd) &
           !is.na(P4zd) & !is.nan(P4zd) & !is.infinite(P4zd) &
           !is.na(E2ch) & !is.nan(E2ch) & !is.infinite(E2ch) &
           !is.na(P4ch) & !is.nan(P4ch) & !is.infinite(P4ch)) %>%
    ungroup()
  
  # Create log-transformed outcome
  data_clean <- data_clean %>%
    mutate(log_outcome = log(.data[[outcome]])) %>%
    filter(!is.na(log_outcome) & !is.nan(log_outcome) & !is.infinite(log_outcome))
  
  # Fit the models with cleaned data
  rawmodel <- lmer(as.formula(paste(outcome, "~ E2zd * P4zd + (1 | id)")), data = data_clean)
  logmodel <- lmer(log_outcome ~ E2zd * P4zd + (1 | id), data = data_clean)
  model_prand <- lmer(log_outcome ~ E2zd * P4zd + (1 + P4zd | id), data = data_clean)
  model_erand <- lmer(log_outcome ~ E2zd * P4zd + (1 + E2zd | id), data = data_clean)
  model_derivs <- lmer(log_outcome ~ E2zd * P4zd + E2ch + P4ch + (1 | id), data = data_clean)
  
  # Print the model summaries
  # print(summary(rawmodel))
  # print(summary(logmodel))
  # print(summary(model_prand))
  # print(summary(model_erand))
  # print(summary(model_derivs))
  
  # Specify the file path for the HTML output - primary model of E2 * P4
  output_file <- file.path(dailydir, paste(outcome, "horm_tabmodel_output.html", sep = ""))
  cat("Output file path:", output_file, "\n")
  
  # Generate the HTML output from tab_model without saving to a file
  tab_model(rawmodel, logmodel, model_prand, model_erand, model_derivs)
  tab_model_output <- tab_model(rawmodel, logmodel, model_prand, model_erand, model_derivs)
  
  # Capture the HTML output as a string
  html_output <- as.character(tab_model_output)
  
  # Manually write the HTML output to the specified file
  writeLines(html_output, con = output_file)
  
  # Create a grid of values for predictors
  E2zd_seq <- seq(min(data_clean$E2zd), max(data_clean$E2zd), length.out = 100)
  P4zd_seq <- seq(min(data_clean$P4zd), max(data_clean$P4zd), length.out = 100)
  
  # Create a dataframe with all combinations of E2zd and P4zd
  grid_df <- expand.grid(E2zd = E2zd_seq, P4zd = P4zd_seq)
  
  # Add the mean values of the derivatives to the grid_df
  grid_df$E2ch <- mean(data_clean$E2ch, na.rm = TRUE)
  grid_df$P4ch <- mean(data_clean$P4ch, na.rm = TRUE)
  
  # Predict the outcome over the grid
  grid_df$predicted_log_outcome <- predict(logmodel, newdata = grid_df, re.form = NA)
  
  # Exponentiate the predicted values to return them to the original scale
  grid_df$predicted_outcome <- exp(grid_df$predicted_log_outcome)

# Create the interaction plot
intplot <- ggplot(grid_df, aes(x = E2zd, y = predicted_outcome, color = P4zd, group = P4zd)) +
    geom_line() +
    labs(
        title = paste("Interaction between E2zd and P4zd on", outcome),
        x = "E2zd",
        y = paste("Predicted", outcome),
        color = "P4zd"
    ) +
    theme_minimal(base_size = 15) +
    scale_color_gradient(low = "blue", high = "red") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(face = "bold"),
        legend.title = element_text(face = "bold"),
        panel.background = element_rect(fill = "white", color = NA), # White background
        plot.background = element_rect(fill = "white", color = NA),  # White background
        panel.grid.major = element_line(color = "gray90"), # Light gray major grid lines
        panel.grid.minor = element_line(color = "gray95")  # Lighter gray minor grid lines
    )

  # Save and return the plot
  ggsave(filename = file.path(dailydir, paste0("EPintplot_", outcome, ".tif")), plot = intplot, width = 12, height = 8, units = "in")
  
  return(intplot)
}


```

#Interaction Plots (running "plot_interaction")

```{r}

dailydir <- '~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-20'


plot_interaction(df_sens, "longstring", dailydir)


# Example usage
plot_interaction(df_sens, "CSS_Inatt", dailydir)
plot_interaction(df_sens, "CSS_Inatt_Count", dailydir) *SIG

plot_interaction(df_sens, "CSS_HypImp", dailydir)
plot_interaction(df_sens, "CSS_HypImp_Count", dailydir)

plot_interaction(df_sens, "CSS_Fx_Total", dailydir)

plot_interaction(df_sens, "CSS_B2_Total", dailydir)

plot_interaction(df_sens, "UPPS_Total", dailydir)

plot_interaction(df_sens, "BDEFS_Total", dailydir)

 plot_interaction(df_sens, "DEBQ_Total", dailydir)

```







# Function to plot by cycle day ("plot_by_cycle_day")
```{r}
plot_by_cycle_day <- function(df, var) {
#Create individual overall means

df <- df %>%
group_by(id) %>%
mutate(var.roll.m = mean(.data[[var]], na.rm = TRUE))

dfcycdayplotdata <- df %>%
group_by(id, hybridcycleday) %>%
filter(!is.na(hybridcycleday)) %>%
summarize(
var.roll.m = mean(var.roll.m, na.rm = TRUE),
var.day.roll.m = mean(.data[[var]], na.rm = TRUE),
var.day.roll.d = var.day.roll.m - var.roll.m
) %>%
arrange(factor(hybridcycleday, levels = hybridcycleday_order))

#print(dfcycdayplotdata)

cycd_plot <- dfcycdayplotdata %>%
group_by(hybridcycleday) %>%
summarize(
personcentered.dev = mean(var.day.roll.d, na.rm = TRUE),
se = sd(var.day.roll.d, na.rm = TRUE) / sqrt(n())
) %>%
arrange(factor(hybridcycleday, levels = hybridcycleday_order)) %>%
ggplot(aes(x = factor(hybridcycleday, levels = hybridcycleday_order), y = personcentered.dev)) +
geom_line(group = 1) +
#geom_ribbon(aes(ymin = personcentered.dev - se, ymax = personcentered.dev + se), alpha = 0.2) +
geom_hline(yintercept = 0, linetype = "solid", col = "black") +

geom_errorbar(aes(ymin = personcentered.dev - se, ymax = personcentered.dev + se), size = 0.5, width = 0.5, position = position_dodge()) +
#scale_y_continuous(expand = c(0, 0.011)) +
theme_bw() +
xlab("Cycle Day\n(Relative to LH-surge and Menses Onset)") +
ylab(paste("Person-Centered", var)) +

  #Midfollicular Label
annotate("rect", ymin = .35, ymax = .45, xmin = "-7L", xmax = "-3L", alpha = .2) +
annotate("text", x = "-7L", y = .4, label = "Midfollicular", size = 3, hjust = -0.25) +
  
  #Periovulatory Label
annotate("rect", ymin = .35, ymax = .45, xmin = "-2L", xmax = "1L", alpha = .2) +
annotate("text", x = "-2L", y = .4, label = "Periovulatory", size = 3, hjust = 0) +
  
  #Early Luteal Label
annotate("rect", ymin = .35, ymax = .45, xmin = "2L", xmax = "5L", alpha = .2) +
annotate("text", x = "2L", y = .4, label = " Early Luteal", size = 3, hjust = 0) +
 
   #Midluteal Label
annotate("rect", ymin = .35, ymax = .45, xmin = "-9M", xmax = "-5M", alpha = .2) +
annotate("text", x = "-9M", y = .4, label = "Midluteal", size = 3, hjust = -0.5) +

  #Perimenstrual Label
annotate("rect", ymin = .35, ymax = .45, xmin = "-3M", xmax = "2M", alpha = .2) +
annotate("text", x = "-3M", y = .4, label = "Perimenstrual", size = 3, hjust = -0.15) +
 
   #Annotation of Ovulation
annotate("text", x = "0L", y = -.25, label = "*", size = 8, color = "forestgreen") +
 
   #Annotation of Menses
annotate("text", x = "1M", y = -.25, label = "*", size = 8, color = "red")
print(cycd_plot)
}

```

# Function to plot by cycle phase ("plot_by_cycle_phase")
```{r warning=FALSE}

plot_by_cycle_phase <- function(df, var) {
  df$cyclephase_LH_graph <- as.factor(df$cyclephase_LH_graph)
  
  # Calculate overall mean for each individual
  df <- df %>%
    group_by(id) %>%
    mutate(overall_mean = mean(.data[[var]], na.rm = TRUE)) %>%
    ungroup()
  
  # Print intermediate data for debugging
  # print(head(df))
  
  # Calculate phase-specific deviation
  dfphaseplotdata <- df %>%
    filter(!is.na(cyclephase_LH_graph)) %>%
    group_by(id, cyclephase_LH_graph) %>%
    summarize(
      phase_mean = mean(.data[[var]], na.rm = TRUE),
      overall_mean = first(overall_mean)
    ) %>%
    mutate(phase_deviation = phase_mean - overall_mean) %>%
    ungroup()
  
  # Print intermediate data for debugging
  # print(head(dfphaseplotdata))
  
  # Calculate grand mean and standard error
  phase_plot_data <- dfphaseplotdata %>%
    group_by(cyclephase_LH_graph) %>%
    summarize(
      grand_mean_deviation = mean(phase_deviation, na.rm = TRUE),
      se = sd(phase_deviation, na.rm = TRUE) / sqrt(n())
    )
  
  # Print summarized data for debugging
 # print(head(phase_plot_data))
  
  # Create the plot
  phase_plot <- phase_plot_data %>%
    ggplot(aes(x = cyclephase_LH_graph, y = grand_mean_deviation, group = 1)) +
    geom_line() + # Add the line
    scale_x_discrete(labels = c(
      "1" = "Midfollicular",
      "2" = "Periovulatory", 
      "3" = "Early Luteal",
      "4" = "Midluteal",
      "5" = "Perimenstrual"
    )) +
    geom_ribbon(aes(ymin = grand_mean_deviation - se, ymax = grand_mean_deviation + se), alpha = 0.2) +
    geom_hline(yintercept = 0.0, color = "black", linetype = "solid") +
    theme_bw(base_size = 11) +
    xlab("Cycle Phase") +
    ylab(paste("Person-Centered", var))
  
  print(phase_plot)
}


```


# FUNCTION TO RUN&SAVE PHASE & CYCLEDAY GRAPHS TO BOX
```{r}

# Define the function
run_and_save_plots <- function(variable_name, df, output_directory) {
  
  # Ensure the output directory exists
  dir.create(output_directory, recursive = TRUE, showWarnings = FALSE)
  
  # Create and save Cycle Day Plot
  day_plot <- plot_by_cycle_day(df, paste0(variable_name, ".roll.d"))
  ggsave(file.path(output_directory, paste0(variable_name, "_DAYPLOT.png")), 
         plot = day_plot, width = 10, height = 6, dpi = 300)
  
  # Create and save Cycle Phase Plot
  phase_plot <- plot_by_cycle_phase(df, paste0(variable_name, ".roll.d"))
  ggsave(file.path(output_directory, paste0(variable_name, "_PHSPLOT.png")), 
         plot = phase_plot, width = 10, height = 6, dpi = 300)
}


```


# Function to run and save MLMs to html in dated Box output folder ("run_and_save_mlms")
```{r message=TRUE, warning=TRUE}

run_and_save_mlms <- function(variable_name, data, output_directory) {
  ## peri
  model_peri <- lmer(as.formula(paste(variable_name, "~ midfol_LH + periov_LH + earlylut_LH + midluteal_LH + (1 | id)")),
                     data = data)
  cat("Peri model fitted.\n")
  
  ## midfol
  model_midfol <- lmer(as.formula(paste(variable_name, "~ periov_LH + earlylut_LH + midluteal_LH + perimenstrual_LH + (1 | id)")),
                       data = data)
  cat("Midfol model fitted.\n")
  
  ## periov
  model_periov <- lmer(as.formula(paste(variable_name, "~ midfol_LH + earlylut_LH + midluteal_LH + perimenstrual_LH + (1 | id)")),
                       data = data)
  cat("Periov model fitted.\n")
  
  ## earlylut
  model_earlylut <- lmer(as.formula(paste(variable_name, "~ midfol_LH + periov_LH + midluteal_LH + perimenstrual_LH + (1 | id)")),
                         data = data)
  cat("Earlylut model fitted.\n")
  
  ## midlut
  model_midlut <- lmer(as.formula(paste(variable_name, "~ midfol_LH + periov_LH + earlylut_LH + perimenstrual_LH + (1 | id)")),
                       data = data)
  cat("Midlut model fitted.\n")
  
  # Create the directory if it doesn't exist
  if (!dir.exists(output_directory)) {
    dir.create(output_directory, recursive = TRUE, showWarnings = FALSE)
    cat("Directory created:", output_directory, "\n")
  } else {
    cat("Directory already exists:", output_directory, "\n")
  }
  
  # Specify the file path for the HTML output
  output_file <- file.path(output_directory, paste(variable_name, "_PHS_tab_model_output.html", sep = ""))
  cat("Output file path:", output_file, "\n")
  
  # Generate the HTML output from tab_model without saving to a file
  tab_model_output <- tab_model(model_midfol, model_periov, model_earlylut, model_midlut, model_peri)
  
  # Capture the HTML output as a string
  html_output <- as.character(tab_model_output)
  
  # Manually write the HTML output to the specified file
  writeLines(html_output, con = output_file)
  
  # Check if the file was created and has content
  if (file.exists(output_file)) {
    cat("HTML output generated and saved to:", output_file, "\n")
  } else {
    cat("Failed to save HTML output to:", output_file, "\n")
  }
}

# Run for all Outcomes

output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"

df <- df

```



# CALL PLOTTING FUNCTIONS FOR CARELESS RESPONDING INDICES

```{r}

plot_by_cycle_day(df_sens, "longstring")
plot_by_cycle_phase(df_sens, "longstring")
```




# CALL PLOTTING FUNCTIONS FOR HORMONES
```{r}

#E2
plot_by_cycle_day(df_sens, "E2")
plot_by_cycle_phase(df_sens, "E2")

#P4
plot_by_cycle_day(df_sens, "P4")
plot_by_cycle_phase(df_sens, "P4")

#LH
plot_by_cycle_day(df_sens, "LH")
plot_by_cycle_phase(df_sens, "LH")



```



# CALL FUNCTIONS: E2

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("E2", df, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "E2"

#### NO NEED TO CHANGE ANYTHING BELOW

df <- df  # Replace with your actual dataframe
output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df, output_directory)

```
# CALL FUNCTIONS: P4

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("P4", df, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "P4"

#### NO NEED TO CHANGE ANYTHING BELOW

df <- df  # Replace with your actual dataframe
output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df, output_directory)

```

# CALL FUNCTIONS: LH

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("LH", df, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "LH"

#### NO NEED TO CHANGE ANYTHING BELOW

df <- df  # Replace with your actual dataframe
output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-04"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df, output_directory)

```


# CALL FUNCTION FOR CARELESS RESPONDING VARS

```{r}

output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-20"


run_and_save_plots("longstring", df, output_directory)

```


# CALL FUNCTIONS: CSS_Inatt

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("CSS_Inatt", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "CSS_Inatt"

#### NO NEED TO CHANGE ANYTHING BELOW

output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```

# CALL FUNCTIONS: CSS_HypImp

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("CSS_HypImp", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "CSS_HypImp"

#### NO NEED TO CHANGE ANYTHING BELOW

output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```

# CALL FUNCTIONS: CSS_B2_Total

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("CSS_B2_Total", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "CSS_B2_Total"

#### NO NEED TO CHANGE ANYTHING BELOW

output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```

# CALL FUNCTIONS: CSS_Fx_Total

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("CSS_Fx_Total", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "CSS_Fx_Total"

#### NO NEED TO CHANGE ANYTHING BELOW

output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```


CSS_Inatt_Count, CSS_Hyp_Count, CSS_Imp_Count, DEBQ_Total, BDEFS_Total, UPPS_Total


# CALL FUNCTIONS: CSS_Inatt_Count

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("CSS_Inatt_Count", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "CSS_Inatt_Count"

#### NO NEED TO CHANGE ANYTHING BELOW

output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```



# CALL FUNCTIONS: CSS_Imp_Count

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("CSS_HypImp_Count", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "CSS_HypImp_Count"

#### NO NEED TO CHANGE ANYTHING BELOW

df <- df  # Replace with your actual dataframe
output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```




# CALL FUNCTIONS: BDEFS_Total

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("BDEFS_Total", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "BDEFS_Total"

#### NO NEED TO CHANGE ANYTHING BELOW

df <- df  # Replace with your actual dataframe
output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```



# CALL FUNCTIONS: DEBQ_Total

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("DEBQ_Total", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "DEBQ_Total"

#### NO NEED TO CHANGE ANYTHING BELOW

df <- df  # Replace with your actual dataframe
output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```


# CALL FUNCTIONS: UPPS_Total

```{r}

#SPECIFY VARIABLE NAME FOR MODELS FUNCTION 

run_and_save_mlms("UPPS_Total", df_sens, output_directory)

# SPECIFY VARIABLE NAME FOR GRAPHING FUNCTION

variable_name <- "UPPS_Total"

#### NO NEED TO CHANGE ANYTHING BELOW

df <- df  # Replace with your actual dataframe
output_directory <- "~/Library/CloudStorage/Box-Box/00 - CLEAR Lab (Locked Folders)/02 - Data Management, Analysis, and Papers/Studies_Projects/CYCLEADHD/03_analytic_projects/CYCADHD_PRIMARY/03_code_dataedits_output/2024-07-09"
# Run the plotting function (Phase, Day)
run_and_save_plots(variable_name, df_sens, output_directory)

```


